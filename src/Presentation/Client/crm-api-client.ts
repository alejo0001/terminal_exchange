//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const CRM_API_BASE_URL = new InjectionToken<string>('CRM_API_BASE_URL');

export interface IActionsClient {
    /**
     * Retrieves information about a specific process, including the day, call attempts, and the maximum number of attempts.
     * @param processId (optional) 
     * @return An HTTP response with:
    - ActionInfoDto: Object containing process details such as the day, attempts, and maximum attempts.
     */
    getActionInfo(processId: number | undefined): Observable<ActionInfoDto>;
    /**
     * Retrieves a list of actions associated with a specific process.
     * @param processId (optional) 
     * @return An HTTP response with:
    - List`1: List of actions for the specified process.
     */
    getActionsByProcess(processId: number | undefined): Observable<ActionChildViewModel[]>;
    /**
     * Creates a new action.
     * @param command Object containing the necessary data to create an action:
    - CreateActionCommand: DTO with the details of the action to be created.
     * @return An HTTP response with:
    - Int32: Identifier of the created action.
     */
    create(command: CreateActionCommand): Observable<number>;
    /**
     * Updates an existing action.
     * @param id Unique identifier of the action to update.
     * @param command Object containing the updated data of the action:
    - Id: Must match the `id` parameter.
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
    - BadRequest if the `id` does not match the `Id` field in the command.
     */
    update(id: number, command: UpdateActionCommand): Observable<FileResponse>;
    /**
     * Deletes an action.
     * @param id Unique identifier of the action to delete.
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
     */
    delete(id: number): Observable<FileResponse>;
    /**
     * Checks if there is an active call for a specific process.
     * @param processId (optional) 
     * @return An HTTP response with:
    - Boolean: `true` if there is an active call, otherwise `false`.
     */
    getHasActiveCall(processId: number | undefined): Observable<boolean>;
    /**
     * Retrieves the details of an active call for the current user.
     * @return An HTTP response with:
    - ActiveCallDetailsDto: Object containing the details of the active call.
     */
    getActiveCall(): Observable<ActiveCallDetailsDto>;
    /**
     * Check, whether Action has it's Type
    one of EmailPending, EmailSucceeded or
    EmailFailed.
     */
    checkHasSentEmails(processId: number): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ActionsClient implements IActionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieves information about a specific process, including the day, call attempts, and the maximum number of attempts.
     * @param processId (optional) 
     * @return An HTTP response with:
    - ActionInfoDto: Object containing process details such as the day, attempts, and maximum attempts.
     */
    getActionInfo(processId: number | undefined): Observable<ActionInfoDto> {
        let url_ = this.baseUrl + "/api/Actions/ActionInfo?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionInfoDto>;
        }));
    }

    protected processGetActionInfo(response: HttpResponseBase): Observable<ActionInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionInfoDto>(null as any);
    }

    /**
     * Retrieves a list of actions associated with a specific process.
     * @param processId (optional) 
     * @return An HTTP response with:
    - List`1: List of actions for the specified process.
     */
    getActionsByProcess(processId: number | undefined): Observable<ActionChildViewModel[]> {
        let url_ = this.baseUrl + "/api/Actions/ByProcess?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionsByProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionsByProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActionChildViewModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActionChildViewModel[]>;
        }));
    }

    protected processGetActionsByProcess(response: HttpResponseBase): Observable<ActionChildViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ActionChildViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionChildViewModel[]>(null as any);
    }

    /**
     * Creates a new action.
     * @param command Object containing the necessary data to create an action:
    - CreateActionCommand: DTO with the details of the action to be created.
     * @return An HTTP response with:
    - Int32: Identifier of the created action.
     */
    create(command: CreateActionCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Actions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Updates an existing action.
     * @param id Unique identifier of the action to update.
     * @param command Object containing the updated data of the action:
    - Id: Must match the `id` parameter.
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
    - BadRequest if the `id` does not match the `Id` field in the command.
     */
    update(id: number, command: UpdateActionCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Actions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Deletes an action.
     * @param id Unique identifier of the action to delete.
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
     */
    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Actions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Checks if there is an active call for a specific process.
     * @param processId (optional) 
     * @return An HTTP response with:
    - Boolean: `true` if there is an active call, otherwise `false`.
     */
    getHasActiveCall(processId: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Actions/HasActiveCall?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHasActiveCall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHasActiveCall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetHasActiveCall(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Retrieves the details of an active call for the current user.
     * @return An HTTP response with:
    - ActiveCallDetailsDto: Object containing the details of the active call.
     */
    getActiveCall(): Observable<ActiveCallDetailsDto> {
        let url_ = this.baseUrl + "/api/Actions/ActiveCall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveCall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveCall(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ActiveCallDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ActiveCallDetailsDto>;
        }));
    }

    protected processGetActiveCall(response: HttpResponseBase): Observable<ActiveCallDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActiveCallDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActiveCallDetailsDto>(null as any);
    }

    /**
     * Check, whether Action has it's Type
    one of EmailPending, EmailSucceeded or
    EmailFailed.
     */
    checkHasSentEmails(processId: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Actions/HasSentEmails/{processId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckHasSentEmails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckHasSentEmails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCheckHasSentEmails(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = resultData400 !== undefined ? resultData400 : <any>null;
    
            return throwException("No such process.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

export interface IAnnotationsClient {
    /**
     * Retrieves a list of annotations associated with a specific contact.
     * @param contactId (optional) 
     * @return An HTTP response with:
    - List`1: List of annotations associated with the specified contact.
     */
    getAnnotationsByContact(contactId: number | undefined): Observable<AnnotationDto[]>;
    /**
     * Creates a new annotation.
     * @param command Object containing the necessary data to create an annotation:
    - CreateAnnotationCommand: DTO with the details of the annotation to be created.
     * @return An HTTP response with:
    - Int32: Identifier of the created annotation.
     */
    create(command: CreateAnnotationCommand): Observable<number>;
    /**
     * Updates an existing annotation.
     * @param id Unique identifier of the annotation to be updated.
     * @param command Object containing the updated data of the annotation:
    - Id: Must match the `id` parameter.
     * @return An HTTP response with:
    - NoContent if the operation completes successfully.
    - BadRequest if the `id` does not match the `Id` field in the command.
     */
    update(id: number, command: UpdateAnnotationCommand): Observable<FileResponse>;
    /**
     * Deletes an annotation.
     * @param id Unique identifier of the annotation to be deleted.
     * @return An HTTP response with:
    - NoContent if the operation completes successfully.
     */
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class AnnotationsClient implements IAnnotationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieves a list of annotations associated with a specific contact.
     * @param contactId (optional) 
     * @return An HTTP response with:
    - List`1: List of annotations associated with the specified contact.
     */
    getAnnotationsByContact(contactId: number | undefined): Observable<AnnotationDto[]> {
        let url_ = this.baseUrl + "/api/Annotations/Contact/List?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAnnotationsByContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAnnotationsByContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AnnotationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AnnotationDto[]>;
        }));
    }

    protected processGetAnnotationsByContact(response: HttpResponseBase): Observable<AnnotationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AnnotationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AnnotationDto[]>(null as any);
    }

    /**
     * Creates a new annotation.
     * @param command Object containing the necessary data to create an annotation:
    - CreateAnnotationCommand: DTO with the details of the annotation to be created.
     * @return An HTTP response with:
    - Int32: Identifier of the created annotation.
     */
    create(command: CreateAnnotationCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Annotations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Updates an existing annotation.
     * @param id Unique identifier of the annotation to be updated.
     * @param command Object containing the updated data of the annotation:
    - Id: Must match the `id` parameter.
     * @return An HTTP response with:
    - NoContent if the operation completes successfully.
    - BadRequest if the `id` does not match the `Id` field in the command.
     */
    update(id: number, command: UpdateAnnotationCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Annotations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Deletes an annotation.
     * @param id Unique identifier of the annotation to be deleted.
     * @return An HTTP response with:
    - NoContent if the operation completes successfully.
     */
    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Annotations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface IAppointmentsClient {
    /**
     * Retrieves appointments associated with a specific process.
     * @param processId Unique identifier of the process for which appointments are to be retrieved.
     * @return An HTTP response with:
    - AppointmentDto: Object containing the appointment details (title, date, type).
     */
    getAppointmentsByProcess(processId: number): Observable<AppointmentDto>;
    /**
     * Creates a new appointment associated with a specific contact and process.
     * @param command Command containing the necessary data to create the appointment:
    - CreateAppointmentCommand: DTO with the appointment details.
     * @return An HTTP response with:
    - Unique identifier of the created appointment.
     */
    create(command: CreateAppointmentCommand): Observable<number>;
    /**
     * Updates the details of an existing appointment.
     * @param id Unique identifier of the appointment to be updated.
     * @param command Command with the new appointment data:
    - UpdateAppointmentCommand: DTO with the updated information.
     * @return An HTTP response with:
    - NoContent if the operation is successful.
     */
    update(id: number, command: UpdateAppointmentCommand): Observable<FileResponse>;
    /**
     * Deletes an existing appointment.
     * @param id Unique identifier of the appointment to be deleted.
     * @return An HTTP response with:
    - NoContent if the operation is successful.
     */
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class AppointmentsClient implements IAppointmentsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieves appointments associated with a specific process.
     * @param processId Unique identifier of the process for which appointments are to be retrieved.
     * @return An HTTP response with:
    - AppointmentDto: Object containing the appointment details (title, date, type).
     */
    getAppointmentsByProcess(processId: number): Observable<AppointmentDto> {
        let url_ = this.baseUrl + "/api/Appointments/GetAppointmentsByProcess/{processId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppointmentsByProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppointmentsByProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppointmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppointmentDto>;
        }));
    }

    protected processGetAppointmentsByProcess(response: HttpResponseBase): Observable<AppointmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppointmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppointmentDto>(null as any);
    }

    /**
     * Creates a new appointment associated with a specific contact and process.
     * @param command Command containing the necessary data to create the appointment:
    - CreateAppointmentCommand: DTO with the appointment details.
     * @return An HTTP response with:
    - Unique identifier of the created appointment.
     */
    create(command: CreateAppointmentCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Appointments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Updates the details of an existing appointment.
     * @param id Unique identifier of the appointment to be updated.
     * @param command Command with the new appointment data:
    - UpdateAppointmentCommand: DTO with the updated information.
     * @return An HTTP response with:
    - NoContent if the operation is successful.
     */
    update(id: number, command: UpdateAppointmentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Appointments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Deletes an existing appointment.
     * @param id Unique identifier of the appointment to be deleted.
     * @return An HTTP response with:
    - NoContent if the operation is successful.
     */
    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Appointments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface IContactsClient {
    /**
     * Obtains the details of a specific contact.
     * @return If the contact details were successfully retrieved.
     */
    getDetails(contactId: number, processId: number): Observable<ContactFullDto>;
    /**
     * Creates a new contact in the system.
     * @param command Command with the information of the new contact.
     * @return The identifier of the created contact.
     */
    create(command: CreateContactCommand): Observable<ContactCreated>;
    /**
     * Updates the information of an existing contact.
     * @param command Command with the updated data of the contact.
     * @return If the contact information was successfully updated.
     */
    update(id: number, command: UpdateContactCommand): Observable<FileResponse>;
    /**
     * Deletes a contact from the database.
     * @param id Identifier of the contact to be deleted.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    delete(id: number): Observable<FileResponse>;
    /**
     * Adds a contact to the blacklist.
     * @param command Command that contains the information necessary to perform the operation.
     * @return If the contact was successfully added to the blacklist.
     */
    addToBlacklist(command: AddContactToBlacklistCommand): Observable<number>;
    /**
     * Adds a course to the favorites list or removes it from it.
     * @param command Object that contains the parameters necessary to add or remove a course from favorites:
    - ContactLeadId: Identifier of the associated contact.
    - ProcessId: Identifier of the associated process.
    - CourseFavourite: Indicates whether the course should be added to favorites (true) or removed (false).
     * @return If the course was successfully added or removed from the favorites list.
     */
    addCourseToFavourite(command: AddCourseToFavouriteCommand): Observable<number>;
    /**
     * Deletes a contact from the database.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    getContactGenders(): Observable<ContactGenderDto[]>;
    /**
     * Obtains a list of available address types.
     * @return If the request is processed successfully and the address types are returned.
     */
    getAddressTypes(): Observable<AddressTypeDto[]>;
    /**
     * Obtains a list of available email types.
     * @return If the request is processed successfully and the email types are returned.
     */
    getEmailTypes(): Observable<EmailTypeDto[]>;
    /**
     * Obtains a list of available phone types.
     * @return If the request is processed successfully and the phone types are returned.
     */
    getPhoneTypes(): Observable<PhoneTypeDto[]>;
    /**
     * Verifies the contact information associated with an identification number.
     * @param idCard (optional) 
     * @return If the request is processed successfully and the contact information is returned.
     */
    checkContactIdCard(idCard: string | undefined): Observable<ContactInfoDto>;
    /**
     * Verifies the contact information associated with an email address.
     * @param email (optional) 
     * @return If the request is processed successfully and the contact information is returned.
     */
    checkContactEmail(email: string | undefined): Observable<ContactInfoDto>;
    checkContactPhone(phonePrefix: string | undefined, phone: string | undefined): Observable<ContactInfoDto>;
    /**
     * Recovers a new lead contact based on the provided information.
     * @param command Object that contains the parameters necessary to create a new lead contact:
    - CreateContactLeadCommand: Information of the lead contact to create.
     * @return An integer representing the identifier of the newly created lead contact.
     */
    recover(command: CreateContactLeadCommand): Observable<number>;
    getContactLeadsByContactAndProcess(contactId: number | undefined, processId: number | undefined): Observable<ContactLeadDto[]>;
    /**
     * Obtains a list of lead contacts associated with a specific contact.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the lead contacts are returned.
     */
    getContactLeadsByContact(contactId: number | undefined): Observable<ContactLeadDto[]>;
    /**
     * Deletes a specific lead contact.
     * @param id Identifier of the lead contact to be deleted.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    deleteContactLead(id: number): Observable<FileResponse>;
    /**
     * Obtains a list of faculties associated with a specific contact.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the faculties are returned.
     */
    getContactFaculties(contactId: number | undefined): Observable<FacultyDto[]>;
    /**
     * Adds faculties to a specific contact.
     * @param command Object that contains the parameters necessary to add faculties to the contact:
    - ContactId: Identifier of the contact to which the faculties will be added.
    - FacultiesId: List of identifiers of the faculties to add.
     * @return If the faculties were successfully added to the contact.
     */
    addFaculties(command: AddContactFacultiesCommand): Observable<number>;
    /**
     * Deletes a faculty associated with a specific contact.
     * @param command Object that contains the parameters necessary to delete the faculty:
    - FacultyId: Identifier of the faculty to be deleted.
    - ContactId: Identifier of the contact from which the faculty will be removed.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    removeFaculty(command: RemoveContactFacultyCommand): Observable<FileResponse>;
    /**
     * Obtains a list of specialties associated with a specific contact.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the specialties are returned.
     */
    getContactSpecialities(contactId: number | undefined): Observable<SpecialityDto[]>;
    /**
     * Adds specialties to a specific contact.
     * @param command Object that contains the parameters necessary to add specialties to the contact:
    - ContactId: Identifier of the contact to which the specialties will be added.
    - SpecialitiesId: List of identifiers of the specialties to add.
     * @return If the specialties were successfully added to the contact.
     */
    addSpecialities(command: AddContactSpecialitiesCommand): Observable<number>;
    removeSpecialities(command: RemoveContactSpecialitiesCommand): Observable<FileResponse>;
    /**
     * Deletes specialties associated with a specific contact.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    getTitleTypes(): Observable<TitleTypeDto[]>;
    getContactInfoForTlmk(processId: number | undefined, apiKey: string | undefined): Observable<ContactInfoTlmkDto>;
    /**
     * Adds a new email address to a specific contact.
     * @param command Object that contains the parameters necessary to add the email address:
    - ContactId: Identifier of the contact to which the email address will be added.
    - Email: Email address to add.
    - EmailTypeId: Identifier of the email type.
    - IsDefault: Indicates whether the email address is the default one.
     * @return If the email address was successfully added to the contact.
     */
    addEmailContact(command: AddNewContactEmailCommand): Observable<number>;
    /**
     * Obtains a list of email addresses associated with a specific contact.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the email addresses are returned.
     */
    getContactEmails(contactId: number | undefined): Observable<ContactEmailDto[]>;
    /**
     * Obtains a list of phone numbers associated with a specific contact.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the phone numbers are returned.
     */
    getContactPhones(contactId: number | undefined): Observable<ContactPhoneDto[]>;
    /**
     * Obtains the complete information of a specific contact by its identifier.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the contact information is returned.
     */
    getContactById(contactId: number | undefined): Observable<ContactFullDto>;
    /**
     * Updates the country code of a specific contact.
     * @param command Object that contains the parameters necessary to update the country code:
    - CountryCode: New country code.
    - ContactId: Identifier of the contact whose country code will be updated.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    updateCountryCode(command: UpdateCountryCodeCommand): Observable<FileResponse>;
    /**
     * Updates the currency of a specific contact.
     * @param command Object that contains the parameters necessary to update the currency:
    - CurrencyId: Identifier of the new currency.
    - ContactId: Identifier of the contact whose currency will be updated.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    updateCurrency(command: UpdateCurrencyCommand): Observable<FileResponse>;
    /**
     * Updates the information of a specific lead contact.
     * @param contactLeadId (optional) Identifier of the lead contact to be updated.
     * @param command Object that contains the parameters necessary for the update:
    - ContactLeadId: Identifier of the lead contact.
    - Other fields from ContactLeadUpdateDto that can be updated.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    updateContactLead(contactLeadId: number | undefined, command: UpdateContactLeadCommand): Observable<FileResponse>;
    /**
     * Updates the information of multiple lead contacts.
     * @param command Object that contains the parameters necessary for the update:
    - ContactLeads: List of objects representing the lead contacts to be updated.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    updateContactLeads(command: UpdateContactLeadsCommand): Observable<FileResponse>;
    /**
     * Updates the price of a specific lead contact.
     * @param contactLeadId (optional) Identifier of the lead contact to be updated.
     * @param command Object that contains the parameters necessary for the update:
    - ContactLeadId: Identifier of the lead contact.
    - Other fields from ContactLeadPriceUpdateDto that can be updated.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    updateContactLeadPrice(contactLeadId: number | undefined, command: UpdateContactLeadPriceCommand): Observable<FileResponse>;
    /**
     * Obtains a specific contact using their email address or phone number.
     * @param data_CorrelationId (optional) 
     * @param data_Email (optional) 
     * @param data_Phone (optional) 
     * @param data_CountryCode (optional) 
     * @return If the request is processed successfully and the contact information is returned.
     */
    getContactByEmailOrPhone(data_CorrelationId: string | undefined, data_Email: string | undefined, data_Phone: string | undefined, data_CountryCode: string | undefined): Observable<ContactGetted>;
    /**
     * Checks if a specific contact is a client.
     * @param contactId (optional) 
     * @param originContactId (optional) 
     * @return If the request is processed successfully and the contact's client status is returned.
     */
    getContactIsClient(contactId: number | null | undefined, originContactId: number | null | undefined): Observable<boolean>;
    /**
     * Obtains a list of contact users based on the email address or phone number.
     * @param email (optional) Email address of the contact (optional).
     * @param phone (optional) Phone number of the contact (optional).
     * @return If the request is processed successfully and the contact users are returned.
     */
    getContactUser(email: string | null | undefined, phone: string | null | undefined): Observable<ContactUserDto[]>;
    /**
     * Recupera y reactiva un proceso en el sistema, actualizando su fecha de creacin
    y las acciones asociadas al mismo.
     * @param query El comando que contiene el ID del proceso a recuperar.
     * @return Operacin exitosa. Retorna el ID del proceso actualizado.
     */
    recoverContactActivations(query: RecoverContactActivationsCommand): Observable<number>;
    /**
     * Consolidates Contact related data from origin to destination contact. Origin will be soft-deleted.
     */
    consolidateToOtherContact(command: ConsolidateContactsCommand): Observable<void>;
    /**
     * Consolidates Contact related data from origin to destination contact *by IDs*. Origin will be soft-deleted. As of now uses ApiKey and not token security model.
     */
    consolidateToOtherContactById(command: ConsolidateContactsByIdCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class ContactsClient implements IContactsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Obtains the details of a specific contact.
     * @return If the contact details were successfully retrieved.
     */
    getDetails(contactId: number, processId: number): Observable<ContactFullDto> {
        let url_ = this.baseUrl + "/api/Contacts/{contactId}/{processId}";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId));
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactFullDto>;
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<ContactFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactFullDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactFullDto>(null as any);
    }

    /**
     * Creates a new contact in the system.
     * @param command Command with the information of the new contact.
     * @return The identifier of the created contact.
     */
    create(command: CreateContactCommand): Observable<ContactCreated> {
        let url_ = this.baseUrl + "/api/Contacts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactCreated>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactCreated>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ContactCreated> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactCreated.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactCreated>(null as any);
    }

    /**
     * Updates the information of an existing contact.
     * @param command Command with the updated data of the contact.
     * @return If the contact information was successfully updated.
     */
    update(id: number, command: UpdateContactCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Deletes a contact from the database.
     * @param id Identifier of the contact to be deleted.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Contacts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Adds a contact to the blacklist.
     * @param command Command that contains the information necessary to perform the operation.
     * @return If the contact was successfully added to the blacklist.
     */
    addToBlacklist(command: AddContactToBlacklistCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Contacts/AddToBlacklist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddToBlacklist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToBlacklist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddToBlacklist(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Adds a course to the favorites list or removes it from it.
     * @param command Object that contains the parameters necessary to add or remove a course from favorites:
    - ContactLeadId: Identifier of the associated contact.
    - ProcessId: Identifier of the associated process.
    - CourseFavourite: Indicates whether the course should be added to favorites (true) or removed (false).
     * @return If the course was successfully added or removed from the favorites list.
     */
    addCourseToFavourite(command: AddCourseToFavouriteCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Contacts/AddCourseToFavourite";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCourseToFavourite(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCourseToFavourite(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddCourseToFavourite(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Deletes a contact from the database.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    getContactGenders(): Observable<ContactGenderDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/Gender";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactGenders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactGenders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactGenderDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactGenderDto[]>;
        }));
    }

    protected processGetContactGenders(response: HttpResponseBase): Observable<ContactGenderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactGenderDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactGenderDto[]>(null as any);
    }

    /**
     * Obtains a list of available address types.
     * @return If the request is processed successfully and the address types are returned.
     */
    getAddressTypes(): Observable<AddressTypeDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/Address/Types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddressTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddressTypeDto[]>;
        }));
    }

    protected processGetAddressTypes(response: HttpResponseBase): Observable<AddressTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AddressTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressTypeDto[]>(null as any);
    }

    /**
     * Obtains a list of available email types.
     * @return If the request is processed successfully and the email types are returned.
     */
    getEmailTypes(): Observable<EmailTypeDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/Email/Types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailTypeDto[]>;
        }));
    }

    protected processGetEmailTypes(response: HttpResponseBase): Observable<EmailTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmailTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailTypeDto[]>(null as any);
    }

    /**
     * Obtains a list of available phone types.
     * @return If the request is processed successfully and the phone types are returned.
     */
    getPhoneTypes(): Observable<PhoneTypeDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/Phone/Types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPhoneTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPhoneTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PhoneTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PhoneTypeDto[]>;
        }));
    }

    protected processGetPhoneTypes(response: HttpResponseBase): Observable<PhoneTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PhoneTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PhoneTypeDto[]>(null as any);
    }

    /**
     * Verifies the contact information associated with an identification number.
     * @param idCard (optional) 
     * @return If the request is processed successfully and the contact information is returned.
     */
    checkContactIdCard(idCard: string | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/Contacts/Check/IdCard?";
        if (idCard === null)
            throw new Error("The parameter 'idCard' cannot be null.");
        else if (idCard !== undefined)
            url_ += "IdCard=" + encodeURIComponent("" + idCard) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckContactIdCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckContactIdCard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactInfoDto>;
        }));
    }

    protected processCheckContactIdCard(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(null as any);
    }

    /**
     * Verifies the contact information associated with an email address.
     * @param email (optional) 
     * @return If the request is processed successfully and the contact information is returned.
     */
    checkContactEmail(email: string | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/Contacts/Check/Email?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckContactEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckContactEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactInfoDto>;
        }));
    }

    protected processCheckContactEmail(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(null as any);
    }

    checkContactPhone(phonePrefix: string | undefined, phone: string | undefined): Observable<ContactInfoDto> {
        let url_ = this.baseUrl + "/api/Contacts/Check/Phone?";
        if (phonePrefix === null)
            throw new Error("The parameter 'phonePrefix' cannot be null.");
        else if (phonePrefix !== undefined)
            url_ += "PhonePrefix=" + encodeURIComponent("" + phonePrefix) + "&";
        if (phone === null)
            throw new Error("The parameter 'phone' cannot be null.");
        else if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckContactPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckContactPhone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactInfoDto>;
        }));
    }

    protected processCheckContactPhone(response: HttpResponseBase): Observable<ContactInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoDto>(null as any);
    }

    /**
     * Recovers a new lead contact based on the provided information.
     * @param command Object that contains the parameters necessary to create a new lead contact:
    - CreateContactLeadCommand: Information of the lead contact to create.
     * @return An integer representing the identifier of the newly created lead contact.
     */
    recover(command: CreateContactLeadCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Contacts/Leads";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecover(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecover(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processRecover(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getContactLeadsByContactAndProcess(contactId: number | undefined, processId: number | undefined): Observable<ContactLeadDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/Leads/List?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactLeadsByContactAndProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactLeadsByContactAndProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactLeadDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactLeadDto[]>;
        }));
    }

    protected processGetContactLeadsByContactAndProcess(response: HttpResponseBase): Observable<ContactLeadDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactLeadDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactLeadDto[]>(null as any);
    }

    /**
     * Obtains a list of lead contacts associated with a specific contact.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the lead contacts are returned.
     */
    getContactLeadsByContact(contactId: number | undefined): Observable<ContactLeadDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/Leads/List/contactId?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactLeadsByContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactLeadsByContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactLeadDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactLeadDto[]>;
        }));
    }

    protected processGetContactLeadsByContact(response: HttpResponseBase): Observable<ContactLeadDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactLeadDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactLeadDto[]>(null as any);
    }

    /**
     * Deletes a specific lead contact.
     * @param id Identifier of the lead contact to be deleted.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    deleteContactLead(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Contacts/Leads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteContactLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteContactLead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteContactLead(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Obtains a list of faculties associated with a specific contact.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the faculties are returned.
     */
    getContactFaculties(contactId: number | undefined): Observable<FacultyDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/ContactFaculties?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactFaculties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactFaculties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FacultyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FacultyDto[]>;
        }));
    }

    protected processGetContactFaculties(response: HttpResponseBase): Observable<FacultyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FacultyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacultyDto[]>(null as any);
    }

    /**
     * Adds faculties to a specific contact.
     * @param command Object that contains the parameters necessary to add faculties to the contact:
    - ContactId: Identifier of the contact to which the faculties will be added.
    - FacultiesId: List of identifiers of the faculties to add.
     * @return If the faculties were successfully added to the contact.
     */
    addFaculties(command: AddContactFacultiesCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Contacts/Faculties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddFaculties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddFaculties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddFaculties(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Deletes a faculty associated with a specific contact.
     * @param command Object that contains the parameters necessary to delete the faculty:
    - FacultyId: Identifier of the faculty to be deleted.
    - ContactId: Identifier of the contact from which the faculty will be removed.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    removeFaculty(command: RemoveContactFacultyCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Contacts/Faculty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFaculty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFaculty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveFaculty(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Obtains a list of specialties associated with a specific contact.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the specialties are returned.
     */
    getContactSpecialities(contactId: number | undefined): Observable<SpecialityDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/ContactSpecialities?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactSpecialities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactSpecialities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpecialityDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpecialityDto[]>;
        }));
    }

    protected processGetContactSpecialities(response: HttpResponseBase): Observable<SpecialityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SpecialityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecialityDto[]>(null as any);
    }

    /**
     * Adds specialties to a specific contact.
     * @param command Object that contains the parameters necessary to add specialties to the contact:
    - ContactId: Identifier of the contact to which the specialties will be added.
    - SpecialitiesId: List of identifiers of the specialties to add.
     * @return If the specialties were successfully added to the contact.
     */
    addSpecialities(command: AddContactSpecialitiesCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Contacts/Specialities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSpecialities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSpecialities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddSpecialities(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    removeSpecialities(command: RemoveContactSpecialitiesCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Contacts/Specialities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveSpecialities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveSpecialities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveSpecialities(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Deletes specialties associated with a specific contact.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    getTitleTypes(): Observable<TitleTypeDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/Title/Types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTitleTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTitleTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TitleTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TitleTypeDto[]>;
        }));
    }

    protected processGetTitleTypes(response: HttpResponseBase): Observable<TitleTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TitleTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TitleTypeDto[]>(null as any);
    }

    getContactInfoForTlmk(processId: number | undefined, apiKey: string | undefined): Observable<ContactInfoTlmkDto> {
        let url_ = this.baseUrl + "/api/Contacts/Tlmk?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&";
        if (apiKey === null)
            throw new Error("The parameter 'apiKey' cannot be null.");
        else if (apiKey !== undefined)
            url_ += "ApiKey=" + encodeURIComponent("" + apiKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactInfoForTlmk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactInfoForTlmk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactInfoTlmkDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactInfoTlmkDto>;
        }));
    }

    protected processGetContactInfoForTlmk(response: HttpResponseBase): Observable<ContactInfoTlmkDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactInfoTlmkDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactInfoTlmkDto>(null as any);
    }

    /**
     * Adds a new email address to a specific contact.
     * @param command Object that contains the parameters necessary to add the email address:
    - ContactId: Identifier of the contact to which the email address will be added.
    - Email: Email address to add.
    - EmailTypeId: Identifier of the email type.
    - IsDefault: Indicates whether the email address is the default one.
     * @return If the email address was successfully added to the contact.
     */
    addEmailContact(command: AddNewContactEmailCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Contacts/AddEmailContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEmailContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEmailContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processAddEmailContact(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Obtains a list of email addresses associated with a specific contact.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the email addresses are returned.
     */
    getContactEmails(contactId: number | undefined): Observable<ContactEmailDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/ContactEmails?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactEmails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactEmails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactEmailDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactEmailDto[]>;
        }));
    }

    protected processGetContactEmails(response: HttpResponseBase): Observable<ContactEmailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactEmailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactEmailDto[]>(null as any);
    }

    /**
     * Obtains a list of phone numbers associated with a specific contact.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the phone numbers are returned.
     */
    getContactPhones(contactId: number | undefined): Observable<ContactPhoneDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/ContactPhones?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactPhones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactPhones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactPhoneDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactPhoneDto[]>;
        }));
    }

    protected processGetContactPhones(response: HttpResponseBase): Observable<ContactPhoneDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactPhoneDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactPhoneDto[]>(null as any);
    }

    /**
     * Obtains the complete information of a specific contact by its identifier.
     * @param contactId (optional) 
     * @return If the request is processed successfully and the contact information is returned.
     */
    getContactById(contactId: number | undefined): Observable<ContactFullDto> {
        let url_ = this.baseUrl + "/api/Contacts/GetContactById?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactFullDto>;
        }));
    }

    protected processGetContactById(response: HttpResponseBase): Observable<ContactFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactFullDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactFullDto>(null as any);
    }

    /**
     * Updates the country code of a specific contact.
     * @param command Object that contains the parameters necessary to update the country code:
    - CountryCode: New country code.
    - ContactId: Identifier of the contact whose country code will be updated.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    updateCountryCode(command: UpdateCountryCodeCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Contacts/UpdateCountryCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCountryCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCountryCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateCountryCode(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Updates the currency of a specific contact.
     * @param command Object that contains the parameters necessary to update the currency:
    - CurrencyId: Identifier of the new currency.
    - ContactId: Identifier of the contact whose currency will be updated.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    updateCurrency(command: UpdateCurrencyCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Contacts/UpdateCurrency";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrency(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateCurrency(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Updates the information of a specific lead contact.
     * @param contactLeadId (optional) Identifier of the lead contact to be updated.
     * @param command Object that contains the parameters necessary for the update:
    - ContactLeadId: Identifier of the lead contact.
    - Other fields from ContactLeadUpdateDto that can be updated.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    updateContactLead(contactLeadId: number | undefined, command: UpdateContactLeadCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Contacts/ContactLead?";
        if (contactLeadId === null)
            throw new Error("The parameter 'contactLeadId' cannot be null.");
        else if (contactLeadId !== undefined)
            url_ += "contactLeadId=" + encodeURIComponent("" + contactLeadId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactLead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactLead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateContactLead(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Updates the information of multiple lead contacts.
     * @param command Object that contains the parameters necessary for the update:
    - ContactLeads: List of objects representing the lead contacts to be updated.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    updateContactLeads(command: UpdateContactLeadsCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Contacts/ContactLeads";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactLeads(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactLeads(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateContactLeads(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Updates the price of a specific lead contact.
     * @param contactLeadId (optional) Identifier of the lead contact to be updated.
     * @param command Object that contains the parameters necessary for the update:
    - ContactLeadId: Identifier of the lead contact.
    - Other fields from ContactLeadPriceUpdateDto that can be updated.
     * @return An object of type ActionResult indicating the result of the operation.
     */
    updateContactLeadPrice(contactLeadId: number | undefined, command: UpdateContactLeadPriceCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Contacts/ContactLeadPrice?";
        if (contactLeadId === null)
            throw new Error("The parameter 'contactLeadId' cannot be null.");
        else if (contactLeadId !== undefined)
            url_ += "contactLeadId=" + encodeURIComponent("" + contactLeadId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContactLeadPrice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContactLeadPrice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateContactLeadPrice(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Obtains a specific contact using their email address or phone number.
     * @param data_CorrelationId (optional) 
     * @param data_Email (optional) 
     * @param data_Phone (optional) 
     * @param data_CountryCode (optional) 
     * @return If the request is processed successfully and the contact information is returned.
     */
    getContactByEmailOrPhone(data_CorrelationId: string | undefined, data_Email: string | undefined, data_Phone: string | undefined, data_CountryCode: string | undefined): Observable<ContactGetted> {
        let url_ = this.baseUrl + "/api/Contacts/GetContactByEmailOrPhone?";
        if (data_CorrelationId === null)
            throw new Error("The parameter 'data_CorrelationId' cannot be null.");
        else if (data_CorrelationId !== undefined)
            url_ += "Data.CorrelationId=" + encodeURIComponent("" + data_CorrelationId) + "&";
        if (data_Email === null)
            throw new Error("The parameter 'data_Email' cannot be null.");
        else if (data_Email !== undefined)
            url_ += "Data.Email=" + encodeURIComponent("" + data_Email) + "&";
        if (data_Phone === null)
            throw new Error("The parameter 'data_Phone' cannot be null.");
        else if (data_Phone !== undefined)
            url_ += "Data.Phone=" + encodeURIComponent("" + data_Phone) + "&";
        if (data_CountryCode === null)
            throw new Error("The parameter 'data_CountryCode' cannot be null.");
        else if (data_CountryCode !== undefined)
            url_ += "Data.CountryCode=" + encodeURIComponent("" + data_CountryCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactByEmailOrPhone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactByEmailOrPhone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactGetted>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactGetted>;
        }));
    }

    protected processGetContactByEmailOrPhone(response: HttpResponseBase): Observable<ContactGetted> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactGetted.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactGetted>(null as any);
    }

    /**
     * Checks if a specific contact is a client.
     * @param contactId (optional) 
     * @param originContactId (optional) 
     * @return If the request is processed successfully and the contact's client status is returned.
     */
    getContactIsClient(contactId: number | null | undefined, originContactId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Contacts/GetContactIsClient?";
        if (contactId !== undefined && contactId !== null)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (originContactId !== undefined && originContactId !== null)
            url_ += "OriginContactId=" + encodeURIComponent("" + originContactId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactIsClient(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactIsClient(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetContactIsClient(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Obtains a list of contact users based on the email address or phone number.
     * @param email (optional) Email address of the contact (optional).
     * @param phone (optional) Phone number of the contact (optional).
     * @return If the request is processed successfully and the contact users are returned.
     */
    getContactUser(email: string | null | undefined, phone: string | null | undefined): Observable<ContactUserDto[]> {
        let url_ = this.baseUrl + "/api/Contacts/GetContactUser?";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (phone !== undefined && phone !== null)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ContactUserDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ContactUserDto[]>;
        }));
    }

    protected processGetContactUser(response: HttpResponseBase): Observable<ContactUserDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactUserDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContactUserDto[]>(null as any);
    }

    /**
     * Recupera y reactiva un proceso en el sistema, actualizando su fecha de creacin
    y las acciones asociadas al mismo.
     * @param query El comando que contiene el ID del proceso a recuperar.
     * @return Operacin exitosa. Retorna el ID del proceso actualizado.
     */
    recoverContactActivations(query: RecoverContactActivationsCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Contacts/RecoverContactActivations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRecoverContactActivations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRecoverContactActivations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processRecoverContactActivations(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Consolidates Contact related data from origin to destination contact. Origin will be soft-deleted.
     */
    consolidateToOtherContact(command: ConsolidateContactsCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Contacts/ConsolidateToOtherContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsolidateToOtherContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsolidateToOtherContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsolidateToOtherContact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Validation failures", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Contacts cannot be found by provided emails", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Contacts cannot refer to the same Contact ID.", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Among others, problem saving changes.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Consolidates Contact related data from origin to destination contact *by IDs*. Origin will be soft-deleted. As of now uses ApiKey and not token security model.
     */
    consolidateToOtherContactById(command: ConsolidateContactsByIdCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Contacts/ConsolidateToOtherContactById";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConsolidateToOtherContactById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConsolidateToOtherContactById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConsolidateToOtherContactById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("Validation failures", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Contacts cannot be found by provided IDs", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Contacts cannot refer to the same Contact ID.", status, _responseText, _headers, result409);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ProblemDetails.fromJS(resultData500);
            return throwException("Among others, problem saving changes.", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface ICountriesClient {
    /**
     * Obtains a list of countries.
     * @return If the request is processed successfully and the countries are returned.
     */
    getCountries(): Observable<CountryDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CountriesClient implements ICountriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Obtains a list of countries.
     * @return If the request is processed successfully and the countries are returned.
     */
    getCountries(): Observable<CountryDto[]> {
        let url_ = this.baseUrl + "/api/Countries/List";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CountryDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CountryDto[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<CountryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CountryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountryDto[]>(null as any);
    }
}

export interface ICouponsClient {
    /**
     * Copies the information of a contact to a FP coupon.
     * @param command Command that contains the necessary parameters for the operation:
    - ContactId: Identifier of the contact.
    - ProcessId: Identifier of the process.
     * @return If the request is processed successfully and the operation is completed.
     */
    copyToCouponFp(command: CopyToCouponFpCommand): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class CouponsClient implements ICouponsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Copies the information of a contact to a FP coupon.
     * @param command Command that contains the necessary parameters for the operation:
    - ContactId: Identifier of the contact.
    - ProcessId: Identifier of the process.
     * @return If the request is processed successfully and the operation is completed.
     */
    copyToCouponFp(command: CopyToCouponFpCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Coupons/CopyToCouponFp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyToCouponFp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyToCouponFp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCopyToCouponFp(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }
}

export interface ICouponsOriginsClient {
    /**
     * Obtains a list of coupon origins.
     * @return If the request is processed successfully and the coupon origins are returned.
     */
    getCouponsOrigins(): Observable<CouponsOriginsDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CouponsOriginsClient implements ICouponsOriginsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Obtains a list of coupon origins.
     * @return If the request is processed successfully and the coupon origins are returned.
     */
    getCouponsOrigins(): Observable<CouponsOriginsDto[]> {
        let url_ = this.baseUrl + "/api/CouponsOrigins/List";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCouponsOrigins(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCouponsOrigins(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CouponsOriginsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CouponsOriginsDto[]>;
        }));
    }

    protected processGetCouponsOrigins(response: HttpResponseBase): Observable<CouponsOriginsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CouponsOriginsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CouponsOriginsDto[]>(null as any);
    }
}

export interface ICourseCountriesClient {
    getCourseCountriesByCountryCodeAndLanguageCode(countryCode: string | undefined, languageCode: string | undefined): Observable<CourseCountryDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CourseCountriesClient implements ICourseCountriesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCourseCountriesByCountryCodeAndLanguageCode(countryCode: string | undefined, languageCode: string | undefined): Observable<CourseCountryDto> {
        let url_ = this.baseUrl + "/api/CourseCountries?";
        if (countryCode === null)
            throw new Error("The parameter 'countryCode' cannot be null.");
        else if (countryCode !== undefined)
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (languageCode === null)
            throw new Error("The parameter 'languageCode' cannot be null.");
        else if (languageCode !== undefined)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCourseCountriesByCountryCodeAndLanguageCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCourseCountriesByCountryCodeAndLanguageCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CourseCountryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CourseCountryDto>;
        }));
    }

    protected processGetCourseCountriesByCountryCodeAndLanguageCode(response: HttpResponseBase): Observable<CourseCountryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CourseCountryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CourseCountryDto>(null as any);
    }
}

export interface ICoursesClient {
    getTopSellingByFacultiesAndCountry(countryCode: string | undefined, facultiesId: number[] | null | undefined, quantity: number | null | undefined): Observable<TopSellingCourseDto[]>;
    /**
     * Population of missing interested courses based on the top-selling courses.
     * @param command Command that contains the necessary parameters for the operation:
    - Area: Area of interest.
    - CountryCode: Country code.
    - ApiKey: API key.
    - MaxJobContacts: Maximum contacts to process (optional).
    - ContactIds: Contact identifiers (optional).
     * @return An object of type IActionResult indicating the status of the operation.
     */
    populateMissingInterestedCoursesByTopSellers(command: PopulateMissingInterestedCoursesCommand): Observable<PopulateMissingInterestedCoursesResult>;
    /**
     * Population of missing interested courses based on the top-selling courses without waiting.
     * @param command Command that contains the necessary parameters for the operation:
    - Area: Area of interest.
    - CountryCode: Country code.
    - ApiKey: API key.
    - MaxJobContacts: Maximum contacts to process (optional).
    - ContactIds: Contact identifiers (optional).
     * @return An object of type IActionResult indicating the status of the operation.
     */
    populateMissingInterestedCoursesByTopSellersNoWait(command: PopulateMissingInterestedCoursesCommand): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class CoursesClient implements ICoursesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTopSellingByFacultiesAndCountry(countryCode: string | undefined, facultiesId: number[] | null | undefined, quantity: number | null | undefined): Observable<TopSellingCourseDto[]> {
        let url_ = this.baseUrl + "/api/Courses/TopSellingByFacultiesAndCountry?";
        if (countryCode === null)
            throw new Error("The parameter 'countryCode' cannot be null.");
        else if (countryCode !== undefined)
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (facultiesId !== undefined && facultiesId !== null)
            facultiesId && facultiesId.forEach(item => { url_ += "FacultiesId=" + encodeURIComponent("" + item) + "&"; });
        if (quantity !== undefined && quantity !== null)
            url_ += "Quantity=" + encodeURIComponent("" + quantity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopSellingByFacultiesAndCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopSellingByFacultiesAndCountry(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TopSellingCourseDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TopSellingCourseDto[]>;
        }));
    }

    protected processGetTopSellingByFacultiesAndCountry(response: HttpResponseBase): Observable<TopSellingCourseDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TopSellingCourseDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TopSellingCourseDto[]>(null as any);
    }

    /**
     * Population of missing interested courses based on the top-selling courses.
     * @param command Command that contains the necessary parameters for the operation:
    - Area: Area of interest.
    - CountryCode: Country code.
    - ApiKey: API key.
    - MaxJobContacts: Maximum contacts to process (optional).
    - ContactIds: Contact identifiers (optional).
     * @return An object of type IActionResult indicating the status of the operation.
     */
    populateMissingInterestedCoursesByTopSellers(command: PopulateMissingInterestedCoursesCommand): Observable<PopulateMissingInterestedCoursesResult> {
        let url_ = this.baseUrl + "/api/Courses/populate-missing-interested-courses-by-top-sellers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPopulateMissingInterestedCoursesByTopSellers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPopulateMissingInterestedCoursesByTopSellers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PopulateMissingInterestedCoursesResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PopulateMissingInterestedCoursesResult>;
        }));
    }

    protected processPopulateMissingInterestedCoursesByTopSellers(response: HttpResponseBase): Observable<PopulateMissingInterestedCoursesResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PopulateMissingInterestedCoursesResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("If the request is invalid or required parameters are missing.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PopulateMissingInterestedCoursesResult>(null as any);
    }

    /**
     * Population of missing interested courses based on the top-selling courses without waiting.
     * @param command Command that contains the necessary parameters for the operation:
    - Area: Area of interest.
    - CountryCode: Country code.
    - ApiKey: API key.
    - MaxJobContacts: Maximum contacts to process (optional).
    - ContactIds: Contact identifiers (optional).
     * @return An object of type IActionResult indicating the status of the operation.
     */
    populateMissingInterestedCoursesByTopSellersNoWait(command: PopulateMissingInterestedCoursesCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Courses/populate-missing-interested-courses-by-top-sellers-nowait";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPopulateMissingInterestedCoursesByTopSellersNoWait(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPopulateMissingInterestedCoursesByTopSellersNoWait(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPopulateMissingInterestedCoursesByTopSellersNoWait(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 202) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result202: any = null;
            let resultData202 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result202 = resultData202 !== undefined ? resultData202 : <any>null;
    
            return _observableOf(result202);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ErrorDto.fromJS(resultData400);
            return throwException("If the request is invalid or required parameters are missing.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

export interface ICurrenciesClient {
    /**
     * Obtains the currency information based on the currency code.
     * @param currencyCode (optional) 
     * @return If the request is processed successfully and the currency information is returned.
     */
    getCurrencyByCode(currencyCode: string | undefined): Observable<CurrencyDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CurrenciesClient implements ICurrenciesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Obtains the currency information based on the currency code.
     * @param currencyCode (optional) 
     * @return If the request is processed successfully and the currency information is returned.
     */
    getCurrencyByCode(currencyCode: string | undefined): Observable<CurrencyDto> {
        let url_ = this.baseUrl + "/api/Currencies/CurrencyByCode?";
        if (currencyCode === null)
            throw new Error("The parameter 'currencyCode' cannot be null.");
        else if (currencyCode !== undefined)
            url_ += "CurrencyCode=" + encodeURIComponent("" + currencyCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencyByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyByCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrencyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrencyDto>;
        }));
    }

    protected processGetCurrencyByCode(response: HttpResponseBase): Observable<CurrencyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyDto>(null as any);
    }
}

export interface IEmailsClient {
    getEmailsByContactWithPagination(contactId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | undefined, order: string[] | undefined): Observable<PaginatedListOfEmailPaginationDto>;
    /**
     * Sends an email with the option to attach files.
     * @param attachments (optional) 
     * @param contactId (optional) 
     * @param contactLeadId (optional) 
     * @param courseId (optional) 
     * @param processId (optional) 
     * @param to (optional) 
     * @param cc (optional) 
     * @param bcc (optional) 
     * @param subject (optional) 
     * @param body (optional) 
     * @param dossiers (optional) 
     * @param colour (optional) 
     * @param emailDefault (optional) 
     * @return If the request is processed successfully and the identifier of the email is returned.
     */
    send(attachments: FileParameter[] | null | undefined, contactId: number | undefined, contactLeadId: number[] | null | undefined, courseId: number | null | undefined, processId: number | undefined, to: string | undefined, cc: string | null | undefined, bcc: string | null | undefined, subject: string | undefined, body: string | undefined, dossiers: string[] | null | undefined, colour: Colour | undefined, emailDefault: string | null | undefined): Observable<number>;
    /**
     * Obtains the details of an email based on its identifier.
     * @param id Identifier of the email.
     * @return If the request is processed successfully and the details of the email are returned.
     */
    getDetails(id: number): Observable<EmailFullDto>;
    /**
     * Checks if the mailbox is free (LOGIC MISSING).
     * @param query (optional) Query that contains the necessary parameters for the operation (currently no parameters are required).
     * @return If the request is processed successfully and the status of the mailbox is returned.
     */
    getMailBoxFree(query: GetMailBoxFreeQuery | undefined): Observable<boolean>;
    /**
     * Gets emails send to client with process and contact id.
     * @param contactId (optional) 
     * @param processId (optional) 
     */
    getEmailsByContactAndProcess(contactId: number | undefined, processId: number | undefined): Observable<EmailFullDto[]>;
    /**
     * Send a Email to Client using correct Template.
     * @param command Object containing the parameters required to send the email:
    - ApiKey: API key required for authentication.
     * @return A string describing the operation's result, indicating the email delivery status.
     */
    sendEmailRecords2(command: SendEmailCommercialAssignmentCommand): Observable<void>;
    /**
     * Send a email of Scholarship Activation R2 to Client using correct Template.
     * @param command Object containing the parameters required to send the email:
    - ApiKey: API key required for authentication.
     * @return A string describing the operation's result, indicating the email delivery status.
     */
    sendEmailScholarshipActivation(command: SendEmailRecords2ScholarshipActivationCommand): Observable<void>;
    /**
     * Send a email for close Process to Client using correct Template (1.2.A).
     * @param command Object containing the parameters required to send the email:
    - ApiKey: API key required for authentication.
     * @return A string describing the operation's result, indicating the email delivery status.
     */
    sendEmailCloseProcesses(command: SendEmailCloseProcessesCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class EmailsClient implements IEmailsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getEmailsByContactWithPagination(contactId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | undefined, order: string[] | undefined): Observable<PaginatedListOfEmailPaginationDto> {
        let url_ = this.baseUrl + "/api/Emails?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (queryParams === null)
            throw new Error("The parameter 'queryParams' cannot be null.");
        else if (queryParams !== undefined)
            url_ += "QueryParams=" + encodeURIComponent("" + queryParams) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            orderBy && orderBy.forEach(item => { url_ += "OrderBy=" + encodeURIComponent("" + item) + "&"; });
        if (order === null)
            throw new Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            order && order.forEach(item => { url_ += "Order=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailsByContactWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailsByContactWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfEmailPaginationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfEmailPaginationDto>;
        }));
    }

    protected processGetEmailsByContactWithPagination(response: HttpResponseBase): Observable<PaginatedListOfEmailPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfEmailPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfEmailPaginationDto>(null as any);
    }

    /**
     * Sends an email with the option to attach files.
     * @param attachments (optional) 
     * @param contactId (optional) 
     * @param contactLeadId (optional) 
     * @param courseId (optional) 
     * @param processId (optional) 
     * @param to (optional) 
     * @param cc (optional) 
     * @param bcc (optional) 
     * @param subject (optional) 
     * @param body (optional) 
     * @param dossiers (optional) 
     * @param colour (optional) 
     * @param emailDefault (optional) 
     * @return If the request is processed successfully and the identifier of the email is returned.
     */
    send(attachments: FileParameter[] | null | undefined, contactId: number | undefined, contactLeadId: number[] | null | undefined, courseId: number | null | undefined, processId: number | undefined, to: string | undefined, cc: string | null | undefined, bcc: string | null | undefined, subject: string | undefined, body: string | undefined, dossiers: string[] | null | undefined, colour: Colour | undefined, emailDefault: string | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Emails";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (attachments !== null && attachments !== undefined)
            attachments.forEach(item_ => content_.append("Attachments", item_.data, item_.fileName ? item_.fileName : "Attachments") );
        if (contactId === null || contactId === undefined)
            throw new Error("The parameter 'contactId' cannot be null.");
        else
            content_.append("ContactId", contactId.toString());
        if (contactLeadId !== null && contactLeadId !== undefined)
            contactLeadId.forEach(item_ => content_.append("ContactLeadId", item_.toString()));
        if (courseId !== null && courseId !== undefined)
            content_.append("CourseId", courseId.toString());
        if (processId === null || processId === undefined)
            throw new Error("The parameter 'processId' cannot be null.");
        else
            content_.append("ProcessId", processId.toString());
        if (to === null || to === undefined)
            throw new Error("The parameter 'to' cannot be null.");
        else
            content_.append("To", to.toString());
        if (cc !== null && cc !== undefined)
            content_.append("Cc", cc.toString());
        if (bcc !== null && bcc !== undefined)
            content_.append("Bcc", bcc.toString());
        if (subject === null || subject === undefined)
            throw new Error("The parameter 'subject' cannot be null.");
        else
            content_.append("Subject", subject.toString());
        if (body === null || body === undefined)
            throw new Error("The parameter 'body' cannot be null.");
        else
            content_.append("Body", body.toString());
        if (dossiers !== null && dossiers !== undefined)
            dossiers.forEach(item_ => content_.append("Dossiers", item_.toString()));
        if (colour === null || colour === undefined)
            throw new Error("The parameter 'colour' cannot be null.");
        else
            content_.append("Colour", colour.toString());
        if (emailDefault !== null && emailDefault !== undefined)
            content_.append("EmailDefault", emailDefault.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Obtains the details of an email based on its identifier.
     * @param id Identifier of the email.
     * @return If the request is processed successfully and the details of the email are returned.
     */
    getDetails(id: number): Observable<EmailFullDto> {
        let url_ = this.baseUrl + "/api/Emails/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailFullDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailFullDto>;
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<EmailFullDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmailFullDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailFullDto>(null as any);
    }

    /**
     * Checks if the mailbox is free (LOGIC MISSING).
     * @param query (optional) Query that contains the necessary parameters for the operation (currently no parameters are required).
     * @return If the request is processed successfully and the status of the mailbox is returned.
     */
    getMailBoxFree(query: GetMailBoxFreeQuery | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Emails/MailBoxFree?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMailBoxFree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMailBoxFree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processGetMailBoxFree(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Gets emails send to client with process and contact id.
     * @param contactId (optional) 
     * @param processId (optional) 
     */
    getEmailsByContactAndProcess(contactId: number | undefined, processId: number | undefined): Observable<EmailFullDto[]> {
        let url_ = this.baseUrl + "/api/Emails/byContactAndProcessId?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEmailsByContactAndProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEmailsByContactAndProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmailFullDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmailFullDto[]>;
        }));
    }

    protected processGetEmailsByContactAndProcess(response: HttpResponseBase): Observable<EmailFullDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmailFullDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmailFullDto[]>(null as any);
    }

    /**
     * Send a Email to Client using correct Template.
     * @param command Object containing the parameters required to send the email:
    - ApiKey: API key required for authentication.
     * @return A string describing the operation's result, indicating the email delivery status.
     */
    sendEmailRecords2(command: SendEmailCommercialAssignmentCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Emails/SendEmailCommercialAssignment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailRecords2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailRecords2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailRecords2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Send a email of Scholarship Activation R2 to Client using correct Template.
     * @param command Object containing the parameters required to send the email:
    - ApiKey: API key required for authentication.
     * @return A string describing the operation's result, indicating the email delivery status.
     */
    sendEmailScholarshipActivation(command: SendEmailRecords2ScholarshipActivationCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Emails/SendEmailRecords2ScholarshipActivation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailScholarshipActivation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailScholarshipActivation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailScholarshipActivation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Send a email for close Process to Client using correct Template (1.2.A).
     * @param command Object containing the parameters required to send the email:
    - ApiKey: API key required for authentication.
     * @return A string describing the operation's result, indicating the email delivery status.
     */
    sendEmailCloseProcesses(command: SendEmailCloseProcessesCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Emails/SendEmailCloseProcesses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailCloseProcesses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailCloseProcesses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailCloseProcesses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }
}

export interface IEmployeeClient {
    /**
     * Retrieves all subordinates of a manager.
     * @param query (optional) Query containing the necessary parameters for the operation (currently no parameters are required).
     * @return If the request is successfully processed and the manager's subordinates are returned.
     */
    getAllManagerSubordinates(query: GetAllManagerSubordinatesQuery | undefined): Observable<EmployeeSubordinateViewModel[]>;
    /**
     * Retrieves the manager associated with an employee.
     * @param query (optional) Query containing the necessary parameters for the operation (currently no parameters are required).
     * @return If the request is successfully processed and the manager associated with the employee is returned.
     */
    getAllManagerByEmployee(query: GetManagerByEmployeeQuery | undefined): Observable<ManagerDto>;
    /**
     * Retrieves the information of the logged-in employee.
     * @return If the request is successfully processed and the employee information is returned.
     */
    getLoggedEmployee(): Observable<EmployeeDto>;
    /**
     * Retrieves the signature associated with a corporate email.
     * @param corporateEmail The corporate email of the employee.
     * @return If the request is successfully processed and the employee's signature is returned.
     */
    getSignature(corporateEmail: string): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class EmployeeClient implements IEmployeeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieves all subordinates of a manager.
     * @param query (optional) Query containing the necessary parameters for the operation (currently no parameters are required).
     * @return If the request is successfully processed and the manager's subordinates are returned.
     */
    getAllManagerSubordinates(query: GetAllManagerSubordinatesQuery | undefined): Observable<EmployeeSubordinateViewModel[]> {
        let url_ = this.baseUrl + "/api/Employee/GetAllManagerSubordinates?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllManagerSubordinates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllManagerSubordinates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeSubordinateViewModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeSubordinateViewModel[]>;
        }));
    }

    protected processGetAllManagerSubordinates(response: HttpResponseBase): Observable<EmployeeSubordinateViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EmployeeSubordinateViewModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeSubordinateViewModel[]>(null as any);
    }

    /**
     * Retrieves the manager associated with an employee.
     * @param query (optional) Query containing the necessary parameters for the operation (currently no parameters are required).
     * @return If the request is successfully processed and the manager associated with the employee is returned.
     */
    getAllManagerByEmployee(query: GetManagerByEmployeeQuery | undefined): Observable<ManagerDto> {
        let url_ = this.baseUrl + "/api/Employee/GetAllManagerByEmployee?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllManagerByEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllManagerByEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ManagerDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ManagerDto>;
        }));
    }

    protected processGetAllManagerByEmployee(response: HttpResponseBase): Observable<ManagerDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ManagerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ManagerDto>(null as any);
    }

    /**
     * Retrieves the information of the logged-in employee.
     * @return If the request is successfully processed and the employee information is returned.
     */
    getLoggedEmployee(): Observable<EmployeeDto> {
        let url_ = this.baseUrl + "/api/Employee";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoggedEmployee(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoggedEmployee(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EmployeeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EmployeeDto>;
        }));
    }

    protected processGetLoggedEmployee(response: HttpResponseBase): Observable<EmployeeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EmployeeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeDto>(null as any);
    }

    /**
     * Retrieves the signature associated with a corporate email.
     * @param corporateEmail The corporate email of the employee.
     * @return If the request is successfully processed and the employee's signature is returned.
     */
    getSignature(corporateEmail: string): Observable<string> {
        let url_ = this.baseUrl + "/api/Employee/Signatures/{corporateEmail}";
        if (corporateEmail === undefined || corporateEmail === null)
            throw new Error("The parameter 'corporateEmail' must be defined.");
        url_ = url_.replace("{corporateEmail}", encodeURIComponent("" + corporateEmail));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSignature(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSignature(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSignature(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

export interface IFacultiesClient {
    /**
     * Retrieves the list of faculties.
     * @return If the request is successfully processed and the list of faculties is returned.
     */
    getFaculties(): Observable<FacultyDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class FacultiesClient implements IFacultiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieves the list of faculties.
     * @return If the request is successfully processed and the list of faculties is returned.
     */
    getFaculties(): Observable<FacultyDto[]> {
        let url_ = this.baseUrl + "/api/Faculties/List";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFaculties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFaculties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FacultyDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FacultyDto[]>;
        }));
    }

    protected processGetFaculties(response: HttpResponseBase): Observable<FacultyDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FacultyDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FacultyDto[]>(null as any);
    }
}

export interface IFlowsClient {
    /**
     * Retrieves the list of flows.
     * @return If the request is successfully processed and the list of flows is returned.
     */
    getFlows(): Observable<FlowDto[]>;
    /**
     * Duplicates an existing flow.
     * @param command Command containing the necessary parameters for the operation:
    - OriginProcessType: Process type of the original flow.
    - OriginTagId: Tag identifier of the original flow.
    - TagId: Tag identifier for the new flow.
    - TagName: Tag name for the new flow.
     * @return If the request is successfully processed and the flow is duplicated.
     */
    duplicateFlow(command: DuplicateFlowCommand): Observable<Unit>;
}

@Injectable({
    providedIn: 'root'
})
export class FlowsClient implements IFlowsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieves the list of flows.
     * @return If the request is successfully processed and the list of flows is returned.
     */
    getFlows(): Observable<FlowDto[]> {
        let url_ = this.baseUrl + "/api/Flows/GetFlows";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFlows(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFlows(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FlowDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FlowDto[]>;
        }));
    }

    protected processGetFlows(response: HttpResponseBase): Observable<FlowDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FlowDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FlowDto[]>(null as any);
    }

    /**
     * Duplicates an existing flow.
     * @param command Command containing the necessary parameters for the operation:
    - OriginProcessType: Process type of the original flow.
    - OriginTagId: Tag identifier of the original flow.
    - TagId: Tag identifier for the new flow.
    - TagName: Tag name for the new flow.
     * @return If the request is successfully processed and the flow is duplicated.
     */
    duplicateFlow(command: DuplicateFlowCommand): Observable<Unit> {
        let url_ = this.baseUrl + "/api/Flows/DuplicateFlow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDuplicateFlow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDuplicateFlow(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processDuplicateFlow(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(null as any);
    }
}

export interface IInvoicePaymentOptionsClient {
    getInvoicePaymentOptionsByContactWithPagination(contactId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | undefined, order: string[] | undefined): Observable<PaginatedListOfInvoicePaymentOptionDto>;
    /**
     * Creates a new invoice payment option.
     * @param command Command containing the necessary parameters for the operation:
    - Property1: Description of property 1 (adjust according to InvoicePaymentOptionCreateDto properties).
    - Property2: Description of property 2 (adjust according to InvoicePaymentOptionCreateDto properties).
     * @return If the request is successfully processed and the identifier of the created invoice payment option is returned.
     */
    create(command: CreateInvoicePaymentOptionCommand): Observable<number>;
    /**
     * Updates an existing invoice payment option.
     * @param id Identifier of the invoice payment option to be updated.
     * @param command Command containing the necessary parameters for the operation:
    - Id: Identifier of the invoice payment option.
    - Property1: Description of property 1 (adjust according to InvoicePaymentOptionUpdateDto properties).
    - Property2: Description of property 2 (adjust according to InvoicePaymentOptionUpdateDto properties).
     * @return An ActionResult indicating the result of the operation.
     */
    update(id: number, command: UpdateInvoicePaymentOptionCommand): Observable<FileResponse>;
    /**
     * Deletes an existing invoice payment option.
     * @param id Identifier of the invoice payment option to be deleted.
     * @return An ActionResult indicating the result of the operation.
     */
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class InvoicePaymentOptionsClient implements IInvoicePaymentOptionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getInvoicePaymentOptionsByContactWithPagination(contactId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | undefined, order: string[] | undefined): Observable<PaginatedListOfInvoicePaymentOptionDto> {
        let url_ = this.baseUrl + "/api/InvoicePaymentOptions?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (queryParams === null)
            throw new Error("The parameter 'queryParams' cannot be null.");
        else if (queryParams !== undefined)
            url_ += "QueryParams=" + encodeURIComponent("" + queryParams) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            orderBy && orderBy.forEach(item => { url_ += "OrderBy=" + encodeURIComponent("" + item) + "&"; });
        if (order === null)
            throw new Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            order && order.forEach(item => { url_ += "Order=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoicePaymentOptionsByContactWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoicePaymentOptionsByContactWithPagination(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfInvoicePaymentOptionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfInvoicePaymentOptionDto>;
        }));
    }

    protected processGetInvoicePaymentOptionsByContactWithPagination(response: HttpResponseBase): Observable<PaginatedListOfInvoicePaymentOptionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfInvoicePaymentOptionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfInvoicePaymentOptionDto>(null as any);
    }

    /**
     * Creates a new invoice payment option.
     * @param command Command containing the necessary parameters for the operation:
    - Property1: Description of property 1 (adjust according to InvoicePaymentOptionCreateDto properties).
    - Property2: Description of property 2 (adjust according to InvoicePaymentOptionCreateDto properties).
     * @return If the request is successfully processed and the identifier of the created invoice payment option is returned.
     */
    create(command: CreateInvoicePaymentOptionCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/InvoicePaymentOptions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Updates an existing invoice payment option.
     * @param id Identifier of the invoice payment option to be updated.
     * @param command Command containing the necessary parameters for the operation:
    - Id: Identifier of the invoice payment option.
    - Property1: Description of property 1 (adjust according to InvoicePaymentOptionUpdateDto properties).
    - Property2: Description of property 2 (adjust according to InvoicePaymentOptionUpdateDto properties).
     * @return An ActionResult indicating the result of the operation.
     */
    update(id: number, command: UpdateInvoicePaymentOptionCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/InvoicePaymentOptions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Deletes an existing invoice payment option.
     * @param id Identifier of the invoice payment option to be deleted.
     * @return An ActionResult indicating the result of the operation.
     */
    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/InvoicePaymentOptions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface ILanguagesClient {
    /**
     * Retrieves the list of available languages.
     * @return If the request is successfully processed and the list of languages is returned.
     */
    getLanguages(): Observable<LanguageDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class LanguagesClient implements ILanguagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieves the list of available languages.
     * @return If the request is successfully processed and the list of languages is returned.
     */
    getLanguages(): Observable<LanguageDto[]> {
        let url_ = this.baseUrl + "/api/Languages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LanguageDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LanguageDto[]>;
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<LanguageDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguageDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LanguageDto[]>(null as any);
    }
}

export interface IMessagesClient {
    send(contactId: number | undefined, processId: number | undefined, contactLeadList: number[] | null | undefined, colour: Colour | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class MessagesClient implements IMessagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    send(contactId: number | undefined, processId: number | undefined, contactLeadList: number[] | null | undefined, colour: Colour | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Messages?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&";
        if (contactLeadList !== undefined && contactLeadList !== null)
            contactLeadList && contactLeadList.forEach(item => { url_ += "ContactLeadList=" + encodeURIComponent("" + item) + "&"; });
        if (colour === null)
            throw new Error("The parameter 'colour' cannot be null.");
        else if (colour !== undefined)
            url_ += "Colour=" + encodeURIComponent("" + colour) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface IOrdersImportedClient {
    getOrdersImportedByContact(contactId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | undefined, order: string[] | undefined): Observable<PaginatedListOfOrdersImportedDto>;
    getOrdersImportedByContactAll(contactId: number | undefined, contactEmails: string[] | null | undefined): Observable<OrdersImportedDto[]>;
    /**
     * Retrieves the details of a specific imported order by its ID.
     * @param id The ID of the imported order to retrieve.
     * @return The details of the imported order.
     */
    getDetails(id: number): Observable<OrdersImportedDto>;
    /**
     * Creates and saves a new imported order from TLMK.
     * @param command The command containing the information of the order to be imported from TLMK.
     * @return The ID of the created imported order.
     */
    saveOrderFromTlmk(command: CreateOrdersImportedFromTlmkCommand): Observable<number>;
    /**
     * Updates the status of a process based on the order number.
     * @param command The command containing the order number, the new process status, the outcome, and the payment type.
     * @return A string indicating the result of the operation.
     */
    setProcessByOrderNumber(command: SetProcessStatusByOrderNumberCommand): Observable<string>;
    /**
     * Deletes imported orders associated with a list of email addresses.
     * @param command The command containing the list of email addresses associated with the orders to be deleted.
     * @return A list of IDs of the deleted orders.
     */
    deleteOrderImportedFromTlmkByEmail(command: DeleteOrderImportedFromTlmkByEmailCommand): Observable<number[]>;
}

@Injectable({
    providedIn: 'root'
})
export class OrdersImportedClient implements IOrdersImportedClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getOrdersImportedByContact(contactId: number | undefined, pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | undefined, order: string[] | undefined): Observable<PaginatedListOfOrdersImportedDto> {
        let url_ = this.baseUrl + "/api/OrdersImported/paginated?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (queryParams === null)
            throw new Error("The parameter 'queryParams' cannot be null.");
        else if (queryParams !== undefined)
            url_ += "QueryParams=" + encodeURIComponent("" + queryParams) + "&";
        if (orderBy === null)
            throw new Error("The parameter 'orderBy' cannot be null.");
        else if (orderBy !== undefined)
            orderBy && orderBy.forEach(item => { url_ += "OrderBy=" + encodeURIComponent("" + item) + "&"; });
        if (order === null)
            throw new Error("The parameter 'order' cannot be null.");
        else if (order !== undefined)
            order && order.forEach(item => { url_ += "Order=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersImportedByContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersImportedByContact(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfOrdersImportedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfOrdersImportedDto>;
        }));
    }

    protected processGetOrdersImportedByContact(response: HttpResponseBase): Observable<PaginatedListOfOrdersImportedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfOrdersImportedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfOrdersImportedDto>(null as any);
    }

    getOrdersImportedByContactAll(contactId: number | undefined, contactEmails: string[] | null | undefined): Observable<OrdersImportedDto[]> {
        let url_ = this.baseUrl + "/api/OrdersImported?";
        if (contactId === null)
            throw new Error("The parameter 'contactId' cannot be null.");
        else if (contactId !== undefined)
            url_ += "ContactId=" + encodeURIComponent("" + contactId) + "&";
        if (contactEmails !== undefined && contactEmails !== null)
            contactEmails && contactEmails.forEach(item => { url_ += "ContactEmails=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersImportedByContactAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersImportedByContactAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersImportedDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersImportedDto[]>;
        }));
    }

    protected processGetOrdersImportedByContactAll(response: HttpResponseBase): Observable<OrdersImportedDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrdersImportedDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrdersImportedDto[]>(null as any);
    }

    /**
     * Retrieves the details of a specific imported order by its ID.
     * @param id The ID of the imported order to retrieve.
     * @return The details of the imported order.
     */
    getDetails(id: number): Observable<OrdersImportedDto> {
        let url_ = this.baseUrl + "/api/OrdersImported/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrdersImportedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrdersImportedDto>;
        }));
    }

    protected processGetDetails(response: HttpResponseBase): Observable<OrdersImportedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrdersImportedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrdersImportedDto>(null as any);
    }

    /**
     * Creates and saves a new imported order from TLMK.
     * @param command The command containing the information of the order to be imported from TLMK.
     * @return The ID of the created imported order.
     */
    saveOrderFromTlmk(command: CreateOrdersImportedFromTlmkCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/OrdersImported/Tlmk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveOrderFromTlmk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveOrderFromTlmk(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processSaveOrderFromTlmk(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Updates the status of a process based on the order number.
     * @param command The command containing the order number, the new process status, the outcome, and the payment type.
     * @return A string indicating the result of the operation.
     */
    setProcessByOrderNumber(command: SetProcessStatusByOrderNumberCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/OrdersImported/SetProcessStatusByOrderNumber";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetProcessByOrderNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetProcessByOrderNumber(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSetProcessByOrderNumber(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }

    /**
     * Deletes imported orders associated with a list of email addresses.
     * @param command The command containing the list of email addresses associated with the orders to be deleted.
     * @return A list of IDs of the deleted orders.
     */
    deleteOrderImportedFromTlmkByEmail(command: DeleteOrderImportedFromTlmkByEmailCommand): Observable<number[]> {
        let url_ = this.baseUrl + "/api/OrdersImported/DeleteOrderImportedFromTlmkByEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrderImportedFromTlmkByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrderImportedFromTlmkByEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number[]>;
        }));
    }

    protected processDeleteOrderImportedFromTlmkByEmail(response: HttpResponseBase): Observable<number[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number[]>(null as any);
    }
}

export interface IProcessesClient {
    /**
     * Retrieves a list of processes that are "in progress" and related to the authenticated user.
     * @param pageNumber (optional) 
     * @param userId (optional) 
     * @param pageSize (optional) 
     * @param queryParams (optional) 
     * @param email (optional) 
     * @param phone (optional) 
     * @param countryCode (optional) 
     * @param orderBy (optional) 
     * @param order (optional) 
     * @param facultiesList (optional) 
     * @param specialitiesList (optional) 
     * @param userData (optional) 
     * @return A PaginatedList`1 object containing the paginated list of processes in progress.
     */
    getProcessesInProgressByUser(pageNumber: number | undefined, userId: number | undefined, pageSize: number | undefined, queryParams: string | undefined, email: string | null | undefined, phone: string | null | undefined, countryCode: string | null | undefined, orderBy: string[] | null | undefined, order: string[] | null | undefined, facultiesList: number[] | null | undefined, specialitiesList: number[] | null | undefined, userData: string | null | undefined): Observable<PaginatedListOfProcessInProgressDto>;
    /**
     * Retrieves a list of processes that are "in progress" and associated with a specific user.
     * @param pageNumber (optional) 
     * @param userId (optional) 
     * @param pageSize (optional) 
     * @param queryParams (optional) 
     * @param email (optional) 
     * @param phone (optional) 
     * @param countryCode (optional) 
     * @param orderBy (optional) 
     * @param order (optional) 
     * @param facultiesList (optional) 
     * @param specialitiesList (optional) 
     * @param userData (optional) 
     * @return A paginated list of in-progress processes as PaginatedList`1.
     */
    getProcessesInProgressByUser2(pageNumber: number | undefined, userId: number | undefined, pageSize: number | undefined, queryParams: string | undefined, email: string | null | undefined, phone: string | null | undefined, countryCode: string | null | undefined, orderBy: string[] | null | undefined, order: string[] | null | undefined, facultiesList: number[] | null | undefined, specialitiesList: number[] | null | undefined, userData: string | null | undefined): Observable<PaginatedListOfProcessDto>;
    /**
     * Retrieves a paginated list of closed processes that did not result in a sale and are associated with the authenticated user.
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param queryParams (optional) 
     * @param orderBy (optional) 
     * @param order (optional) 
     * @return A PaginatedList`1 object containing the paginated list of closed processes without a sale 
    associated with the authenticated user.
     */
    getProcessesNotSalesByUser(pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | null | undefined, order: string[] | null | undefined): Observable<PaginatedListOfProcessDto>;
    /**
     * Retrieves a list of processes managed by a specific user, filtered by an optional sales type.
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param queryParams (optional) 
     * @param orderBy (optional) 
     * @param order (optional) 
     * @return A list of ProcessSalesDto objects representing the sales processes managed by the specified user.
     */
    getProcessesSalesByUser(pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | null | undefined, order: string[] | null | undefined): Observable<PaginatedListOfProcessDto>;
    /**
     * Retrieves a paginated list of pending processes associated with a specific user.
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param queryParams (optional) 
     * @param orderBy (optional) 
     * @param order (optional) 
     * @param userData (optional) 
     * @return A PaginatedList`1 object containing the paginated list of pending processes
    associated with the specified user.
     */
    getProcessesPendingByUser(pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | null | undefined, order: string[] | null | undefined, userData: string | null | undefined): Observable<PaginatedListOfProcessDto>;
    /**
     * Retrieves the active process types associated with the current user.
     * @return A list of ProcessTypeDto objects representing the currently active (ongoing or pending) process types for the user.
     */
    getTypesActiveProcesses(): Observable<ProcessTypeDto[]>;
    /**
     * Retrieves the sales status of a specific process.
     * @param processId Identifier of the process for which the sales status is to be obtained.
     * @return A ProcessSaleStatusDto object containing the sales status of the process.
    - SaleComplete: Indicates whether the sale is complete.
     */
    getProcessSaleStatus(processId: number): Observable<ProcessSaleStatusDto>;
    /**
     * Retrieves the number of sales attempts for a specific process.
     * @param processId Identifier of the process for which the number of sales attempts is to be obtained.
     * @return A ProcessSaleAttemtpsDto object containing the number of sales attempts for the process.
    - SaleAttemtps: Number of sales attempts recorded for the process.
     */
    getProcessSaleAttempts(processId: number): Observable<ProcessSaleAttemtpsDto>;
    /**
     * Checks if the current user can create a new recovery process.
     * @return A ActionResult<bool> indicating whether the user can create a recovery process.
    - true if the user can create a new recovery process; otherwise, false.
     */
    canCreateRecoverProcess(): Observable<boolean>;
    /**
     * Retrieves a list of all available discard reasons.
     * @return A list of DiscardReasonDto objects representing the discard reasons.
     */
    getAllDiscardReasons(): Observable<DiscardReasonDto[]>;
    /**
     * Retrieves a list of open processes associated with a specific contact.
     * @param contactId Identifier of the contact for whom the open processes are to be retrieved.
     * @return A list of ProcessDto objects representing the open processes.
     */
    getOpenProcessesByContactId(contactId: number): Observable<ProcessDto[]>;
    /**
     * Date Local Time with unspecified type Zone (without HourZone). Expected: 2024-09-03T09:00:00.000
     * @param processId Identifier of the process for which the suggested interaction date is to be obtained.
     * @param dateLocalEmployee Employee's local date and time in string format, without a specified time zone. 
    Expected format: 2024-09-03T09:34:56.789
     * @return A suggested date and time for the next interaction, or null if it cannot be determined.
     */
    getSuggestedNextInteractionDate(processId: number, dateLocalEmployee: string): Observable<Date | null>;
    /**
     * Creates a new process.
     * @param command Object containing the necessary data for creating the process.
     * @return The unique identifier (Int32) of the newly created process.
     */
    create(command: CreateProcessCommand): Observable<number>;
    /**
     * Sets a web sales process using the contact's email, phone, or ID.
     * @param command Object containing the parameters required to set the sales process:
    - Email: Contact's email address.
    - Phone: Contact's phone number.
    - Dni: Contact's ID.
     * @return A Unit object indicating the operation was completed successfully.
     */
    saleProcessByEmailOrPhoneOrDniCommand(command: SetWebSaleProcessByEmailOrPhoneOrDniCommand): Observable<Unit>;
    /**
     * Updates the data of an existing process.
     * @param id The unique identifier (Int32) of the process to be updated.
     * @param command Object containing the updated data for the process. This command inherits from ProcessUpdateDto.
     * @return Returns an HTTP result:
    - BadRequest if the identifier provided in the parameter does not match the ID in the command.
    - NoContent if the update is successfully completed.
     */
    update(id: number, command: UpdateProcessCommand): Observable<FileResponse>;
    /**
     * Marks a process as deleted by its identifier.
     * @param id The unique identifier of the process to delete.
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
     */
    delete(id: number): Observable<FileResponse>;
    /**
     * Changes the color associated with a specific process.
     * @param processId (optional) 
     * @param color (optional) 
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
     */
    changeProcessColor(processId: number | undefined, color: Colour | undefined): Observable<FileResponse>;
    /**
     * Closes pending sales processes based on the associated order number or email address.
     * @param command Object of type CloseProcessSaleByOrderNumberOrEmailCommand containing a list of 
    OrderImportedUpdateDto objects with the following information:
    - OrderNumber: Order number associated with the process.
    - PaymentType: Type of payment made.
    - PaymentDate: Date of the payment.
    - Status: Order status (e.g., "CANCELLED").
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
     */
    closeProcessSaleByOrderNumberOrEmail(command: OrderImportedUpdateDto[]): Observable<FileResponse>;
    /**
     * Reassigns a process to a different user.
     * @param command Object containing the data necessary for the reassignment:
    - ProcessId: Unique identifier of the process.
    - UserId: Identifier of the user to whom the process will be reassigned.
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
     */
    reassignProcess(command: ReassignProcessCommand): Observable<FileResponse>;
    /**
     * Reassigns all processes from one user to another user.
     * @param fromUserId (optional) 
     * @param toUserId (optional) 
     * @param onlyToDo (optional) 
     * @return An HTTP response:
    - NoContent if the operation is successful.
     */
    reassignAllProcesses(fromUserId: number | undefined, toUserId: number | undefined, onlyToDo: boolean | undefined): Observable<FileResponse>;
    /**
     * Processes a successful external sale and updates the associated contact and process information.
     * @param command Object containing the parameters required to process the successful external sale:
    - ProcessId: Identifier of the associated process.
    - IdCard: Contact's ID.
    - Email: Contact's email address.
    - Address: Contact's address.
    - PostalCode: Postal code of the address.
    - Country: Country code.
    - Province: Province of the address.
    - City: City of the address.
    - OrderNumber: Order number.
    - OrderDate: Order date.
    - AcademicTitle: Academic title.
    - InitDate: Start date.
    - PaymentType: Payment type.
    - CurrencyCountry: Currency country.
    - NumberDeadLines: Number of installments.
    - SalesCountry: Sales country.
    - AmountRegistration: Registration amount.
     * @return An ActionResult object indicating the operation's result.
    - NoContent if the operation was completed successfully.
     */
    externalSuccessfulSaleProcessCommand(command: ExternalSuccessfulSaleProcessCommand): Observable<FileResponse>;
    /**
     * Closes the processes specified in the list of process identifiers.
     * @param processIds (optional) 
     * @param isAutomatic (optional) 
     * @return An ActionResult object indicating the operation's result.
    - NoContent if the operation was completed successfully.
     */
    closeProcessesCommand(processIds: number[] | undefined, isAutomatic: boolean | null | undefined): Observable<FileResponse>;
    /**
     * Replaces an existing process with a new one for a priority commercial user.
     * @param processId (optional) 
     * @return An ActionResult<int> object containing the identifier of the newly created process.
     */
    replaceProcessForPriorityCommercial(processId: number | undefined): Observable<number>;
    /**
     * Devuelve los contactos comerciales para entrega basados en el correo electrnico corporativo proporcionado.
     * @param corporateEmail (optional) 
     * @param apiKey (optional) 
     * @return Las fechas de reparto y el estado de los procesos se actualizaron correctamente.
     */
    returnBusinnesContactsDelivery(corporateEmail: string | undefined, apiKey: string | undefined): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class ProcessesClient implements IProcessesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieves a list of processes that are "in progress" and related to the authenticated user.
     * @param pageNumber (optional) 
     * @param userId (optional) 
     * @param pageSize (optional) 
     * @param queryParams (optional) 
     * @param email (optional) 
     * @param phone (optional) 
     * @param countryCode (optional) 
     * @param orderBy (optional) 
     * @param order (optional) 
     * @param facultiesList (optional) 
     * @param specialitiesList (optional) 
     * @param userData (optional) 
     * @return A PaginatedList`1 object containing the paginated list of processes in progress.
     */
    getProcessesInProgressByUser(pageNumber: number | undefined, userId: number | undefined, pageSize: number | undefined, queryParams: string | undefined, email: string | null | undefined, phone: string | null | undefined, countryCode: string | null | undefined, orderBy: string[] | null | undefined, order: string[] | null | undefined, facultiesList: number[] | null | undefined, specialitiesList: number[] | null | undefined, userData: string | null | undefined): Observable<PaginatedListOfProcessInProgressDto> {
        let url_ = this.baseUrl + "/api/Processes/InProgress?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (queryParams === null)
            throw new Error("The parameter 'queryParams' cannot be null.");
        else if (queryParams !== undefined)
            url_ += "QueryParams=" + encodeURIComponent("" + queryParams) + "&";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (phone !== undefined && phone !== null)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (orderBy !== undefined && orderBy !== null)
            orderBy && orderBy.forEach(item => { url_ += "OrderBy=" + encodeURIComponent("" + item) + "&"; });
        if (order !== undefined && order !== null)
            order && order.forEach(item => { url_ += "Order=" + encodeURIComponent("" + item) + "&"; });
        if (facultiesList !== undefined && facultiesList !== null)
            facultiesList && facultiesList.forEach(item => { url_ += "FacultiesList=" + encodeURIComponent("" + item) + "&"; });
        if (specialitiesList !== undefined && specialitiesList !== null)
            specialitiesList && specialitiesList.forEach(item => { url_ += "SpecialitiesList=" + encodeURIComponent("" + item) + "&"; });
        if (userData !== undefined && userData !== null)
            url_ += "UserData=" + encodeURIComponent("" + userData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessesInProgressByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessesInProgressByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProcessInProgressDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProcessInProgressDto>;
        }));
    }

    protected processGetProcessesInProgressByUser(response: HttpResponseBase): Observable<PaginatedListOfProcessInProgressDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProcessInProgressDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfProcessInProgressDto>(null as any);
    }

    /**
     * Retrieves a list of processes that are "in progress" and associated with a specific user.
     * @param pageNumber (optional) 
     * @param userId (optional) 
     * @param pageSize (optional) 
     * @param queryParams (optional) 
     * @param email (optional) 
     * @param phone (optional) 
     * @param countryCode (optional) 
     * @param orderBy (optional) 
     * @param order (optional) 
     * @param facultiesList (optional) 
     * @param specialitiesList (optional) 
     * @param userData (optional) 
     * @return A paginated list of in-progress processes as PaginatedList`1.
     */
    getProcessesInProgressByUser2(pageNumber: number | undefined, userId: number | undefined, pageSize: number | undefined, queryParams: string | undefined, email: string | null | undefined, phone: string | null | undefined, countryCode: string | null | undefined, orderBy: string[] | null | undefined, order: string[] | null | undefined, facultiesList: number[] | null | undefined, specialitiesList: number[] | null | undefined, userData: string | null | undefined): Observable<PaginatedListOfProcessDto> {
        let url_ = this.baseUrl + "/api/Processes/InProgress2?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (queryParams === null)
            throw new Error("The parameter 'queryParams' cannot be null.");
        else if (queryParams !== undefined)
            url_ += "QueryParams=" + encodeURIComponent("" + queryParams) + "&";
        if (email !== undefined && email !== null)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (phone !== undefined && phone !== null)
            url_ += "phone=" + encodeURIComponent("" + phone) + "&";
        if (countryCode !== undefined && countryCode !== null)
            url_ += "CountryCode=" + encodeURIComponent("" + countryCode) + "&";
        if (orderBy !== undefined && orderBy !== null)
            orderBy && orderBy.forEach(item => { url_ += "OrderBy=" + encodeURIComponent("" + item) + "&"; });
        if (order !== undefined && order !== null)
            order && order.forEach(item => { url_ += "Order=" + encodeURIComponent("" + item) + "&"; });
        if (facultiesList !== undefined && facultiesList !== null)
            facultiesList && facultiesList.forEach(item => { url_ += "FacultiesList=" + encodeURIComponent("" + item) + "&"; });
        if (specialitiesList !== undefined && specialitiesList !== null)
            specialitiesList && specialitiesList.forEach(item => { url_ += "SpecialitiesList=" + encodeURIComponent("" + item) + "&"; });
        if (userData !== undefined && userData !== null)
            url_ += "UserData=" + encodeURIComponent("" + userData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessesInProgressByUser2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessesInProgressByUser2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProcessDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProcessDto>;
        }));
    }

    protected processGetProcessesInProgressByUser2(response: HttpResponseBase): Observable<PaginatedListOfProcessDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProcessDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfProcessDto>(null as any);
    }

    /**
     * Retrieves a paginated list of closed processes that did not result in a sale and are associated with the authenticated user.
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param queryParams (optional) 
     * @param orderBy (optional) 
     * @param order (optional) 
     * @return A PaginatedList`1 object containing the paginated list of closed processes without a sale 
    associated with the authenticated user.
     */
    getProcessesNotSalesByUser(pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | null | undefined, order: string[] | null | undefined): Observable<PaginatedListOfProcessDto> {
        let url_ = this.baseUrl + "/api/Processes/NotSales?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (queryParams === null)
            throw new Error("The parameter 'queryParams' cannot be null.");
        else if (queryParams !== undefined)
            url_ += "QueryParams=" + encodeURIComponent("" + queryParams) + "&";
        if (orderBy !== undefined && orderBy !== null)
            orderBy && orderBy.forEach(item => { url_ += "OrderBy=" + encodeURIComponent("" + item) + "&"; });
        if (order !== undefined && order !== null)
            order && order.forEach(item => { url_ += "Order=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessesNotSalesByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessesNotSalesByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProcessDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProcessDto>;
        }));
    }

    protected processGetProcessesNotSalesByUser(response: HttpResponseBase): Observable<PaginatedListOfProcessDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProcessDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfProcessDto>(null as any);
    }

    /**
     * Retrieves a list of processes managed by a specific user, filtered by an optional sales type.
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param queryParams (optional) 
     * @param orderBy (optional) 
     * @param order (optional) 
     * @return A list of ProcessSalesDto objects representing the sales processes managed by the specified user.
     */
    getProcessesSalesByUser(pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | null | undefined, order: string[] | null | undefined): Observable<PaginatedListOfProcessDto> {
        let url_ = this.baseUrl + "/api/Processes/Sales?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (queryParams === null)
            throw new Error("The parameter 'queryParams' cannot be null.");
        else if (queryParams !== undefined)
            url_ += "QueryParams=" + encodeURIComponent("" + queryParams) + "&";
        if (orderBy !== undefined && orderBy !== null)
            orderBy && orderBy.forEach(item => { url_ += "OrderBy=" + encodeURIComponent("" + item) + "&"; });
        if (order !== undefined && order !== null)
            order && order.forEach(item => { url_ += "Order=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessesSalesByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessesSalesByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProcessDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProcessDto>;
        }));
    }

    protected processGetProcessesSalesByUser(response: HttpResponseBase): Observable<PaginatedListOfProcessDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProcessDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfProcessDto>(null as any);
    }

    /**
     * Retrieves a paginated list of pending processes associated with a specific user.
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @param queryParams (optional) 
     * @param orderBy (optional) 
     * @param order (optional) 
     * @param userData (optional) 
     * @return A PaginatedList`1 object containing the paginated list of pending processes
    associated with the specified user.
     */
    getProcessesPendingByUser(pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined, orderBy: string[] | null | undefined, order: string[] | null | undefined, userData: string | null | undefined): Observable<PaginatedListOfProcessDto> {
        let url_ = this.baseUrl + "/api/Processes/Pending?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (queryParams === null)
            throw new Error("The parameter 'queryParams' cannot be null.");
        else if (queryParams !== undefined)
            url_ += "QueryParams=" + encodeURIComponent("" + queryParams) + "&";
        if (orderBy !== undefined && orderBy !== null)
            orderBy && orderBy.forEach(item => { url_ += "OrderBy=" + encodeURIComponent("" + item) + "&"; });
        if (order !== undefined && order !== null)
            order && order.forEach(item => { url_ += "Order=" + encodeURIComponent("" + item) + "&"; });
        if (userData !== undefined && userData !== null)
            url_ += "UserData=" + encodeURIComponent("" + userData) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessesPendingByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessesPendingByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfProcessDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfProcessDto>;
        }));
    }

    protected processGetProcessesPendingByUser(response: HttpResponseBase): Observable<PaginatedListOfProcessDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfProcessDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfProcessDto>(null as any);
    }

    /**
     * Retrieves the active process types associated with the current user.
     * @return A list of ProcessTypeDto objects representing the currently active (ongoing or pending) process types for the user.
     */
    getTypesActiveProcesses(): Observable<ProcessTypeDto[]> {
        let url_ = this.baseUrl + "/api/Processes/Types/ActiveProcesses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTypesActiveProcesses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTypesActiveProcesses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessTypeDto[]>;
        }));
    }

    protected processGetTypesActiveProcesses(response: HttpResponseBase): Observable<ProcessTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessTypeDto[]>(null as any);
    }

    /**
     * Retrieves the sales status of a specific process.
     * @param processId Identifier of the process for which the sales status is to be obtained.
     * @return A ProcessSaleStatusDto object containing the sales status of the process.
    - SaleComplete: Indicates whether the sale is complete.
     */
    getProcessSaleStatus(processId: number): Observable<ProcessSaleStatusDto> {
        let url_ = this.baseUrl + "/api/Processes/SaleStatus/{processId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessSaleStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessSaleStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessSaleStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessSaleStatusDto>;
        }));
    }

    protected processGetProcessSaleStatus(response: HttpResponseBase): Observable<ProcessSaleStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessSaleStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessSaleStatusDto>(null as any);
    }

    /**
     * Retrieves the number of sales attempts for a specific process.
     * @param processId Identifier of the process for which the number of sales attempts is to be obtained.
     * @return A ProcessSaleAttemtpsDto object containing the number of sales attempts for the process.
    - SaleAttemtps: Number of sales attempts recorded for the process.
     */
    getProcessSaleAttempts(processId: number): Observable<ProcessSaleAttemtpsDto> {
        let url_ = this.baseUrl + "/api/Processes/SaleAttemtps/{processId}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessSaleAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessSaleAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessSaleAttemtpsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessSaleAttemtpsDto>;
        }));
    }

    protected processGetProcessSaleAttempts(response: HttpResponseBase): Observable<ProcessSaleAttemtpsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProcessSaleAttemtpsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessSaleAttemtpsDto>(null as any);
    }

    /**
     * Checks if the current user can create a new recovery process.
     * @return A ActionResult<bool> indicating whether the user can create a recovery process.
    - true if the user can create a new recovery process; otherwise, false.
     */
    canCreateRecoverProcess(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Processes/CanCreateRecoverProcess";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCanCreateRecoverProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCanCreateRecoverProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCanCreateRecoverProcess(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(null as any);
    }

    /**
     * Retrieves a list of all available discard reasons.
     * @return A list of DiscardReasonDto objects representing the discard reasons.
     */
    getAllDiscardReasons(): Observable<DiscardReasonDto[]> {
        let url_ = this.baseUrl + "/api/Processes/DiscardReasons/List";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDiscardReasons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDiscardReasons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DiscardReasonDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DiscardReasonDto[]>;
        }));
    }

    protected processGetAllDiscardReasons(response: HttpResponseBase): Observable<DiscardReasonDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DiscardReasonDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiscardReasonDto[]>(null as any);
    }

    /**
     * Retrieves a list of open processes associated with a specific contact.
     * @param contactId Identifier of the contact for whom the open processes are to be retrieved.
     * @return A list of ProcessDto objects representing the open processes.
     */
    getOpenProcessesByContactId(contactId: number): Observable<ProcessDto[]> {
        let url_ = this.baseUrl + "/api/Processes/GetOpenProcessesByContactId/{contactId}";
        if (contactId === undefined || contactId === null)
            throw new Error("The parameter 'contactId' must be defined.");
        url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOpenProcessesByContactId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOpenProcessesByContactId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessDto[]>;
        }));
    }

    protected processGetOpenProcessesByContactId(response: HttpResponseBase): Observable<ProcessDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessDto[]>(null as any);
    }

    /**
     * Date Local Time with unspecified type Zone (without HourZone). Expected: 2024-09-03T09:00:00.000
     * @param processId Identifier of the process for which the suggested interaction date is to be obtained.
     * @param dateLocalEmployee Employee's local date and time in string format, without a specified time zone. 
    Expected format: 2024-09-03T09:34:56.789
     * @return A suggested date and time for the next interaction, or null if it cannot be determined.
     */
    getSuggestedNextInteractionDate(processId: number, dateLocalEmployee: string): Observable<Date | null> {
        let url_ = this.baseUrl + "/api/Processes/GetSuggestedNextInteractionDate/{processId}/{dateLocalEmployee}";
        if (processId === undefined || processId === null)
            throw new Error("The parameter 'processId' must be defined.");
        url_ = url_.replace("{processId}", encodeURIComponent("" + processId));
        if (dateLocalEmployee === undefined || dateLocalEmployee === null)
            throw new Error("The parameter 'dateLocalEmployee' must be defined.");
        url_ = url_.replace("{dateLocalEmployee}", encodeURIComponent("" + dateLocalEmployee));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSuggestedNextInteractionDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSuggestedNextInteractionDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Date | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Date | null>;
        }));
    }

    protected processGetSuggestedNextInteractionDate(response: HttpResponseBase): Observable<Date | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? new Date(resultData200.toString()) : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Date | null>(null as any);
    }

    /**
     * Creates a new process.
     * @param command Object containing the necessary data for creating the process.
     * @return The unique identifier (Int32) of the newly created process.
     */
    create(command: CreateProcessCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Processes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Sets a web sales process using the contact's email, phone, or ID.
     * @param command Object containing the parameters required to set the sales process:
    - Email: Contact's email address.
    - Phone: Contact's phone number.
    - Dni: Contact's ID.
     * @return A Unit object indicating the operation was completed successfully.
     */
    saleProcessByEmailOrPhoneOrDniCommand(command: SetWebSaleProcessByEmailOrPhoneOrDniCommand): Observable<Unit> {
        let url_ = this.baseUrl + "/api/Processes/SetWebSaleProcessByEmailOrPhoneOrDniCommand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaleProcessByEmailOrPhoneOrDniCommand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaleProcessByEmailOrPhoneOrDniCommand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Unit>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Unit>;
        }));
    }

    protected processSaleProcessByEmailOrPhoneOrDniCommand(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(null as any);
    }

    /**
     * Updates the data of an existing process.
     * @param id The unique identifier (Int32) of the process to be updated.
     * @param command Object containing the updated data for the process. This command inherits from ProcessUpdateDto.
     * @return Returns an HTTP result:
    - BadRequest if the identifier provided in the parameter does not match the ID in the command.
    - NoContent if the update is successfully completed.
     */
    update(id: number, command: UpdateProcessCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Processes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Marks a process as deleted by its identifier.
     * @param id The unique identifier of the process to delete.
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
     */
    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Processes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Changes the color associated with a specific process.
     * @param processId (optional) 
     * @param color (optional) 
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
     */
    changeProcessColor(processId: number | undefined, color: Colour | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Processes/ChangeProcessColor?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&";
        if (color === null)
            throw new Error("The parameter 'color' cannot be null.");
        else if (color !== undefined)
            url_ += "Color=" + encodeURIComponent("" + color) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeProcessColor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeProcessColor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processChangeProcessColor(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Closes pending sales processes based on the associated order number or email address.
     * @param command Object of type CloseProcessSaleByOrderNumberOrEmailCommand containing a list of 
    OrderImportedUpdateDto objects with the following information:
    - OrderNumber: Order number associated with the process.
    - PaymentType: Type of payment made.
    - PaymentDate: Date of the payment.
    - Status: Order status (e.g., "CANCELLED").
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
     */
    closeProcessSaleByOrderNumberOrEmail(command: OrderImportedUpdateDto[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Processes/CloseProcessSaleByOrderNumberOrEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCloseProcessSaleByOrderNumberOrEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCloseProcessSaleByOrderNumberOrEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCloseProcessSaleByOrderNumberOrEmail(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Reassigns a process to a different user.
     * @param command Object containing the data necessary for the reassignment:
    - ProcessId: Unique identifier of the process.
    - UserId: Identifier of the user to whom the process will be reassigned.
     * @return An HTTP response with:
    - NoContent if the operation is successfully completed.
     */
    reassignProcess(command: ReassignProcessCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Processes/Reassign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReassignProcess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReassignProcess(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processReassignProcess(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Reassigns all processes from one user to another user.
     * @param fromUserId (optional) 
     * @param toUserId (optional) 
     * @param onlyToDo (optional) 
     * @return An HTTP response:
    - NoContent if the operation is successful.
     */
    reassignAllProcesses(fromUserId: number | undefined, toUserId: number | undefined, onlyToDo: boolean | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Processes/ReassignAllUserProcesses?";
        if (fromUserId === null)
            throw new Error("The parameter 'fromUserId' cannot be null.");
        else if (fromUserId !== undefined)
            url_ += "FromUserId=" + encodeURIComponent("" + fromUserId) + "&";
        if (toUserId === null)
            throw new Error("The parameter 'toUserId' cannot be null.");
        else if (toUserId !== undefined)
            url_ += "ToUserId=" + encodeURIComponent("" + toUserId) + "&";
        if (onlyToDo === null)
            throw new Error("The parameter 'onlyToDo' cannot be null.");
        else if (onlyToDo !== undefined)
            url_ += "OnlyToDo=" + encodeURIComponent("" + onlyToDo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReassignAllProcesses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReassignAllProcesses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processReassignAllProcesses(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Processes a successful external sale and updates the associated contact and process information.
     * @param command Object containing the parameters required to process the successful external sale:
    - ProcessId: Identifier of the associated process.
    - IdCard: Contact's ID.
    - Email: Contact's email address.
    - Address: Contact's address.
    - PostalCode: Postal code of the address.
    - Country: Country code.
    - Province: Province of the address.
    - City: City of the address.
    - OrderNumber: Order number.
    - OrderDate: Order date.
    - AcademicTitle: Academic title.
    - InitDate: Start date.
    - PaymentType: Payment type.
    - CurrencyCountry: Currency country.
    - NumberDeadLines: Number of installments.
    - SalesCountry: Sales country.
    - AmountRegistration: Registration amount.
     * @return An ActionResult object indicating the operation's result.
    - NoContent if the operation was completed successfully.
     */
    externalSuccessfulSaleProcessCommand(command: ExternalSuccessfulSaleProcessCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Processes/ExternalSuccessfulSaleProcess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalSuccessfulSaleProcessCommand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalSuccessfulSaleProcessCommand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processExternalSuccessfulSaleProcessCommand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Closes the processes specified in the list of process identifiers.
     * @param processIds (optional) 
     * @param isAutomatic (optional) 
     * @return An ActionResult object indicating the operation's result.
    - NoContent if the operation was completed successfully.
     */
    closeProcessesCommand(processIds: number[] | undefined, isAutomatic: boolean | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Processes/CloseProcesses?";
        if (processIds === null)
            throw new Error("The parameter 'processIds' cannot be null.");
        else if (processIds !== undefined)
            processIds && processIds.forEach(item => { url_ += "ProcessIds=" + encodeURIComponent("" + item) + "&"; });
        if (isAutomatic !== undefined && isAutomatic !== null)
            url_ += "IsAutomatic=" + encodeURIComponent("" + isAutomatic) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCloseProcessesCommand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCloseProcessesCommand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCloseProcessesCommand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Replaces an existing process with a new one for a priority commercial user.
     * @param processId (optional) 
     * @return An ActionResult<int> object containing the identifier of the newly created process.
     */
    replaceProcessForPriorityCommercial(processId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Processes/ReplaceProcessForPriorityCommercial?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceProcessForPriorityCommercial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceProcessForPriorityCommercial(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processReplaceProcessForPriorityCommercial(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Devuelve los contactos comerciales para entrega basados en el correo electrnico corporativo proporcionado.
     * @param corporateEmail (optional) 
     * @param apiKey (optional) 
     * @return Las fechas de reparto y el estado de los procesos se actualizaron correctamente.
     */
    returnBusinnesContactsDelivery(corporateEmail: string | undefined, apiKey: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Processes/ReturnBusinnesContactsDelivery?";
        if (corporateEmail === null)
            throw new Error("The parameter 'corporateEmail' cannot be null.");
        else if (corporateEmail !== undefined)
            url_ += "corporateEmail=" + encodeURIComponent("" + corporateEmail) + "&";
        if (apiKey === null)
            throw new Error("The parameter 'apiKey' cannot be null.");
        else if (apiKey !== undefined)
            url_ += "ApiKey=" + encodeURIComponent("" + apiKey) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReturnBusinnesContactsDelivery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReturnBusinnesContactsDelivery(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processReturnBusinnesContactsDelivery(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Si el comando es nulo o no v\u00e1lido.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Si ocurre un error interno en el servidor.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

export interface IProcessSettingsClient {
    /**
     * Retrieves a list of process configuration types.
     * @param isCouponsOnly (optional) 
     * @return A list of objects representing the process types.
     */
    getProcessSettingsTypes(isCouponsOnly: boolean | undefined): Observable<ProcessTypeDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class ProcessSettingsClient implements IProcessSettingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieves a list of process configuration types.
     * @param isCouponsOnly (optional) 
     * @return A list of objects representing the process types.
     */
    getProcessSettingsTypes(isCouponsOnly: boolean | undefined): Observable<ProcessTypeDto[]> {
        let url_ = this.baseUrl + "/api/ProcessSettings?";
        if (isCouponsOnly === null)
            throw new Error("The parameter 'isCouponsOnly' cannot be null.");
        else if (isCouponsOnly !== undefined)
            url_ += "IsCouponsOnly=" + encodeURIComponent("" + isCouponsOnly) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProcessSettingsTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProcessSettingsTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProcessTypeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProcessTypeDto[]>;
        }));
    }

    protected processGetProcessSettingsTypes(response: HttpResponseBase): Observable<ProcessTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProcessTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProcessTypeDto[]>(null as any);
    }
}

export interface IProposalsClient {
    getTemplateProposals(pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined): Observable<PaginatedListOfTemplateProposalDto>;
    /**
     * Retrieves the details of a specific template proposal.
     * @param tempateProposalId (optional) 
     * @return The details of the specified template proposal.
     */
    getTemplateProposal(tempateProposalId: number | undefined): Observable<TemplateProposalDto>;
    /**
     * Creates a new template proposal.
     * @param command The command containing the necessary data to create the template proposal.
     * @return The ID of the created template proposal.
     */
    create(command: CreateTemplateProposalCommand): Observable<number>;
    /**
     * Updates an existing template proposal.
     * @param id The ID of the template proposal to update.
     * @param command The command containing the updated data for the template proposal.
     * @return An HTTP status code indicating the result of the operation.
     */
    update(id: number, command: UpdateTemplateProposalCommand): Observable<FileResponse>;
    /**
     * Deletes a template proposal by marking it as deleted.
     * @param id The ID of the template proposal to delete.
     * @return An HTTP status code indicating the result of the operation.
     */
    delete(id: number): Observable<FileResponse>;
    /**
     * Retrieves the templates associated with a specific template proposal.
     * @param tempateProposalId (optional) 
     * @return A list of templates associated with the specified template proposal.
     */
    getTemplateProposalAll(tempateProposalId: number | undefined): Observable<TemplateProposalTemplateDto[]>;
    /**
     * Retrieves the templates associated with a specific tag identifier.
     * @param tagId (optional) 
     * @return A list of templates associated with the specified tag.
     */
    getTemplatesFromTagIdAll(tagId: number | undefined): Observable<TemplateDto[]>;
    /**
     * Associates a specific template with an existing template proposal.
     * @param command Command containing the identifiers of the template proposal and the template.
     * @return A no-content result if the operation is successful.
     */
    setTemplateInTemplateProposal(command: SetTemplateInTemplateProposalCommand): Observable<FileResponse>;
    /**
     * Retrieves the details of a specific template by its identifier.
     * @param templateId (optional) 
     * @return An object TemplateDetailsDto with the details of the template.
     */
    getTemplatesFromTagId(templateId: number | undefined): Observable<TemplateDetailsDto>;
    /**
     * Retrieves a list of template proposals associated with a specific template.
     * @param templateId (optional) 
     * @return A list of TemplateProposalDto objects representing the associated template proposals.
     */
    getTemplateProposalsByTemplate(templateId: number | undefined): Observable<TemplateProposalDto[]>;
    getAllTemplates(pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined): Observable<PaginatedListOfTemplateDto>;
    /**
     * Creates a new template in the system.
     * @param command Command containing the necessary data to create the template.
     * @return The unique identifier of the newly created template.
     */
    createTemplate(command: CreateTemplateCommand): Observable<number>;
    /**
     * Updates the data of an existing template.
     * @param command Command containing the updated data of the template, including its identifier.
     * @return A no-content result if the operation is successful.
     */
    updateTemplate(id: string, command: UpdateTemplateCommand): Observable<FileResponse>;
    /**
     * Deletes (marks as deleted) an existing template in the system.
     * @param id The unique identifier of the template to delete.
     * @return A no-content result if the operation is successful.
     */
    deleteTemplate(id: number): Observable<FileResponse>;
    /**
     * Deletes the relationships between a template and a template proposal.
     * @param command Command containing the identifiers of the template and the template proposal to unlink.
     * @return A no-content result if the operation is successful.
     */
    deleteTemplateInTemplateProposal(command: DeleteTemplateInTemplateProposalCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProposalsClient implements IProposalsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTemplateProposals(pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined): Observable<PaginatedListOfTemplateProposalDto> {
        let url_ = this.baseUrl + "/api/Proposals/TemplateProposals?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (queryParams === null)
            throw new Error("The parameter 'queryParams' cannot be null.");
        else if (queryParams !== undefined)
            url_ += "QueryParams=" + encodeURIComponent("" + queryParams) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateProposals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateProposals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTemplateProposalDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTemplateProposalDto>;
        }));
    }

    protected processGetTemplateProposals(response: HttpResponseBase): Observable<PaginatedListOfTemplateProposalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTemplateProposalDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfTemplateProposalDto>(null as any);
    }

    /**
     * Retrieves the details of a specific template proposal.
     * @param tempateProposalId (optional) 
     * @return The details of the specified template proposal.
     */
    getTemplateProposal(tempateProposalId: number | undefined): Observable<TemplateProposalDto> {
        let url_ = this.baseUrl + "/api/Proposals/TemplateProposal?";
        if (tempateProposalId === null)
            throw new Error("The parameter 'tempateProposalId' cannot be null.");
        else if (tempateProposalId !== undefined)
            url_ += "TempateProposalId=" + encodeURIComponent("" + tempateProposalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateProposal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateProposal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateProposalDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateProposalDto>;
        }));
    }

    protected processGetTemplateProposal(response: HttpResponseBase): Observable<TemplateProposalDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateProposalDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateProposalDto>(null as any);
    }

    /**
     * Creates a new template proposal.
     * @param command The command containing the necessary data to create the template proposal.
     * @return The ID of the created template proposal.
     */
    create(command: CreateTemplateProposalCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Proposals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Updates an existing template proposal.
     * @param id The ID of the template proposal to update.
     * @param command The command containing the updated data for the template proposal.
     * @return An HTTP status code indicating the result of the operation.
     */
    update(id: number, command: UpdateTemplateProposalCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Proposals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Deletes a template proposal by marking it as deleted.
     * @param id The ID of the template proposal to delete.
     * @return An HTTP status code indicating the result of the operation.
     */
    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Proposals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Retrieves the templates associated with a specific template proposal.
     * @param tempateProposalId (optional) 
     * @return A list of templates associated with the specified template proposal.
     */
    getTemplateProposalAll(tempateProposalId: number | undefined): Observable<TemplateProposalTemplateDto[]> {
        let url_ = this.baseUrl + "/api/Proposals/TemplatesFromTemplateProposal?";
        if (tempateProposalId === null)
            throw new Error("The parameter 'tempateProposalId' cannot be null.");
        else if (tempateProposalId !== undefined)
            url_ += "TempateProposalId=" + encodeURIComponent("" + tempateProposalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateProposalAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateProposalAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateProposalTemplateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateProposalTemplateDto[]>;
        }));
    }

    protected processGetTemplateProposalAll(response: HttpResponseBase): Observable<TemplateProposalTemplateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemplateProposalTemplateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateProposalTemplateDto[]>(null as any);
    }

    /**
     * Retrieves the templates associated with a specific tag identifier.
     * @param tagId (optional) 
     * @return A list of templates associated with the specified tag.
     */
    getTemplatesFromTagIdAll(tagId: number | undefined): Observable<TemplateDto[]> {
        let url_ = this.baseUrl + "/api/Proposals/TemplatesFromTagId?";
        if (tagId === null)
            throw new Error("The parameter 'tagId' cannot be null.");
        else if (tagId !== undefined)
            url_ += "TagId=" + encodeURIComponent("" + tagId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplatesFromTagIdAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplatesFromTagIdAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto[]>;
        }));
    }

    protected processGetTemplatesFromTagIdAll(response: HttpResponseBase): Observable<TemplateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemplateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateDto[]>(null as any);
    }

    /**
     * Associates a specific template with an existing template proposal.
     * @param command Command containing the identifiers of the template proposal and the template.
     * @return A no-content result if the operation is successful.
     */
    setTemplateInTemplateProposal(command: SetTemplateInTemplateProposalCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Proposals/SetTemplateInTemplateProposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetTemplateInTemplateProposal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetTemplateInTemplateProposal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processSetTemplateInTemplateProposal(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Retrieves the details of a specific template by its identifier.
     * @param templateId (optional) 
     * @return An object TemplateDetailsDto with the details of the template.
     */
    getTemplatesFromTagId(templateId: number | undefined): Observable<TemplateDetailsDto> {
        let url_ = this.baseUrl + "/api/Proposals/TemplateDetails?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "TemplateId=" + encodeURIComponent("" + templateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplatesFromTagId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplatesFromTagId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDetailsDto>;
        }));
    }

    protected processGetTemplatesFromTagId(response: HttpResponseBase): Observable<TemplateDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateDetailsDto>(null as any);
    }

    /**
     * Retrieves a list of template proposals associated with a specific template.
     * @param templateId (optional) 
     * @return A list of TemplateProposalDto objects representing the associated template proposals.
     */
    getTemplateProposalsByTemplate(templateId: number | undefined): Observable<TemplateProposalDto[]> {
        let url_ = this.baseUrl + "/api/Proposals/TemplatesProposalByTemplate?";
        if (templateId === null)
            throw new Error("The parameter 'templateId' cannot be null.");
        else if (templateId !== undefined)
            url_ += "TemplateId=" + encodeURIComponent("" + templateId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateProposalsByTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateProposalsByTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateProposalDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateProposalDto[]>;
        }));
    }

    protected processGetTemplateProposalsByTemplate(response: HttpResponseBase): Observable<TemplateProposalDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemplateProposalDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateProposalDto[]>(null as any);
    }

    getAllTemplates(pageNumber: number | undefined, pageSize: number | undefined, queryParams: string | undefined): Observable<PaginatedListOfTemplateDto> {
        let url_ = this.baseUrl + "/api/Proposals/AllTemplates?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (queryParams === null)
            throw new Error("The parameter 'queryParams' cannot be null.");
        else if (queryParams !== undefined)
            url_ += "QueryParams=" + encodeURIComponent("" + queryParams) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTemplates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedListOfTemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedListOfTemplateDto>;
        }));
    }

    protected processGetAllTemplates(response: HttpResponseBase): Observable<PaginatedListOfTemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfTemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfTemplateDto>(null as any);
    }

    /**
     * Creates a new template in the system.
     * @param command Command containing the necessary data to create the template.
     * @return The unique identifier of the newly created template.
     */
    createTemplate(command: CreateTemplateCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Proposals/CreateTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreateTemplate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    /**
     * Updates the data of an existing template.
     * @param command Command containing the updated data of the template, including its identifier.
     * @return A no-content result if the operation is successful.
     */
    updateTemplate(id: string, command: UpdateTemplateCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Proposals/UpdateTemplate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateTemplate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Deletes (marks as deleted) an existing template in the system.
     * @param id The unique identifier of the template to delete.
     * @return A no-content result if the operation is successful.
     */
    deleteTemplate(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Proposals/DeleteTemplate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteTemplate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Deletes the relationships between a template and a template proposal.
     * @param command Command containing the identifiers of the template and the template proposal to unlink.
     * @return A no-content result if the operation is successful.
     */
    deleteTemplateInTemplateProposal(command: DeleteTemplateInTemplateProposalCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Proposals/DeleteTemplateInTemplateProposal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTemplateInTemplateProposal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTemplateInTemplateProposal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteTemplateInTemplateProposal(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }
}

export interface ISpecialitiesClient {
    getSpecialitiesByFaculty(facultyId: number | undefined, courseCountryId: number | undefined): Observable<SpecialityDto[]>;
    getSpecialitiesByFaculties(facultiesId: number[] | undefined, courseCountryId: number | undefined): Observable<SpecialityDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class SpecialitiesClient implements ISpecialitiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSpecialitiesByFaculty(facultyId: number | undefined, courseCountryId: number | undefined): Observable<SpecialityDto[]> {
        let url_ = this.baseUrl + "/api/Specialities/Faculty/List?";
        if (facultyId === null)
            throw new Error("The parameter 'facultyId' cannot be null.");
        else if (facultyId !== undefined)
            url_ += "FacultyId=" + encodeURIComponent("" + facultyId) + "&";
        if (courseCountryId === null)
            throw new Error("The parameter 'courseCountryId' cannot be null.");
        else if (courseCountryId !== undefined)
            url_ += "CourseCountryId=" + encodeURIComponent("" + courseCountryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpecialitiesByFaculty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpecialitiesByFaculty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpecialityDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpecialityDto[]>;
        }));
    }

    protected processGetSpecialitiesByFaculty(response: HttpResponseBase): Observable<SpecialityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SpecialityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecialityDto[]>(null as any);
    }

    getSpecialitiesByFaculties(facultiesId: number[] | undefined, courseCountryId: number | undefined): Observable<SpecialityDto[]> {
        let url_ = this.baseUrl + "/api/Specialities/Faculties/List?";
        if (facultiesId === null)
            throw new Error("The parameter 'facultiesId' cannot be null.");
        else if (facultiesId !== undefined)
            facultiesId && facultiesId.forEach(item => { url_ += "FacultiesId=" + encodeURIComponent("" + item) + "&"; });
        if (courseCountryId === null)
            throw new Error("The parameter 'courseCountryId' cannot be null.");
        else if (courseCountryId !== undefined)
            url_ += "CourseCountryId=" + encodeURIComponent("" + courseCountryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpecialitiesByFaculties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpecialitiesByFaculties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SpecialityDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SpecialityDto[]>;
        }));
    }

    protected processGetSpecialitiesByFaculties(response: HttpResponseBase): Observable<SpecialityDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SpecialityDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpecialityDto[]>(null as any);
    }
}

export interface ITemplatesClient {
    getTemplates(processType: string | null | undefined, languageCode: string | null | undefined, templateType: string | null | undefined): Observable<TemplateDto[]>;
    /**
     * Retrieves the complete details of a specific template.
     * @param templateId The unique identifier of the template.
     * @return A `TemplateDetailsDto` object containing the details of the specified template.
     */
    getTemplateDetails(templateId: number): Observable<TemplateDetailsDto>;
    getTemplateBundleProposal(processId: number | undefined, languageCode: string | undefined, courseId: number | null | undefined, response: boolean | null | undefined): Observable<TemplateBundleProposalViewModel>;
    getTemplateId(processType: string | null | undefined, templateType: string | null | undefined, languageCode: string | null | undefined, day: number | undefined, attempt: number | undefined, colour: string | null | undefined, courseKnown: boolean | undefined): Observable<number>;
    getTemplate(processType: string | null | undefined, templateType: string | null | undefined, languageCode: string | null | undefined, day: number | undefined, attempt: number | undefined, colour: string | null | undefined, courseKnown: boolean | undefined): Observable<TemplateDto>;
    getTemplateByLabel(processType: string | undefined, templateType: string | undefined, languageCode: string | undefined, label: string | undefined): Observable<TemplateDto>;
    /**
     * Retrieves the details of an argument based on the process ID or the specific argument ID.
     * @param processId (optional) 
     * @param argumentId (optional) 
     * @return A TemplateDetailsDto object containing the details of the found argument.
     */
    getArgumentByProcessId(processId: number | null | undefined, argumentId: number | null | undefined): Observable<TemplateDetailsDto>;
    updateContentInAllTemplates(actualContent: string | undefined, newContent: string | undefined): Observable<AffectedTemplatesViewModel>;
    /**
     * Uploads a file with the completed audit template. Then, the contacts to be audited are inserted.
     * @param command An object UploadTemplateAuditoryCommand that contains the file to upload and an optional date.
     * @return An HTTP response with status 204 (No Content) if the operation is successful.
     */
    uploadTemplateAuditory(command: UploadTemplateAuditoryCommand): Observable<FileResponse>;
    /**
     * Send an empty template auditory by email.
     * @return Email sent successfully.
     */
    getTemplateAuditory(): Observable<void>;
    /**
     * Get a template by Name Code
     * @param nameCode (optional) 
     * @param languageId (optional) 
     * @param type (optional) 
     */
    getTemplateByNameCode(nameCode: string | undefined, languageId: number | undefined, type: TemplateType | undefined): Observable<TemplateDto>;
}

@Injectable({
    providedIn: 'root'
})
export class TemplatesClient implements ITemplatesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTemplates(processType: string | null | undefined, languageCode: string | null | undefined, templateType: string | null | undefined): Observable<TemplateDto[]> {
        let url_ = this.baseUrl + "/api/Templates?";
        if (processType !== undefined && processType !== null)
            url_ += "ProcessType=" + encodeURIComponent("" + processType) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (templateType !== undefined && templateType !== null)
            url_ += "TemplateType=" + encodeURIComponent("" + templateType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto[]>;
        }));
    }

    protected processGetTemplates(response: HttpResponseBase): Observable<TemplateDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TemplateDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateDto[]>(null as any);
    }

    /**
     * Retrieves the complete details of a specific template.
     * @param templateId The unique identifier of the template.
     * @return A `TemplateDetailsDto` object containing the details of the specified template.
     */
    getTemplateDetails(templateId: number): Observable<TemplateDetailsDto> {
        let url_ = this.baseUrl + "/api/Templates/{templateId}";
        if (templateId === undefined || templateId === null)
            throw new Error("The parameter 'templateId' must be defined.");
        url_ = url_.replace("{templateId}", encodeURIComponent("" + templateId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDetailsDto>;
        }));
    }

    protected processGetTemplateDetails(response: HttpResponseBase): Observable<TemplateDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateDetailsDto>(null as any);
    }

    getTemplateBundleProposal(processId: number | undefined, languageCode: string | undefined, courseId: number | null | undefined, response: boolean | null | undefined): Observable<TemplateBundleProposalViewModel> {
        let url_ = this.baseUrl + "/api/Templates/Proposal?";
        if (processId === null)
            throw new Error("The parameter 'processId' cannot be null.");
        else if (processId !== undefined)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&";
        if (languageCode === null)
            throw new Error("The parameter 'languageCode' cannot be null.");
        else if (languageCode !== undefined)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (courseId !== undefined && courseId !== null)
            url_ += "CourseId=" + encodeURIComponent("" + courseId) + "&";
        if (response !== undefined && response !== null)
            url_ += "Response=" + encodeURIComponent("" + response) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateBundleProposal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateBundleProposal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateBundleProposalViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateBundleProposalViewModel>;
        }));
    }

    protected processGetTemplateBundleProposal(response: HttpResponseBase): Observable<TemplateBundleProposalViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateBundleProposalViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateBundleProposalViewModel>(null as any);
    }

    getTemplateId(processType: string | null | undefined, templateType: string | null | undefined, languageCode: string | null | undefined, day: number | undefined, attempt: number | undefined, colour: string | null | undefined, courseKnown: boolean | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Templates/getId?";
        if (processType !== undefined && processType !== null)
            url_ += "ProcessType=" + encodeURIComponent("" + processType) + "&";
        if (templateType !== undefined && templateType !== null)
            url_ += "TemplateType=" + encodeURIComponent("" + templateType) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (day === null)
            throw new Error("The parameter 'day' cannot be null.");
        else if (day !== undefined)
            url_ += "Day=" + encodeURIComponent("" + day) + "&";
        if (attempt === null)
            throw new Error("The parameter 'attempt' cannot be null.");
        else if (attempt !== undefined)
            url_ += "Attempt=" + encodeURIComponent("" + attempt) + "&";
        if (colour !== undefined && colour !== null)
            url_ += "Colour=" + encodeURIComponent("" + colour) + "&";
        if (courseKnown === null)
            throw new Error("The parameter 'courseKnown' cannot be null.");
        else if (courseKnown !== undefined)
            url_ += "CourseKnown=" + encodeURIComponent("" + courseKnown) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetTemplateId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }

    getTemplate(processType: string | null | undefined, templateType: string | null | undefined, languageCode: string | null | undefined, day: number | undefined, attempt: number | undefined, colour: string | null | undefined, courseKnown: boolean | undefined): Observable<TemplateDto> {
        let url_ = this.baseUrl + "/api/Templates/getTemplate?";
        if (processType !== undefined && processType !== null)
            url_ += "ProcessType=" + encodeURIComponent("" + processType) + "&";
        if (templateType !== undefined && templateType !== null)
            url_ += "TemplateType=" + encodeURIComponent("" + templateType) + "&";
        if (languageCode !== undefined && languageCode !== null)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (day === null)
            throw new Error("The parameter 'day' cannot be null.");
        else if (day !== undefined)
            url_ += "Day=" + encodeURIComponent("" + day) + "&";
        if (attempt === null)
            throw new Error("The parameter 'attempt' cannot be null.");
        else if (attempt !== undefined)
            url_ += "Attempt=" + encodeURIComponent("" + attempt) + "&";
        if (colour !== undefined && colour !== null)
            url_ += "Colour=" + encodeURIComponent("" + colour) + "&";
        if (courseKnown === null)
            throw new Error("The parameter 'courseKnown' cannot be null.");
        else if (courseKnown !== undefined)
            url_ += "CourseKnown=" + encodeURIComponent("" + courseKnown) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto>;
        }));
    }

    protected processGetTemplate(response: HttpResponseBase): Observable<TemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateDto>(null as any);
    }

    getTemplateByLabel(processType: string | undefined, templateType: string | undefined, languageCode: string | undefined, label: string | undefined): Observable<TemplateDto> {
        let url_ = this.baseUrl + "/api/Templates/getTemplateByLabel?";
        if (processType === null)
            throw new Error("The parameter 'processType' cannot be null.");
        else if (processType !== undefined)
            url_ += "ProcessType=" + encodeURIComponent("" + processType) + "&";
        if (templateType === null)
            throw new Error("The parameter 'templateType' cannot be null.");
        else if (templateType !== undefined)
            url_ += "TemplateType=" + encodeURIComponent("" + templateType) + "&";
        if (languageCode === null)
            throw new Error("The parameter 'languageCode' cannot be null.");
        else if (languageCode !== undefined)
            url_ += "LanguageCode=" + encodeURIComponent("" + languageCode) + "&";
        if (label === null)
            throw new Error("The parameter 'label' cannot be null.");
        else if (label !== undefined)
            url_ += "Label=" + encodeURIComponent("" + label) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateByLabel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateByLabel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto>;
        }));
    }

    protected processGetTemplateByLabel(response: HttpResponseBase): Observable<TemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateDto>(null as any);
    }

    /**
     * Retrieves the details of an argument based on the process ID or the specific argument ID.
     * @param processId (optional) 
     * @param argumentId (optional) 
     * @return A TemplateDetailsDto object containing the details of the found argument.
     */
    getArgumentByProcessId(processId: number | null | undefined, argumentId: number | null | undefined): Observable<TemplateDetailsDto> {
        let url_ = this.baseUrl + "/api/Templates/GetArgumentByProcessId?";
        if (processId !== undefined && processId !== null)
            url_ += "ProcessId=" + encodeURIComponent("" + processId) + "&";
        if (argumentId !== undefined && argumentId !== null)
            url_ += "ArgumentId=" + encodeURIComponent("" + argumentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetArgumentByProcessId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetArgumentByProcessId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDetailsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDetailsDto>;
        }));
    }

    protected processGetArgumentByProcessId(response: HttpResponseBase): Observable<TemplateDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateDetailsDto>(null as any);
    }

    updateContentInAllTemplates(actualContent: string | undefined, newContent: string | undefined): Observable<AffectedTemplatesViewModel> {
        let url_ = this.baseUrl + "/api/Templates/UpdateContentInAllTemplates?";
        if (actualContent === null)
            throw new Error("The parameter 'actualContent' cannot be null.");
        else if (actualContent !== undefined)
            url_ += "ActualContent=" + encodeURIComponent("" + actualContent) + "&";
        if (newContent === null)
            throw new Error("The parameter 'newContent' cannot be null.");
        else if (newContent !== undefined)
            url_ += "NewContent=" + encodeURIComponent("" + newContent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateContentInAllTemplates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateContentInAllTemplates(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AffectedTemplatesViewModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AffectedTemplatesViewModel>;
        }));
    }

    protected processUpdateContentInAllTemplates(response: HttpResponseBase): Observable<AffectedTemplatesViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AffectedTemplatesViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AffectedTemplatesViewModel>(null as any);
    }

    /**
     * Uploads a file with the completed audit template. Then, the contacts to be audited are inserted.
     * @param command An object UploadTemplateAuditoryCommand that contains the file to upload and an optional date.
     * @return An HTTP response with status 204 (No Content) if the operation is successful.
     */
    uploadTemplateAuditory(command: UploadTemplateAuditoryCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Templates/UploadTemplateAuditory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadTemplateAuditory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadTemplateAuditory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadTemplateAuditory(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(null as any);
    }

    /**
     * Send an empty template auditory by email.
     * @return Email sent successfully.
     */
    getTemplateAuditory(): Observable<void> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateAuditory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateAuditory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateAuditory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetTemplateAuditory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(null as any);
    }

    /**
     * Get a template by Name Code
     * @param nameCode (optional) 
     * @param languageId (optional) 
     * @param type (optional) 
     */
    getTemplateByNameCode(nameCode: string | undefined, languageId: number | undefined, type: TemplateType | undefined): Observable<TemplateDto> {
        let url_ = this.baseUrl + "/api/Templates/GetTemplateByNameCode?";
        if (nameCode === null)
            throw new Error("The parameter 'nameCode' cannot be null.");
        else if (nameCode !== undefined)
            url_ += "NameCode=" + encodeURIComponent("" + nameCode) + "&";
        if (languageId === null)
            throw new Error("The parameter 'languageId' cannot be null.");
        else if (languageId !== undefined)
            url_ += "LanguageId=" + encodeURIComponent("" + languageId) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTemplateByNameCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTemplateByNameCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TemplateDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TemplateDto>;
        }));
    }

    protected processGetTemplateByNameCode(response: HttpResponseBase): Observable<TemplateDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TemplateDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TemplateDto>(null as any);
    }
}

export interface IUsersClient {
    /**
     * Retrieves the ID of the seller associated with the current authenticated user.
     * @return Returns the ID of the seller associated with the user.
     */
    getCurrentUserSellerId(): Observable<number | null>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieves the ID of the seller associated with the current authenticated user.
     * @return Returns the ID of the seller associated with the user.
     */
    getCurrentUserSellerId(): Observable<number | null> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserSellerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserSellerId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number | null>;
        }));
    }

    protected processGetCurrentUserSellerId(response: HttpResponseBase): Observable<number | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number | null>(null as any);
    }
}

export interface IUtcTimeZoneClient {
    /**
     * Convierte una fecha y hora UTC a la zona horaria de un pas especfico.
     * @param destinationCountryIso (optional) 
     * @param datetimeFrom (optional) 
     * @return Devuelve la fecha y hora convertida exitosamente.
     */
    utcTimeZone(destinationCountryIso: string | undefined, datetimeFrom: Date | undefined): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class UtcTimeZoneClient implements IUtcTimeZoneClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Convierte una fecha y hora UTC a la zona horaria de un pas especfico.
     * @param destinationCountryIso (optional) 
     * @param datetimeFrom (optional) 
     * @return Devuelve la fecha y hora convertida exitosamente.
     */
    utcTimeZone(destinationCountryIso: string | undefined, datetimeFrom: Date | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/UtcTimeZone/utc?";
        if (destinationCountryIso === null)
            throw new Error("The parameter 'destinationCountryIso' cannot be null.");
        else if (destinationCountryIso !== undefined)
            url_ += "DestinationCountryIso=" + encodeURIComponent("" + destinationCountryIso) + "&";
        if (datetimeFrom === null)
            throw new Error("The parameter 'datetimeFrom' cannot be null.");
        else if (datetimeFrom !== undefined)
            url_ += "DatetimeFrom=" + encodeURIComponent(datetimeFrom ? "" + datetimeFrom.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUtcTimeZone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUtcTimeZone(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processUtcTimeZone(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(null as any);
    }
}

export interface IWebEnrollmentClient {
    /**
     * Creates a new web enrollment record.
     * @return Enrollment created successfully.
     */
    create(command: CreateWebEnrollmentCommand): Observable<WebEnrollmentDto>;
}

@Injectable({
    providedIn: 'root'
})
export class WebEnrollmentClient implements IWebEnrollmentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Creates a new web enrollment record.
     * @return Enrollment created successfully.
     */
    create(command: CreateWebEnrollmentCommand): Observable<WebEnrollmentDto> {
        let url_ = this.baseUrl + "/api/WebEnrollment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebEnrollmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebEnrollmentDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<WebEnrollmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebEnrollmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WebEnrollmentDto>(null as any);
    }
}

export interface IWhatsappClient {
    /**
     * Sends a WhatsApp message using the provided data.
     * @return Message sent successfully and recorded in the database.
     */
    create(command: SendWhatsappCommand): Observable<number>;
}

@Injectable({
    providedIn: 'root'
})
export class WhatsappClient implements IWhatsappClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(CRM_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Sends a WhatsApp message using the provided data.
     * @return Message sent successfully and recorded in the database.
     */
    create(command: SendWhatsappCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Whatsapp";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(null as any);
    }
}

export class ActionInfoDto implements IActionInfoDto {
    day?: number;
    attemptsCalls?: number;
    isActive3X3X3?: boolean;
    maxAttemptsCalls?: number;

    constructor(data?: IActionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day = _data["day"];
            this.attemptsCalls = _data["attemptsCalls"];
            this.isActive3X3X3 = _data["isActive3X3X3"];
            this.maxAttemptsCalls = _data["maxAttemptsCalls"];
        }
    }

    static fromJS(data: any): ActionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["day"] = this.day;
        data["attemptsCalls"] = this.attemptsCalls;
        data["isActive3X3X3"] = this.isActive3X3X3;
        data["maxAttemptsCalls"] = this.maxAttemptsCalls;
        return data;
    }
}

export interface IActionInfoDto {
    day?: number;
    attemptsCalls?: number;
    isActive3X3X3?: boolean;
    maxAttemptsCalls?: number;
}

export class ActionChildViewModel implements IActionChildViewModel {
    id?: number;
    userId?: number | undefined;
    contactId?: number;
    processId?: number | undefined;
    ordersImportedId?: number | undefined;
    date?: Date;
    finishDate?: Date | undefined;
    actionType?: string;
    outcome?: string;
    reassignment?: ReassignmentDto | undefined;
    user?: UserDto;
    appointments?: AppointmentChildDto[];

    constructor(data?: IActionChildViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
            this.ordersImportedId = _data["ordersImportedId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.finishDate = _data["finishDate"] ? new Date(_data["finishDate"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.outcome = _data["outcome"];
            this.reassignment = _data["reassignment"] ? ReassignmentDto.fromJS(_data["reassignment"]) : <any>undefined;
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["appointments"])) {
                this.appointments = [] as any;
                for (let item of _data["appointments"])
                    this.appointments!.push(AppointmentChildDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActionChildViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActionChildViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        data["ordersImportedId"] = this.ordersImportedId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["finishDate"] = this.finishDate ? this.finishDate.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["outcome"] = this.outcome;
        data["reassignment"] = this.reassignment ? this.reassignment.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.appointments)) {
            data["appointments"] = [];
            for (let item of this.appointments)
                data["appointments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IActionChildViewModel {
    id?: number;
    userId?: number | undefined;
    contactId?: number;
    processId?: number | undefined;
    ordersImportedId?: number | undefined;
    date?: Date;
    finishDate?: Date | undefined;
    actionType?: string;
    outcome?: string;
    reassignment?: ReassignmentDto | undefined;
    user?: UserDto;
    appointments?: AppointmentChildDto[];
}

export class ReassignmentDto implements IReassignmentDto {
    id?: number;
    fromUserId?: number;
    toUserId?: number;
    rassignerId?: number;
    fromUser?: UserDto;
    toUser?: UserDto;
    reassigner?: UserDto;

    constructor(data?: IReassignmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fromUserId = _data["fromUserId"];
            this.toUserId = _data["toUserId"];
            this.rassignerId = _data["rassignerId"];
            this.fromUser = _data["fromUser"] ? UserDto.fromJS(_data["fromUser"]) : <any>undefined;
            this.toUser = _data["toUser"] ? UserDto.fromJS(_data["toUser"]) : <any>undefined;
            this.reassigner = _data["reassigner"] ? UserDto.fromJS(_data["reassigner"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ReassignmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReassignmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fromUserId"] = this.fromUserId;
        data["toUserId"] = this.toUserId;
        data["rassignerId"] = this.rassignerId;
        data["fromUser"] = this.fromUser ? this.fromUser.toJSON() : <any>undefined;
        data["toUser"] = this.toUser ? this.toUser.toJSON() : <any>undefined;
        data["reassigner"] = this.reassigner ? this.reassigner.toJSON() : <any>undefined;
        return data;
    }
}

export interface IReassignmentDto {
    id?: number;
    fromUserId?: number;
    toUserId?: number;
    rassignerId?: number;
    fromUser?: UserDto;
    toUser?: UserDto;
    reassigner?: UserDto;
}

export class UserDto implements IUserDto {
    id?: number;
    name?: string;
    surname?: string;
    email?: string;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        return data;
    }
}

export interface IUserDto {
    id?: number;
    name?: string;
    surname?: string;
    email?: string;
}

export class AppointmentChildDto implements IAppointmentChildDto {
    id?: number;
    userId?: number;
    actionId?: number;
    title?: string;
    date?: Date;
    type?: string;
    isAnnulled?: boolean;

    constructor(data?: IAppointmentChildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.actionId = _data["actionId"];
            this.title = _data["title"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.isAnnulled = _data["isAnnulled"];
        }
    }

    static fromJS(data: any): AppointmentChildDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentChildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["actionId"] = this.actionId;
        data["title"] = this.title;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["isAnnulled"] = this.isAnnulled;
        return data;
    }
}

export interface IAppointmentChildDto {
    id?: number;
    userId?: number;
    actionId?: number;
    title?: string;
    date?: Date;
    type?: string;
    isAnnulled?: boolean;
}

export class ActionCreateDto implements IActionCreateDto {
    userId?: number | undefined;
    contactId?: number;
    processId?: number;
    date?: Date;
    actionType?: string;
    outcome?: string;
    appointments?: AppointmentDto[];

    constructor(data?: IActionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.outcome = _data["outcome"];
            if (Array.isArray(_data["appointments"])) {
                this.appointments = [] as any;
                for (let item of _data["appointments"])
                    this.appointments!.push(AppointmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["outcome"] = this.outcome;
        if (Array.isArray(this.appointments)) {
            data["appointments"] = [];
            for (let item of this.appointments)
                data["appointments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IActionCreateDto {
    userId?: number | undefined;
    contactId?: number;
    processId?: number;
    date?: Date;
    actionType?: string;
    outcome?: string;
    appointments?: AppointmentDto[];
}

export class CreateActionCommand extends ActionCreateDto implements ICreateActionCommand {

    constructor(data?: ICreateActionCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateActionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateActionCommand extends IActionCreateDto {
}

export class AppointmentDto implements IAppointmentDto {
    id?: number;
    userId?: number;
    actionId?: number;
    user?: UserDto;
    action?: ActionChildDto;
    title?: string;
    date?: Date;
    type?: string;

    constructor(data?: IAppointmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.actionId = _data["actionId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.action = _data["action"] ? ActionChildDto.fromJS(_data["action"]) : <any>undefined;
            this.title = _data["title"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): AppointmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["actionId"] = this.actionId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

export interface IAppointmentDto {
    id?: number;
    userId?: number;
    actionId?: number;
    user?: UserDto;
    action?: ActionChildDto;
    title?: string;
    date?: Date;
    type?: string;
}

export class ActionChildDto implements IActionChildDto {
    id?: number;
    userId?: number | undefined;
    contactId?: number;
    processId?: number | undefined;
    ordersImportedId?: number | undefined;
    date?: Date;
    finishDate?: Date | undefined;
    type?: string;
    outcome?: string;

    constructor(data?: IActionChildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
            this.ordersImportedId = _data["ordersImportedId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.finishDate = _data["finishDate"] ? new Date(_data["finishDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.outcome = _data["outcome"];
        }
    }

    static fromJS(data: any): ActionChildDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionChildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        data["ordersImportedId"] = this.ordersImportedId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["finishDate"] = this.finishDate ? this.finishDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["outcome"] = this.outcome;
        return data;
    }
}

export interface IActionChildDto {
    id?: number;
    userId?: number | undefined;
    contactId?: number;
    processId?: number | undefined;
    ordersImportedId?: number | undefined;
    date?: Date;
    finishDate?: Date | undefined;
    type?: string;
    outcome?: string;
}

export class ActionUpdateDto implements IActionUpdateDto {
    id?: number;
    userId?: number | undefined;
    contactId?: number;
    processId?: number | undefined;
    ordersImportedId?: number | undefined;
    date?: Date;
    finishDate?: Date;
    actionType?: string;
    outcome?: string;
    appointments?: AppointmentDto[];

    constructor(data?: IActionUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
            this.ordersImportedId = _data["ordersImportedId"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.finishDate = _data["finishDate"] ? new Date(_data["finishDate"].toString()) : <any>undefined;
            this.actionType = _data["actionType"];
            this.outcome = _data["outcome"];
            if (Array.isArray(_data["appointments"])) {
                this.appointments = [] as any;
                for (let item of _data["appointments"])
                    this.appointments!.push(AppointmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActionUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        data["ordersImportedId"] = this.ordersImportedId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["finishDate"] = this.finishDate ? this.finishDate.toISOString() : <any>undefined;
        data["actionType"] = this.actionType;
        data["outcome"] = this.outcome;
        if (Array.isArray(this.appointments)) {
            data["appointments"] = [];
            for (let item of this.appointments)
                data["appointments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IActionUpdateDto {
    id?: number;
    userId?: number | undefined;
    contactId?: number;
    processId?: number | undefined;
    ordersImportedId?: number | undefined;
    date?: Date;
    finishDate?: Date;
    actionType?: string;
    outcome?: string;
    appointments?: AppointmentDto[];
}

export class UpdateActionCommand extends ActionUpdateDto implements IUpdateActionCommand {

    constructor(data?: IUpdateActionCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpdateActionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateActionCommand extends IActionUpdateDto {
}

export class ActiveCallDetailsDto implements IActiveCallDetailsDto {
    id?: number | undefined;
    contactId?: number | undefined;
    processId?: number | undefined;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    processColour?: string;
    contactEmail?: string;
    contactPhone?: string;
    outcome?: string;
    date?: Date | undefined;
    process?: ProcessDto;

    constructor(data?: IActiveCallDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
            this.name = _data["name"];
            this.firstSurName = _data["firstSurName"];
            this.secondSurName = _data["secondSurName"];
            this.processColour = _data["processColour"];
            this.contactEmail = _data["contactEmail"];
            this.contactPhone = _data["contactPhone"];
            this.outcome = _data["outcome"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.process = _data["process"] ? ProcessDto.fromJS(_data["process"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActiveCallDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveCallDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        data["name"] = this.name;
        data["firstSurName"] = this.firstSurName;
        data["secondSurName"] = this.secondSurName;
        data["processColour"] = this.processColour;
        data["contactEmail"] = this.contactEmail;
        data["contactPhone"] = this.contactPhone;
        data["outcome"] = this.outcome;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["process"] = this.process ? this.process.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActiveCallDetailsDto {
    id?: number | undefined;
    contactId?: number | undefined;
    processId?: number | undefined;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    processColour?: string;
    contactEmail?: string;
    contactPhone?: string;
    outcome?: string;
    date?: Date | undefined;
    process?: ProcessDto;
}

export class ProcessDto implements IProcessDto {
    contactLanguageId?: number;
    id?: number;
    userId?: number;
    name?: string;
    email?: string;
    firstSurname?: string;
    contactLanguage?: ContactLanguageDto | undefined;
    contactId?: number;
    ordersImportedId?: number;
    created?: Date;
    user?: UserDto;
    contact?: ContactDto;
    ordersImported?: OrdersImportedChildDto;
    type?: string;
    status?: string;
    outcome?: string;
    description?: string;
    colour?: string | undefined;
    attempts?: number;
    activeCall?: boolean;
    lastActionDate?: Date | undefined;
    lastAction?: LastActionProcessDto | undefined;
    nextAction?: AppointmentDto | undefined;
    nextInteractionDate?: Date;
    actions?: ActionChildDto[];
    faculties?: FacultyDto[] | undefined;
    specialities?: SpecialityDto[] | undefined;
    initialDate?: Date | undefined;

    constructor(data?: IProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactLanguageId = _data["contactLanguageId"];
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.firstSurname = _data["firstSurname"];
            this.contactLanguage = _data["contactLanguage"] ? ContactLanguageDto.fromJS(_data["contactLanguage"]) : <any>undefined;
            this.contactId = _data["contactId"];
            this.ordersImportedId = _data["ordersImportedId"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.contact = _data["contact"] ? ContactDto.fromJS(_data["contact"]) : <any>undefined;
            this.ordersImported = _data["ordersImported"] ? OrdersImportedChildDto.fromJS(_data["ordersImported"]) : <any>undefined;
            this.type = _data["type"];
            this.status = _data["status"];
            this.outcome = _data["outcome"];
            this.description = _data["description"];
            this.colour = _data["colour"];
            this.attempts = _data["attempts"];
            this.activeCall = _data["activeCall"];
            this.lastActionDate = _data["lastActionDate"] ? new Date(_data["lastActionDate"].toString()) : <any>undefined;
            this.lastAction = _data["lastAction"] ? LastActionProcessDto.fromJS(_data["lastAction"]) : <any>undefined;
            this.nextAction = _data["nextAction"] ? AppointmentDto.fromJS(_data["nextAction"]) : <any>undefined;
            this.nextInteractionDate = _data["nextInteractionDate"] ? new Date(_data["nextInteractionDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(ActionChildDto.fromJS(item));
            }
            if (Array.isArray(_data["faculties"])) {
                this.faculties = [] as any;
                for (let item of _data["faculties"])
                    this.faculties!.push(FacultyDto.fromJS(item));
            }
            if (Array.isArray(_data["specialities"])) {
                this.specialities = [] as any;
                for (let item of _data["specialities"])
                    this.specialities!.push(SpecialityDto.fromJS(item));
            }
            this.initialDate = _data["initialDate"] ? new Date(_data["initialDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactLanguageId"] = this.contactLanguageId;
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["email"] = this.email;
        data["firstSurname"] = this.firstSurname;
        data["contactLanguage"] = this.contactLanguage ? this.contactLanguage.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["ordersImportedId"] = this.ordersImportedId;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["ordersImported"] = this.ordersImported ? this.ordersImported.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["status"] = this.status;
        data["outcome"] = this.outcome;
        data["description"] = this.description;
        data["colour"] = this.colour;
        data["attempts"] = this.attempts;
        data["activeCall"] = this.activeCall;
        data["lastActionDate"] = this.lastActionDate ? this.lastActionDate.toISOString() : <any>undefined;
        data["lastAction"] = this.lastAction ? this.lastAction.toJSON() : <any>undefined;
        data["nextAction"] = this.nextAction ? this.nextAction.toJSON() : <any>undefined;
        data["nextInteractionDate"] = this.nextInteractionDate ? this.nextInteractionDate.toISOString() : <any>undefined;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        if (Array.isArray(this.faculties)) {
            data["faculties"] = [];
            for (let item of this.faculties)
                data["faculties"].push(item.toJSON());
        }
        if (Array.isArray(this.specialities)) {
            data["specialities"] = [];
            for (let item of this.specialities)
                data["specialities"].push(item.toJSON());
        }
        data["initialDate"] = this.initialDate ? this.initialDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IProcessDto {
    contactLanguageId?: number;
    id?: number;
    userId?: number;
    name?: string;
    email?: string;
    firstSurname?: string;
    contactLanguage?: ContactLanguageDto | undefined;
    contactId?: number;
    ordersImportedId?: number;
    created?: Date;
    user?: UserDto;
    contact?: ContactDto;
    ordersImported?: OrdersImportedChildDto;
    type?: string;
    status?: string;
    outcome?: string;
    description?: string;
    colour?: string | undefined;
    attempts?: number;
    activeCall?: boolean;
    lastActionDate?: Date | undefined;
    lastAction?: LastActionProcessDto | undefined;
    nextAction?: AppointmentDto | undefined;
    nextInteractionDate?: Date;
    actions?: ActionChildDto[];
    faculties?: FacultyDto[] | undefined;
    specialities?: SpecialityDto[] | undefined;
    initialDate?: Date | undefined;
}

export class ContactLanguageDto implements IContactLanguageDto {
    id?: number;
    contactId?: number;
    languageId?: number;
    language?: LanguageDto;
    isDefault?: boolean;

    constructor(data?: IContactLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.languageId = _data["languageId"];
            this.language = _data["language"] ? LanguageDto.fromJS(_data["language"]) : <any>undefined;
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["languageId"] = this.languageId;
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IContactLanguageDto {
    id?: number;
    contactId?: number;
    languageId?: number;
    language?: LanguageDto;
    isDefault?: boolean;
}

export class LanguageDto implements ILanguageDto {
    id?: number;
    name?: string;
    nativeName?: string;
    dateFormat?: string;
    currency?: string;
    flagCode?: string;

    constructor(data?: ILanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.nativeName = _data["nativeName"];
            this.dateFormat = _data["dateFormat"];
            this.currency = _data["currency"];
            this.flagCode = _data["flagCode"];
        }
    }

    static fromJS(data: any): LanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["nativeName"] = this.nativeName;
        data["dateFormat"] = this.dateFormat;
        data["currency"] = this.currency;
        data["flagCode"] = this.flagCode;
        return data;
    }
}

export interface ILanguageDto {
    id?: number;
    name?: string;
    nativeName?: string;
    dateFormat?: string;
    currency?: string;
    flagCode?: string;
}

export class ContactDto implements IContactDto {
    id?: number;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    phone?: string;
    studentCIF?: string;
    fiscalCIF?: string;
    email?: string;
    legalName?: string | undefined;
    idCard?: string;
    countryCode?: string;
    contactTypeId?: number;
    type?: ContactTypeDto;
    contactStatusId?: number;
    status?: ContactStatusDto;
    mainArea?: string;
    mainSpeciality?: string;
    origin?: string;
    profession?: string;
    career?: string;
    contactGenderId?: number;
    gender?: ContactGenderDto;
    dateOfBirth?: Date | undefined;
    nationality?: string;
    company?: string;
    lastSale?: Date | undefined;
    keyRegimeCode?: string | undefined;
    customerAccount?: string | undefined;
    occupation?: string | undefined;
    centerName?: string | undefined;
    workCenter?: string | undefined;
    observations?: string | undefined;
    originContactId?: number | undefined;
    lastInteraction?: Date | undefined;
    nextInteraction?: Date | undefined;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.firstSurName = _data["firstSurName"];
            this.secondSurName = _data["secondSurName"];
            this.phone = _data["phone"];
            this.studentCIF = _data["studentCIF"];
            this.fiscalCIF = _data["fiscalCIF"];
            this.email = _data["email"];
            this.legalName = _data["legalName"];
            this.idCard = _data["idCard"];
            this.countryCode = _data["countryCode"];
            this.contactTypeId = _data["contactTypeId"];
            this.type = _data["type"] ? ContactTypeDto.fromJS(_data["type"]) : <any>undefined;
            this.contactStatusId = _data["contactStatusId"];
            this.status = _data["status"] ? ContactStatusDto.fromJS(_data["status"]) : <any>undefined;
            this.mainArea = _data["mainArea"];
            this.mainSpeciality = _data["mainSpeciality"];
            this.origin = _data["origin"];
            this.profession = _data["profession"];
            this.career = _data["career"];
            this.contactGenderId = _data["contactGenderId"];
            this.gender = _data["gender"] ? ContactGenderDto.fromJS(_data["gender"]) : <any>undefined;
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.nationality = _data["nationality"];
            this.company = _data["company"];
            this.lastSale = _data["lastSale"] ? new Date(_data["lastSale"].toString()) : <any>undefined;
            this.keyRegimeCode = _data["keyRegimeCode"];
            this.customerAccount = _data["customerAccount"];
            this.occupation = _data["occupation"];
            this.centerName = _data["centerName"];
            this.workCenter = _data["workCenter"];
            this.observations = _data["observations"];
            this.originContactId = _data["originContactId"];
            this.lastInteraction = _data["lastInteraction"] ? new Date(_data["lastInteraction"].toString()) : <any>undefined;
            this.nextInteraction = _data["nextInteraction"] ? new Date(_data["nextInteraction"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["firstSurName"] = this.firstSurName;
        data["secondSurName"] = this.secondSurName;
        data["phone"] = this.phone;
        data["studentCIF"] = this.studentCIF;
        data["fiscalCIF"] = this.fiscalCIF;
        data["email"] = this.email;
        data["legalName"] = this.legalName;
        data["idCard"] = this.idCard;
        data["countryCode"] = this.countryCode;
        data["contactTypeId"] = this.contactTypeId;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["contactStatusId"] = this.contactStatusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["mainArea"] = this.mainArea;
        data["mainSpeciality"] = this.mainSpeciality;
        data["origin"] = this.origin;
        data["profession"] = this.profession;
        data["career"] = this.career;
        data["contactGenderId"] = this.contactGenderId;
        data["gender"] = this.gender ? this.gender.toJSON() : <any>undefined;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["nationality"] = this.nationality;
        data["company"] = this.company;
        data["lastSale"] = this.lastSale ? this.lastSale.toISOString() : <any>undefined;
        data["keyRegimeCode"] = this.keyRegimeCode;
        data["customerAccount"] = this.customerAccount;
        data["occupation"] = this.occupation;
        data["centerName"] = this.centerName;
        data["workCenter"] = this.workCenter;
        data["observations"] = this.observations;
        data["originContactId"] = this.originContactId;
        data["lastInteraction"] = this.lastInteraction ? this.lastInteraction.toISOString() : <any>undefined;
        data["nextInteraction"] = this.nextInteraction ? this.nextInteraction.toISOString() : <any>undefined;
        return data;
    }
}

export interface IContactDto {
    id?: number;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    phone?: string;
    studentCIF?: string;
    fiscalCIF?: string;
    email?: string;
    legalName?: string | undefined;
    idCard?: string;
    countryCode?: string;
    contactTypeId?: number;
    type?: ContactTypeDto;
    contactStatusId?: number;
    status?: ContactStatusDto;
    mainArea?: string;
    mainSpeciality?: string;
    origin?: string;
    profession?: string;
    career?: string;
    contactGenderId?: number;
    gender?: ContactGenderDto;
    dateOfBirth?: Date | undefined;
    nationality?: string;
    company?: string;
    lastSale?: Date | undefined;
    keyRegimeCode?: string | undefined;
    customerAccount?: string | undefined;
    occupation?: string | undefined;
    centerName?: string | undefined;
    workCenter?: string | undefined;
    observations?: string | undefined;
    originContactId?: number | undefined;
    lastInteraction?: Date | undefined;
    nextInteraction?: Date | undefined;
}

export class ContactTypeDto implements IContactTypeDto {
    id?: number;
    name?: string;
    label?: string;

    constructor(data?: IContactTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): ContactTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        return data;
    }
}

export interface IContactTypeDto {
    id?: number;
    name?: string;
    label?: string;
}

export class ContactStatusDto implements IContactStatusDto {
    id?: number;
    name?: string;
    label?: string;

    constructor(data?: IContactStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): ContactStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        return data;
    }
}

export interface IContactStatusDto {
    id?: number;
    name?: string;
    label?: string;
}

export class ContactGenderDto implements IContactGenderDto {
    id?: number;
    name?: string;
    label?: string;

    constructor(data?: IContactGenderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): ContactGenderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGenderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        return data;
    }
}

export interface IContactGenderDto {
    id?: number;
    name?: string;
    label?: string;
}

export class OrdersImportedChildDto implements IOrdersImportedChildDto {
    id?: number;
    orderNumber?: number;
    courseId?: number | undefined;
    processId?: number | undefined;
    actionId?: number | undefined;
    contactId?: number | undefined;
    studentName?: string | undefined;
    studentSurName?: string | undefined;
    orderDate?: Date | undefined;
    title?: string | undefined;
    area?: string | undefined;
    courseCode?: string | undefined;

    constructor(data?: IOrdersImportedChildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.courseId = _data["courseId"];
            this.processId = _data["processId"];
            this.actionId = _data["actionId"];
            this.contactId = _data["contactId"];
            this.studentName = _data["studentName"];
            this.studentSurName = _data["studentSurName"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.area = _data["area"];
            this.courseCode = _data["courseCode"];
        }
    }

    static fromJS(data: any): OrdersImportedChildDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrdersImportedChildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["courseId"] = this.courseId;
        data["processId"] = this.processId;
        data["actionId"] = this.actionId;
        data["contactId"] = this.contactId;
        data["studentName"] = this.studentName;
        data["studentSurName"] = this.studentSurName;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["area"] = this.area;
        data["courseCode"] = this.courseCode;
        return data;
    }
}

export interface IOrdersImportedChildDto {
    id?: number;
    orderNumber?: number;
    courseId?: number | undefined;
    processId?: number | undefined;
    actionId?: number | undefined;
    contactId?: number | undefined;
    studentName?: string | undefined;
    studentSurName?: string | undefined;
    orderDate?: Date | undefined;
    title?: string | undefined;
    area?: string | undefined;
    courseCode?: string | undefined;
}

export class LastActionProcessDto implements ILastActionProcessDto {
    type?: string;
    courseTitle?: string;

    constructor(data?: ILastActionProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.courseTitle = _data["courseTitle"];
        }
    }

    static fromJS(data: any): LastActionProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new LastActionProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["courseTitle"] = this.courseTitle;
        return data;
    }
}

export interface ILastActionProcessDto {
    type?: string;
    courseTitle?: string;
}

export class FacultyDto implements IFacultyDto {
    id?: number;
    name?: string;
    label?: string;
    seoUrl?: string;
    color?: string;
    code?: string;

    constructor(data?: IFacultyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
            this.seoUrl = _data["seoUrl"];
            this.color = _data["color"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): FacultyDto {
        data = typeof data === 'object' ? data : {};
        let result = new FacultyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        data["seoUrl"] = this.seoUrl;
        data["color"] = this.color;
        data["code"] = this.code;
        return data;
    }
}

export interface IFacultyDto {
    id?: number;
    name?: string;
    label?: string;
    seoUrl?: string;
    color?: string;
    code?: string;
}

export class SpecialityDto implements ISpecialityDto {
    id?: number;
    name?: string;
    label?: string;
    seoUrl?: string;
    seoTitle?: string;
    originalCategoryId?: string;
    code?: string;

    constructor(data?: ISpecialityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
            this.seoUrl = _data["seoUrl"];
            this.seoTitle = _data["seoTitle"];
            this.originalCategoryId = _data["originalCategoryId"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): SpecialityDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        data["seoUrl"] = this.seoUrl;
        data["seoTitle"] = this.seoTitle;
        data["originalCategoryId"] = this.originalCategoryId;
        data["code"] = this.code;
        return data;
    }
}

export interface ISpecialityDto {
    id?: number;
    name?: string;
    label?: string;
    seoUrl?: string;
    seoTitle?: string;
    originalCategoryId?: string;
    code?: string;
}

export class AnnotationDto implements IAnnotationDto {
    id?: number;
    created?: Date;
    createdBy?: string;
    lastModified?: Date | undefined;
    lastModifiedBy?: string;
    contactId?: number;
    comment?: string;
    title?: string;
    lastEditor?: string;
    userId?: number;
    user?: UserDto;
    mandatory?: boolean;
    isPrivate?: boolean;

    constructor(data?: IAnnotationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.contactId = _data["contactId"];
            this.comment = _data["comment"];
            this.title = _data["title"];
            this.lastEditor = _data["lastEditor"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.mandatory = _data["mandatory"];
            this.isPrivate = _data["isPrivate"];
        }
    }

    static fromJS(data: any): AnnotationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnnotationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["contactId"] = this.contactId;
        data["comment"] = this.comment;
        data["title"] = this.title;
        data["lastEditor"] = this.lastEditor;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["mandatory"] = this.mandatory;
        data["isPrivate"] = this.isPrivate;
        return data;
    }
}

export interface IAnnotationDto {
    id?: number;
    created?: Date;
    createdBy?: string;
    lastModified?: Date | undefined;
    lastModifiedBy?: string;
    contactId?: number;
    comment?: string;
    title?: string;
    lastEditor?: string;
    userId?: number;
    user?: UserDto;
    mandatory?: boolean;
    isPrivate?: boolean;
}

export class AnnotationCreateDto implements IAnnotationCreateDto {
    contactId?: number;
    comment?: string;
    title?: string;
    lastEditor?: string;
    mandatory?: boolean;
    isPrivate?: boolean;

    constructor(data?: IAnnotationCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.comment = _data["comment"];
            this.title = _data["title"];
            this.lastEditor = _data["lastEditor"];
            this.mandatory = _data["mandatory"];
            this.isPrivate = _data["isPrivate"];
        }
    }

    static fromJS(data: any): AnnotationCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnnotationCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["comment"] = this.comment;
        data["title"] = this.title;
        data["lastEditor"] = this.lastEditor;
        data["mandatory"] = this.mandatory;
        data["isPrivate"] = this.isPrivate;
        return data;
    }
}

export interface IAnnotationCreateDto {
    contactId?: number;
    comment?: string;
    title?: string;
    lastEditor?: string;
    mandatory?: boolean;
    isPrivate?: boolean;
}

export class CreateAnnotationCommand extends AnnotationCreateDto implements ICreateAnnotationCommand {

    constructor(data?: ICreateAnnotationCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateAnnotationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAnnotationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateAnnotationCommand extends IAnnotationCreateDto {
}

export class AnnotationUpdateDto implements IAnnotationUpdateDto {
    id?: number;
    userId?: number;
    comment?: string;
    title?: string;
    lastEditor?: string;
    mandatory?: boolean;
    isPrivate?: boolean;

    constructor(data?: IAnnotationUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.comment = _data["comment"];
            this.title = _data["title"];
            this.lastEditor = _data["lastEditor"];
            this.mandatory = _data["mandatory"];
            this.isPrivate = _data["isPrivate"];
        }
    }

    static fromJS(data: any): AnnotationUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AnnotationUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["comment"] = this.comment;
        data["title"] = this.title;
        data["lastEditor"] = this.lastEditor;
        data["mandatory"] = this.mandatory;
        data["isPrivate"] = this.isPrivate;
        return data;
    }
}

export interface IAnnotationUpdateDto {
    id?: number;
    userId?: number;
    comment?: string;
    title?: string;
    lastEditor?: string;
    mandatory?: boolean;
    isPrivate?: boolean;
}

export class UpdateAnnotationCommand extends AnnotationUpdateDto implements IUpdateAnnotationCommand {

    constructor(data?: IUpdateAnnotationCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpdateAnnotationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAnnotationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateAnnotationCommand extends IAnnotationUpdateDto {
}

export class AppointmentCreateDto implements IAppointmentCreateDto {
    contactId?: number;
    processId?: number;
    type?: string;
    title?: string;
    date?: Date;

    constructor(data?: IAppointmentCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
            this.type = _data["type"];
            this.title = _data["title"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AppointmentCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        data["type"] = this.type;
        data["title"] = this.title;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAppointmentCreateDto {
    contactId?: number;
    processId?: number;
    type?: string;
    title?: string;
    date?: Date;
}

export class CreateAppointmentCommand extends AppointmentCreateDto implements ICreateAppointmentCommand {

    constructor(data?: ICreateAppointmentCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateAppointmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAppointmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateAppointmentCommand extends IAppointmentCreateDto {
}

export class AppointmentUpdateDto implements IAppointmentUpdateDto {
    id?: number;
    userId?: number;
    actionId?: number;
    title?: string;
    date?: Date;
    type?: string;

    constructor(data?: IAppointmentUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.actionId = _data["actionId"];
            this.title = _data["title"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): AppointmentUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppointmentUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["actionId"] = this.actionId;
        data["title"] = this.title;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["type"] = this.type;
        return data;
    }
}

export interface IAppointmentUpdateDto {
    id?: number;
    userId?: number;
    actionId?: number;
    title?: string;
    date?: Date;
    type?: string;
}

export class UpdateAppointmentCommand extends AppointmentUpdateDto implements IUpdateAppointmentCommand {

    constructor(data?: IUpdateAppointmentCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpdateAppointmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAppointmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateAppointmentCommand extends IAppointmentUpdateDto {
}

export class ContactFullDto implements IContactFullDto {
    id?: number;
    guid?: string;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    studentCIF?: string;
    fiscalCIF?: string;
    email?: string;
    legalName?: string | undefined;
    idCard?: string;
    countryCode?: string | undefined;
    country?: CourseCountryDto | undefined;
    currencyId?: number | undefined;
    currency?: CurrencyDto | undefined;
    contactTypeId?: number;
    type?: ContactTypeDto;
    contactStatusId?: number;
    status?: ContactStatusDto;
    mainArea?: string;
    mainSpeciality?: string;
    origin?: string;
    profession?: string;
    career?: string;
    contactGenderId?: number;
    gender?: ContactGenderDto;
    dateOfBirth?: Date | undefined;
    nationality?: string;
    company?: string;
    lastSale?: Date | undefined;
    keyRegimeCode?: string | undefined;
    customerAccount?: string | undefined;
    occupation?: string | undefined;
    centerName?: string | undefined;
    observations?: string | undefined;
    originContactId?: number | undefined;
    title?: Title | undefined;
    workCenter?: string | undefined;
    activeCall?: ActiveCallDto;
    lastInteraction?: Date | undefined;
    nextInteraction?: Date | undefined;
    dontWantCalls?: boolean | undefined;
    faculties?: FacultyDto[];
    specialities?: SpecialityDto[];
    processes?: ProcessChildViewModel[];
    contactPhone?: ContactPhoneDto[];
    contactEmail?: ContactEmailDto[];
    contactAddress?: ContactAddressDto[];
    contactTitles?: ContactTitleDto[];
    contactLanguages?: ContactLanguageDto[];
    saleAttempts?: number | undefined;
    isClient?: boolean;
    requestIp?: string | undefined;

    constructor(data?: IContactFullDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.guid = _data["guid"];
            this.name = _data["name"];
            this.firstSurName = _data["firstSurName"];
            this.secondSurName = _data["secondSurName"];
            this.studentCIF = _data["studentCIF"];
            this.fiscalCIF = _data["fiscalCIF"];
            this.email = _data["email"];
            this.legalName = _data["legalName"];
            this.idCard = _data["idCard"];
            this.countryCode = _data["countryCode"];
            this.country = _data["country"] ? CourseCountryDto.fromJS(_data["country"]) : <any>undefined;
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.contactTypeId = _data["contactTypeId"];
            this.type = _data["type"] ? ContactTypeDto.fromJS(_data["type"]) : <any>undefined;
            this.contactStatusId = _data["contactStatusId"];
            this.status = _data["status"] ? ContactStatusDto.fromJS(_data["status"]) : <any>undefined;
            this.mainArea = _data["mainArea"];
            this.mainSpeciality = _data["mainSpeciality"];
            this.origin = _data["origin"];
            this.profession = _data["profession"];
            this.career = _data["career"];
            this.contactGenderId = _data["contactGenderId"];
            this.gender = _data["gender"] ? ContactGenderDto.fromJS(_data["gender"]) : <any>undefined;
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.nationality = _data["nationality"];
            this.company = _data["company"];
            this.lastSale = _data["lastSale"] ? new Date(_data["lastSale"].toString()) : <any>undefined;
            this.keyRegimeCode = _data["keyRegimeCode"];
            this.customerAccount = _data["customerAccount"];
            this.occupation = _data["occupation"];
            this.centerName = _data["centerName"];
            this.observations = _data["observations"];
            this.originContactId = _data["originContactId"];
            this.title = _data["title"];
            this.workCenter = _data["workCenter"];
            this.activeCall = _data["activeCall"] ? ActiveCallDto.fromJS(_data["activeCall"]) : <any>undefined;
            this.lastInteraction = _data["lastInteraction"] ? new Date(_data["lastInteraction"].toString()) : <any>undefined;
            this.nextInteraction = _data["nextInteraction"] ? new Date(_data["nextInteraction"].toString()) : <any>undefined;
            this.dontWantCalls = _data["dontWantCalls"];
            if (Array.isArray(_data["faculties"])) {
                this.faculties = [] as any;
                for (let item of _data["faculties"])
                    this.faculties!.push(FacultyDto.fromJS(item));
            }
            if (Array.isArray(_data["specialities"])) {
                this.specialities = [] as any;
                for (let item of _data["specialities"])
                    this.specialities!.push(SpecialityDto.fromJS(item));
            }
            if (Array.isArray(_data["processes"])) {
                this.processes = [] as any;
                for (let item of _data["processes"])
                    this.processes!.push(ProcessChildViewModel.fromJS(item));
            }
            if (Array.isArray(_data["contactPhone"])) {
                this.contactPhone = [] as any;
                for (let item of _data["contactPhone"])
                    this.contactPhone!.push(ContactPhoneDto.fromJS(item));
            }
            if (Array.isArray(_data["contactEmail"])) {
                this.contactEmail = [] as any;
                for (let item of _data["contactEmail"])
                    this.contactEmail!.push(ContactEmailDto.fromJS(item));
            }
            if (Array.isArray(_data["contactAddress"])) {
                this.contactAddress = [] as any;
                for (let item of _data["contactAddress"])
                    this.contactAddress!.push(ContactAddressDto.fromJS(item));
            }
            if (Array.isArray(_data["contactTitles"])) {
                this.contactTitles = [] as any;
                for (let item of _data["contactTitles"])
                    this.contactTitles!.push(ContactTitleDto.fromJS(item));
            }
            if (Array.isArray(_data["contactLanguages"])) {
                this.contactLanguages = [] as any;
                for (let item of _data["contactLanguages"])
                    this.contactLanguages!.push(ContactLanguageDto.fromJS(item));
            }
            this.saleAttempts = _data["saleAttempts"];
            this.isClient = _data["isClient"];
            this.requestIp = _data["requestIp"];
        }
    }

    static fromJS(data: any): ContactFullDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactFullDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["guid"] = this.guid;
        data["name"] = this.name;
        data["firstSurName"] = this.firstSurName;
        data["secondSurName"] = this.secondSurName;
        data["studentCIF"] = this.studentCIF;
        data["fiscalCIF"] = this.fiscalCIF;
        data["email"] = this.email;
        data["legalName"] = this.legalName;
        data["idCard"] = this.idCard;
        data["countryCode"] = this.countryCode;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["contactTypeId"] = this.contactTypeId;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["contactStatusId"] = this.contactStatusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["mainArea"] = this.mainArea;
        data["mainSpeciality"] = this.mainSpeciality;
        data["origin"] = this.origin;
        data["profession"] = this.profession;
        data["career"] = this.career;
        data["contactGenderId"] = this.contactGenderId;
        data["gender"] = this.gender ? this.gender.toJSON() : <any>undefined;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["nationality"] = this.nationality;
        data["company"] = this.company;
        data["lastSale"] = this.lastSale ? this.lastSale.toISOString() : <any>undefined;
        data["keyRegimeCode"] = this.keyRegimeCode;
        data["customerAccount"] = this.customerAccount;
        data["occupation"] = this.occupation;
        data["centerName"] = this.centerName;
        data["observations"] = this.observations;
        data["originContactId"] = this.originContactId;
        data["title"] = this.title;
        data["workCenter"] = this.workCenter;
        data["activeCall"] = this.activeCall ? this.activeCall.toJSON() : <any>undefined;
        data["lastInteraction"] = this.lastInteraction ? this.lastInteraction.toISOString() : <any>undefined;
        data["nextInteraction"] = this.nextInteraction ? this.nextInteraction.toISOString() : <any>undefined;
        data["dontWantCalls"] = this.dontWantCalls;
        if (Array.isArray(this.faculties)) {
            data["faculties"] = [];
            for (let item of this.faculties)
                data["faculties"].push(item.toJSON());
        }
        if (Array.isArray(this.specialities)) {
            data["specialities"] = [];
            for (let item of this.specialities)
                data["specialities"].push(item.toJSON());
        }
        if (Array.isArray(this.processes)) {
            data["processes"] = [];
            for (let item of this.processes)
                data["processes"].push(item.toJSON());
        }
        if (Array.isArray(this.contactPhone)) {
            data["contactPhone"] = [];
            for (let item of this.contactPhone)
                data["contactPhone"].push(item.toJSON());
        }
        if (Array.isArray(this.contactEmail)) {
            data["contactEmail"] = [];
            for (let item of this.contactEmail)
                data["contactEmail"].push(item.toJSON());
        }
        if (Array.isArray(this.contactAddress)) {
            data["contactAddress"] = [];
            for (let item of this.contactAddress)
                data["contactAddress"].push(item.toJSON());
        }
        if (Array.isArray(this.contactTitles)) {
            data["contactTitles"] = [];
            for (let item of this.contactTitles)
                data["contactTitles"].push(item.toJSON());
        }
        if (Array.isArray(this.contactLanguages)) {
            data["contactLanguages"] = [];
            for (let item of this.contactLanguages)
                data["contactLanguages"].push(item.toJSON());
        }
        data["saleAttempts"] = this.saleAttempts;
        data["isClient"] = this.isClient;
        data["requestIp"] = this.requestIp;
        return data;
    }
}

export interface IContactFullDto {
    id?: number;
    guid?: string;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    studentCIF?: string;
    fiscalCIF?: string;
    email?: string;
    legalName?: string | undefined;
    idCard?: string;
    countryCode?: string | undefined;
    country?: CourseCountryDto | undefined;
    currencyId?: number | undefined;
    currency?: CurrencyDto | undefined;
    contactTypeId?: number;
    type?: ContactTypeDto;
    contactStatusId?: number;
    status?: ContactStatusDto;
    mainArea?: string;
    mainSpeciality?: string;
    origin?: string;
    profession?: string;
    career?: string;
    contactGenderId?: number;
    gender?: ContactGenderDto;
    dateOfBirth?: Date | undefined;
    nationality?: string;
    company?: string;
    lastSale?: Date | undefined;
    keyRegimeCode?: string | undefined;
    customerAccount?: string | undefined;
    occupation?: string | undefined;
    centerName?: string | undefined;
    observations?: string | undefined;
    originContactId?: number | undefined;
    title?: Title | undefined;
    workCenter?: string | undefined;
    activeCall?: ActiveCallDto;
    lastInteraction?: Date | undefined;
    nextInteraction?: Date | undefined;
    dontWantCalls?: boolean | undefined;
    faculties?: FacultyDto[];
    specialities?: SpecialityDto[];
    processes?: ProcessChildViewModel[];
    contactPhone?: ContactPhoneDto[];
    contactEmail?: ContactEmailDto[];
    contactAddress?: ContactAddressDto[];
    contactTitles?: ContactTitleDto[];
    contactLanguages?: ContactLanguageDto[];
    saleAttempts?: number | undefined;
    isClient?: boolean;
    requestIp?: string | undefined;
}

export class CourseCountryDto implements ICourseCountryDto {
    id?: number;
    originalCountryId?: number;
    name?: string;
    code?: string;
    hreflangCode?: string;
    languageCode?: string;
    currency?: string;
    currencyName?: string;
    currencyCode?: string;
    currencyFormat?: string;
    geoApiId?: number;
    logo?: string;
    inverseLogo?: string;
    flagIcon?: string;
    isActive?: boolean;
    language?: LanguageDto;
    languageId?: number | undefined;
    seoUrl?: string;
    defaultCountry?: boolean | undefined;
    mirrorCountryId?: number | undefined;
    generateCatalog?: boolean | undefined;

    constructor(data?: ICourseCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.originalCountryId = _data["originalCountryId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.hreflangCode = _data["hreflangCode"];
            this.languageCode = _data["languageCode"];
            this.currency = _data["currency"];
            this.currencyName = _data["currencyName"];
            this.currencyCode = _data["currencyCode"];
            this.currencyFormat = _data["currencyFormat"];
            this.geoApiId = _data["geoApiId"];
            this.logo = _data["logo"];
            this.inverseLogo = _data["inverseLogo"];
            this.flagIcon = _data["flagIcon"];
            this.isActive = _data["isActive"];
            this.language = _data["language"] ? LanguageDto.fromJS(_data["language"]) : <any>undefined;
            this.languageId = _data["languageId"];
            this.seoUrl = _data["seoUrl"];
            this.defaultCountry = _data["defaultCountry"];
            this.mirrorCountryId = _data["mirrorCountryId"];
            this.generateCatalog = _data["generateCatalog"];
        }
    }

    static fromJS(data: any): CourseCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["originalCountryId"] = this.originalCountryId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["hreflangCode"] = this.hreflangCode;
        data["languageCode"] = this.languageCode;
        data["currency"] = this.currency;
        data["currencyName"] = this.currencyName;
        data["currencyCode"] = this.currencyCode;
        data["currencyFormat"] = this.currencyFormat;
        data["geoApiId"] = this.geoApiId;
        data["logo"] = this.logo;
        data["inverseLogo"] = this.inverseLogo;
        data["flagIcon"] = this.flagIcon;
        data["isActive"] = this.isActive;
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        data["languageId"] = this.languageId;
        data["seoUrl"] = this.seoUrl;
        data["defaultCountry"] = this.defaultCountry;
        data["mirrorCountryId"] = this.mirrorCountryId;
        data["generateCatalog"] = this.generateCatalog;
        return data;
    }
}

export interface ICourseCountryDto {
    id?: number;
    originalCountryId?: number;
    name?: string;
    code?: string;
    hreflangCode?: string;
    languageCode?: string;
    currency?: string;
    currencyName?: string;
    currencyCode?: string;
    currencyFormat?: string;
    geoApiId?: number;
    logo?: string;
    inverseLogo?: string;
    flagIcon?: string;
    isActive?: boolean;
    language?: LanguageDto;
    languageId?: number | undefined;
    seoUrl?: string;
    defaultCountry?: boolean | undefined;
    mirrorCountryId?: number | undefined;
    generateCatalog?: boolean | undefined;
}

export class CurrencyDto implements ICurrencyDto {
    id?: number;
    currencyCode?: string;
    currencySymbol?: string;
    name?: string;
    currencyDisplayFormat?: string | undefined;

    constructor(data?: ICurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.currencyCode = _data["currencyCode"];
            this.currencySymbol = _data["currencySymbol"];
            this.name = _data["name"];
            this.currencyDisplayFormat = _data["currencyDisplayFormat"];
        }
    }

    static fromJS(data: any): CurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["currencyCode"] = this.currencyCode;
        data["currencySymbol"] = this.currencySymbol;
        data["name"] = this.name;
        data["currencyDisplayFormat"] = this.currencyDisplayFormat;
        return data;
    }
}

export interface ICurrencyDto {
    id?: number;
    currencyCode?: string;
    currencySymbol?: string;
    name?: string;
    currencyDisplayFormat?: string | undefined;
}

export enum Title {
    Mister = "mister",
    Missus = "missus",
    Miss = "miss",
    Doctor = "doctor",
    Professor = "professor",
}

export class ActiveCallDto implements IActiveCallDto {
    actionId?: number | undefined;
    startDate?: Date | undefined;

    constructor(data?: IActiveCallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionId = _data["actionId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ActiveCallDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActiveCallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionId"] = this.actionId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IActiveCallDto {
    actionId?: number | undefined;
    startDate?: Date | undefined;
}

export class ProcessChildViewModel implements IProcessChildViewModel {
    id?: number;
    userId?: number;
    contactId?: number;
    ordersImportedId?: number;
    type?: string;
    status?: string;
    outcome?: string;
    description?: string;
    created?: Date;
    colour?: string | undefined;
    ordersImported?: OrdersImportedDto;
    discardReasonProcess?: DiscardReasonProcessDto;
    university?: University;

    constructor(data?: IProcessChildViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.ordersImportedId = _data["ordersImportedId"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.outcome = _data["outcome"];
            this.description = _data["description"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.colour = _data["colour"];
            this.ordersImported = _data["ordersImported"] ? OrdersImportedDto.fromJS(_data["ordersImported"]) : <any>undefined;
            this.discardReasonProcess = _data["discardReasonProcess"] ? DiscardReasonProcessDto.fromJS(_data["discardReasonProcess"]) : <any>undefined;
            this.university = _data["university"];
        }
    }

    static fromJS(data: any): ProcessChildViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessChildViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["ordersImportedId"] = this.ordersImportedId;
        data["type"] = this.type;
        data["status"] = this.status;
        data["outcome"] = this.outcome;
        data["description"] = this.description;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["colour"] = this.colour;
        data["ordersImported"] = this.ordersImported ? this.ordersImported.toJSON() : <any>undefined;
        data["discardReasonProcess"] = this.discardReasonProcess ? this.discardReasonProcess.toJSON() : <any>undefined;
        data["university"] = this.university;
        return data;
    }
}

export interface IProcessChildViewModel {
    id?: number;
    userId?: number;
    contactId?: number;
    ordersImportedId?: number;
    type?: string;
    status?: string;
    outcome?: string;
    description?: string;
    created?: Date;
    colour?: string | undefined;
    ordersImported?: OrdersImportedDto;
    discardReasonProcess?: DiscardReasonProcessDto;
    university?: University;
}

export class OrdersImportedDto implements IOrdersImportedDto {
    id?: number;
    orderNumber?: number | undefined;
    courseId?: number | undefined;
    studentNif?: string | undefined;
    studentName?: string | undefined;
    studentSurName?: string | undefined;
    address?: string | undefined;
    birthDate?: Date | undefined;
    postsalCode?: string | undefined;
    province?: string | undefined;
    town?: string | undefined;
    country?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    orderDate?: Date | undefined;
    observations?: string | undefined;
    title?: string | undefined;
    gender?: number | undefined;
    webUrl?: string | undefined;
    discount?: string | undefined;
    amountBase?: number | undefined;
    amountFinal?: number | undefined;
    amountRegistration?: number | undefined;
    amountDeadLines?: number | undefined;
    numberDeadLines?: number | undefined;
    firstPaymentInEuro?: number | undefined;
    nationality?: string | undefined;
    occupation?: string | undefined;
    academicTitle?: string | undefined;
    university?: string | undefined;
    teleoperator?: string | undefined;
    registrationAgain?: string | undefined;
    enterprise?: string | undefined;
    initDate?: Date | undefined;
    durationCourseInDays?: number | undefined;
    area?: string | undefined;
    salesCountry?: string | undefined;
    currencyCountry?: string | undefined;
    endorsementPersonId?: number | undefined;
    studentId?: number | undefined;
    intensive?: number | undefined;
    courseCode?: string | undefined;
    study?: string | undefined;
    programType?: string | undefined;
    invoiceNumber?: number | undefined;
    teamId?: number | undefined;
    orderOriginNumber?: number | undefined;
    clientNotificationSent?: number | undefined;
    isEnrollmentUpload?: number | undefined;
    orderHeaderId?: number | undefined;
    invoiceHeaderId?: number | undefined;
    newStudentId?: number | undefined;
    newCustomerId?: number | undefined;
    processId?: number | undefined;
    actionId?: number | undefined;
    contactId?: number | undefined;
    countryId?: number | undefined;
    affiliateCode?: string;
    importedFromTlmk?: boolean;
    paymentType?: string;
    businessCountry?: CountryDto;
    currencySaleCountry?: CountryDto;
    process?: ProcessChildDto;
    action?: ActionChildDto;
    contact?: ContactChildDto;

    constructor(data?: IOrdersImportedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNumber = _data["orderNumber"];
            this.courseId = _data["courseId"];
            this.studentNif = _data["studentNif"];
            this.studentName = _data["studentName"];
            this.studentSurName = _data["studentSurName"];
            this.address = _data["address"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.postsalCode = _data["postsalCode"];
            this.province = _data["province"];
            this.town = _data["town"];
            this.country = _data["country"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.observations = _data["observations"];
            this.title = _data["title"];
            this.gender = _data["gender"];
            this.webUrl = _data["webUrl"];
            this.discount = _data["discount"];
            this.amountBase = _data["amountBase"];
            this.amountFinal = _data["amountFinal"];
            this.amountRegistration = _data["amountRegistration"];
            this.amountDeadLines = _data["amountDeadLines"];
            this.numberDeadLines = _data["numberDeadLines"];
            this.firstPaymentInEuro = _data["firstPaymentInEuro"];
            this.nationality = _data["nationality"];
            this.occupation = _data["occupation"];
            this.academicTitle = _data["academicTitle"];
            this.university = _data["university"];
            this.teleoperator = _data["teleoperator"];
            this.registrationAgain = _data["registrationAgain"];
            this.enterprise = _data["enterprise"];
            this.initDate = _data["initDate"] ? new Date(_data["initDate"].toString()) : <any>undefined;
            this.durationCourseInDays = _data["durationCourseInDays"];
            this.area = _data["area"];
            this.salesCountry = _data["salesCountry"];
            this.currencyCountry = _data["currencyCountry"];
            this.endorsementPersonId = _data["endorsementPersonId"];
            this.studentId = _data["studentId"];
            this.intensive = _data["intensive"];
            this.courseCode = _data["courseCode"];
            this.study = _data["study"];
            this.programType = _data["programType"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.teamId = _data["teamId"];
            this.orderOriginNumber = _data["orderOriginNumber"];
            this.clientNotificationSent = _data["clientNotificationSent"];
            this.isEnrollmentUpload = _data["isEnrollmentUpload"];
            this.orderHeaderId = _data["orderHeaderId"];
            this.invoiceHeaderId = _data["invoiceHeaderId"];
            this.newStudentId = _data["newStudentId"];
            this.newCustomerId = _data["newCustomerId"];
            this.processId = _data["processId"];
            this.actionId = _data["actionId"];
            this.contactId = _data["contactId"];
            this.countryId = _data["countryId"];
            this.affiliateCode = _data["affiliateCode"];
            this.importedFromTlmk = _data["importedFromTlmk"];
            this.paymentType = _data["paymentType"];
            this.businessCountry = _data["businessCountry"] ? CountryDto.fromJS(_data["businessCountry"]) : <any>undefined;
            this.currencySaleCountry = _data["currencySaleCountry"] ? CountryDto.fromJS(_data["currencySaleCountry"]) : <any>undefined;
            this.process = _data["process"] ? ProcessChildDto.fromJS(_data["process"]) : <any>undefined;
            this.action = _data["action"] ? ActionChildDto.fromJS(_data["action"]) : <any>undefined;
            this.contact = _data["contact"] ? ContactChildDto.fromJS(_data["contact"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrdersImportedDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrdersImportedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNumber"] = this.orderNumber;
        data["courseId"] = this.courseId;
        data["studentNif"] = this.studentNif;
        data["studentName"] = this.studentName;
        data["studentSurName"] = this.studentSurName;
        data["address"] = this.address;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["postsalCode"] = this.postsalCode;
        data["province"] = this.province;
        data["town"] = this.town;
        data["country"] = this.country;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["observations"] = this.observations;
        data["title"] = this.title;
        data["gender"] = this.gender;
        data["webUrl"] = this.webUrl;
        data["discount"] = this.discount;
        data["amountBase"] = this.amountBase;
        data["amountFinal"] = this.amountFinal;
        data["amountRegistration"] = this.amountRegistration;
        data["amountDeadLines"] = this.amountDeadLines;
        data["numberDeadLines"] = this.numberDeadLines;
        data["firstPaymentInEuro"] = this.firstPaymentInEuro;
        data["nationality"] = this.nationality;
        data["occupation"] = this.occupation;
        data["academicTitle"] = this.academicTitle;
        data["university"] = this.university;
        data["teleoperator"] = this.teleoperator;
        data["registrationAgain"] = this.registrationAgain;
        data["enterprise"] = this.enterprise;
        data["initDate"] = this.initDate ? this.initDate.toISOString() : <any>undefined;
        data["durationCourseInDays"] = this.durationCourseInDays;
        data["area"] = this.area;
        data["salesCountry"] = this.salesCountry;
        data["currencyCountry"] = this.currencyCountry;
        data["endorsementPersonId"] = this.endorsementPersonId;
        data["studentId"] = this.studentId;
        data["intensive"] = this.intensive;
        data["courseCode"] = this.courseCode;
        data["study"] = this.study;
        data["programType"] = this.programType;
        data["invoiceNumber"] = this.invoiceNumber;
        data["teamId"] = this.teamId;
        data["orderOriginNumber"] = this.orderOriginNumber;
        data["clientNotificationSent"] = this.clientNotificationSent;
        data["isEnrollmentUpload"] = this.isEnrollmentUpload;
        data["orderHeaderId"] = this.orderHeaderId;
        data["invoiceHeaderId"] = this.invoiceHeaderId;
        data["newStudentId"] = this.newStudentId;
        data["newCustomerId"] = this.newCustomerId;
        data["processId"] = this.processId;
        data["actionId"] = this.actionId;
        data["contactId"] = this.contactId;
        data["countryId"] = this.countryId;
        data["affiliateCode"] = this.affiliateCode;
        data["importedFromTlmk"] = this.importedFromTlmk;
        data["paymentType"] = this.paymentType;
        data["businessCountry"] = this.businessCountry ? this.businessCountry.toJSON() : <any>undefined;
        data["currencySaleCountry"] = this.currencySaleCountry ? this.currencySaleCountry.toJSON() : <any>undefined;
        data["process"] = this.process ? this.process.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrdersImportedDto {
    id?: number;
    orderNumber?: number | undefined;
    courseId?: number | undefined;
    studentNif?: string | undefined;
    studentName?: string | undefined;
    studentSurName?: string | undefined;
    address?: string | undefined;
    birthDate?: Date | undefined;
    postsalCode?: string | undefined;
    province?: string | undefined;
    town?: string | undefined;
    country?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    orderDate?: Date | undefined;
    observations?: string | undefined;
    title?: string | undefined;
    gender?: number | undefined;
    webUrl?: string | undefined;
    discount?: string | undefined;
    amountBase?: number | undefined;
    amountFinal?: number | undefined;
    amountRegistration?: number | undefined;
    amountDeadLines?: number | undefined;
    numberDeadLines?: number | undefined;
    firstPaymentInEuro?: number | undefined;
    nationality?: string | undefined;
    occupation?: string | undefined;
    academicTitle?: string | undefined;
    university?: string | undefined;
    teleoperator?: string | undefined;
    registrationAgain?: string | undefined;
    enterprise?: string | undefined;
    initDate?: Date | undefined;
    durationCourseInDays?: number | undefined;
    area?: string | undefined;
    salesCountry?: string | undefined;
    currencyCountry?: string | undefined;
    endorsementPersonId?: number | undefined;
    studentId?: number | undefined;
    intensive?: number | undefined;
    courseCode?: string | undefined;
    study?: string | undefined;
    programType?: string | undefined;
    invoiceNumber?: number | undefined;
    teamId?: number | undefined;
    orderOriginNumber?: number | undefined;
    clientNotificationSent?: number | undefined;
    isEnrollmentUpload?: number | undefined;
    orderHeaderId?: number | undefined;
    invoiceHeaderId?: number | undefined;
    newStudentId?: number | undefined;
    newCustomerId?: number | undefined;
    processId?: number | undefined;
    actionId?: number | undefined;
    contactId?: number | undefined;
    countryId?: number | undefined;
    affiliateCode?: string;
    importedFromTlmk?: boolean;
    paymentType?: string;
    businessCountry?: CountryDto;
    currencySaleCountry?: CountryDto;
    process?: ProcessChildDto;
    action?: ActionChildDto;
    contact?: ContactChildDto;
}

export class CountryDto implements ICountryDto {
    id?: number;
    name?: string;
    countryCode?: string;
    currencyId?: number;
    currency?: CurrencyDto;
    phonePrefix?: string;
    dateFormat?: string;

    constructor(data?: ICountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.countryCode = _data["countryCode"];
            this.currencyId = _data["currencyId"];
            this.currency = _data["currency"] ? CurrencyDto.fromJS(_data["currency"]) : <any>undefined;
            this.phonePrefix = _data["phonePrefix"];
            this.dateFormat = _data["dateFormat"];
        }
    }

    static fromJS(data: any): CountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["countryCode"] = this.countryCode;
        data["currencyId"] = this.currencyId;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["phonePrefix"] = this.phonePrefix;
        data["dateFormat"] = this.dateFormat;
        return data;
    }
}

export interface ICountryDto {
    id?: number;
    name?: string;
    countryCode?: string;
    currencyId?: number;
    currency?: CurrencyDto;
    phonePrefix?: string;
    dateFormat?: string;
}

export class ProcessChildDto implements IProcessChildDto {
    id?: number;
    userId?: number;
    contactId?: number;
    ordersImportedId?: number;
    type?: string;
    status?: string;
    outcome?: string;
    description?: string;
    created?: Date;
    colour?: string;

    constructor(data?: IProcessChildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.ordersImportedId = _data["ordersImportedId"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.outcome = _data["outcome"];
            this.description = _data["description"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.colour = _data["colour"];
        }
    }

    static fromJS(data: any): ProcessChildDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessChildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["ordersImportedId"] = this.ordersImportedId;
        data["type"] = this.type;
        data["status"] = this.status;
        data["outcome"] = this.outcome;
        data["description"] = this.description;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["colour"] = this.colour;
        return data;
    }
}

export interface IProcessChildDto {
    id?: number;
    userId?: number;
    contactId?: number;
    ordersImportedId?: number;
    type?: string;
    status?: string;
    outcome?: string;
    description?: string;
    created?: Date;
    colour?: string;
}

export class ContactChildDto implements IContactChildDto {
    id?: number;
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string;

    constructor(data?: IContactChildDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): ContactChildDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactChildDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface IContactChildDto {
    id?: number;
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string;
}

export class DiscardReasonProcessDto implements IDiscardReasonProcessDto {
    discardReasonId?: number;
    discardReason?: DiscardReasonDto;
    processId?: number;
    observations?: string;

    constructor(data?: IDiscardReasonProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.discardReasonId = _data["discardReasonId"];
            this.discardReason = _data["discardReason"] ? DiscardReasonDto.fromJS(_data["discardReason"]) : <any>undefined;
            this.processId = _data["processId"];
            this.observations = _data["observations"];
        }
    }

    static fromJS(data: any): DiscardReasonProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiscardReasonProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discardReasonId"] = this.discardReasonId;
        data["discardReason"] = this.discardReason ? this.discardReason.toJSON() : <any>undefined;
        data["processId"] = this.processId;
        data["observations"] = this.observations;
        return data;
    }
}

export interface IDiscardReasonProcessDto {
    discardReasonId?: number;
    discardReason?: DiscardReasonDto;
    processId?: number;
    observations?: string;
}

export class DiscardReasonDto implements IDiscardReasonDto {
    id?: number;
    name?: string;
    label?: string;
    observations?: boolean;

    constructor(data?: IDiscardReasonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
            this.observations = _data["observations"];
        }
    }

    static fromJS(data: any): DiscardReasonDto {
        data = typeof data === 'object' ? data : {};
        let result = new DiscardReasonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        data["observations"] = this.observations;
        return data;
    }
}

export interface IDiscardReasonDto {
    id?: number;
    name?: string;
    label?: string;
    observations?: boolean;
}

export enum University {
    TechUniversity = "techUniversity",
    TechFP = "techFP",
}

export class ContactPhoneDto implements IContactPhoneDto {
    id?: number;
    contactId?: number;
    phoneTypeId?: number;
    phoneType?: PhoneTypeDto;
    phone?: string;
    phonePrefix?: string;
    isDefault?: boolean;

    constructor(data?: IContactPhoneDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.phoneTypeId = _data["phoneTypeId"];
            this.phoneType = _data["phoneType"] ? PhoneTypeDto.fromJS(_data["phoneType"]) : <any>undefined;
            this.phone = _data["phone"];
            this.phonePrefix = _data["phonePrefix"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactPhoneDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhoneDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["phoneTypeId"] = this.phoneTypeId;
        data["phoneType"] = this.phoneType ? this.phoneType.toJSON() : <any>undefined;
        data["phone"] = this.phone;
        data["phonePrefix"] = this.phonePrefix;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IContactPhoneDto {
    id?: number;
    contactId?: number;
    phoneTypeId?: number;
    phoneType?: PhoneTypeDto;
    phone?: string;
    phonePrefix?: string;
    isDefault?: boolean;
}

export class PhoneTypeDto implements IPhoneTypeDto {
    id?: number;
    name?: string;
    label?: string;

    constructor(data?: IPhoneTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): PhoneTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        return data;
    }
}

export interface IPhoneTypeDto {
    id?: number;
    name?: string;
    label?: string;
}

export class ContactEmailDto implements IContactEmailDto {
    id?: number;
    contactId?: number;
    emailTypeId?: number;
    emailType?: EmailTypeDto;
    email?: string;
    isDefault?: boolean;

    constructor(data?: IContactEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.emailTypeId = _data["emailTypeId"];
            this.emailType = _data["emailType"] ? EmailTypeDto.fromJS(_data["emailType"]) : <any>undefined;
            this.email = _data["email"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["emailTypeId"] = this.emailTypeId;
        data["emailType"] = this.emailType ? this.emailType.toJSON() : <any>undefined;
        data["email"] = this.email;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IContactEmailDto {
    id?: number;
    contactId?: number;
    emailTypeId?: number;
    emailType?: EmailTypeDto;
    email?: string;
    isDefault?: boolean;
}

export class EmailTypeDto implements IEmailTypeDto {
    id?: number;
    name?: string;
    label?: string;

    constructor(data?: IEmailTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): EmailTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        return data;
    }
}

export interface IEmailTypeDto {
    id?: number;
    name?: string;
    label?: string;
}

export class ContactAddressDto implements IContactAddressDto {
    id?: number;
    contactId?: number;
    addressTypeId?: number;
    addressType?: AddressTypeDto;
    address?: string;
    city?: string;
    countryId?: number;
    country?: CountryDto;
    province?: string;
    countryCode?: string;
    postalCode?: string;
    department?: string;
    isDefault?: boolean;

    constructor(data?: IContactAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.addressTypeId = _data["addressTypeId"];
            this.addressType = _data["addressType"] ? AddressTypeDto.fromJS(_data["addressType"]) : <any>undefined;
            this.address = _data["address"];
            this.city = _data["city"];
            this.countryId = _data["countryId"];
            this.country = _data["country"] ? CountryDto.fromJS(_data["country"]) : <any>undefined;
            this.province = _data["province"];
            this.countryCode = _data["countryCode"];
            this.postalCode = _data["postalCode"];
            this.department = _data["department"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["addressTypeId"] = this.addressTypeId;
        data["addressType"] = this.addressType ? this.addressType.toJSON() : <any>undefined;
        data["address"] = this.address;
        data["city"] = this.city;
        data["countryId"] = this.countryId;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        data["province"] = this.province;
        data["countryCode"] = this.countryCode;
        data["postalCode"] = this.postalCode;
        data["department"] = this.department;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IContactAddressDto {
    id?: number;
    contactId?: number;
    addressTypeId?: number;
    addressType?: AddressTypeDto;
    address?: string;
    city?: string;
    countryId?: number;
    country?: CountryDto;
    province?: string;
    countryCode?: string;
    postalCode?: string;
    department?: string;
    isDefault?: boolean;
}

export class AddressTypeDto implements IAddressTypeDto {
    id?: number;
    name?: string;
    label?: string;

    constructor(data?: IAddressTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): AddressTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        return data;
    }
}

export interface IAddressTypeDto {
    id?: number;
    name?: string;
    label?: string;
}

export class ContactTitleDto implements IContactTitleDto {
    id?: number;
    contactId?: number;
    titleTypeId?: number;
    academicInstitution?: string;
    degree?: string;
    isDeleted?: boolean;
    titleType?: TitleTypeDto | undefined;

    constructor(data?: IContactTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.titleTypeId = _data["titleTypeId"];
            this.academicInstitution = _data["academicInstitution"];
            this.degree = _data["degree"];
            this.isDeleted = _data["isDeleted"];
            this.titleType = _data["titleType"] ? TitleTypeDto.fromJS(_data["titleType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["titleTypeId"] = this.titleTypeId;
        data["academicInstitution"] = this.academicInstitution;
        data["degree"] = this.degree;
        data["isDeleted"] = this.isDeleted;
        data["titleType"] = this.titleType ? this.titleType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IContactTitleDto {
    id?: number;
    contactId?: number;
    titleTypeId?: number;
    academicInstitution?: string;
    degree?: string;
    isDeleted?: boolean;
    titleType?: TitleTypeDto | undefined;
}

export class TitleTypeDto implements ITitleTypeDto {
    id?: number;
    name?: string;
    label?: string;

    constructor(data?: ITitleTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): TitleTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        return data;
    }
}

export interface ITitleTypeDto {
    id?: number;
    name?: string;
    label?: string;
}

export class ContactCreated implements IContactCreated {
    contactId?: number;
    processId?: number;
    correlationId?: string;

    constructor(data?: IContactCreated) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
            this.correlationId = _data["correlationId"];
        }
    }

    static fromJS(data: any): ContactCreated {
        data = typeof data === 'object' ? data : {};
        let result = new ContactCreated();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        data["correlationId"] = this.correlationId;
        return data;
    }
}

export interface IContactCreated {
    contactId?: number;
    processId?: number;
    correlationId?: string;
}

export class ContactCreateDto implements IContactCreateDto {
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    studentCIF?: string | undefined;
    fiscalCIF?: string | undefined;
    email?: string | undefined;
    legalName?: string | undefined;
    idCard?: string | undefined;
    countryCode?: string | undefined;
    currencyCode?: string | undefined;
    contactTypeId?: number;
    contactStatusId?: number;
    mainArea?: string | undefined;
    mainSpeciality?: string | undefined;
    origin?: string | undefined;
    profession?: string | undefined;
    career?: string | undefined;
    contactGenderId?: number;
    dateOfBirth?: Date | undefined;
    nationality?: string | undefined;
    company?: string | undefined;
    lastSale?: Date | undefined;
    keyRegimeCode?: string | undefined;
    customerAccount?: string | undefined;
    occupation?: string | undefined;
    centerName?: string | undefined;
    observations?: string | undefined;
    originContactId?: number | undefined;
    lastInteraction?: Date | undefined;
    nextInteraction?: Date | undefined;
    title?: Title | undefined;
    workCenter?: string | undefined;
    contactPhone?: ContactPhoneCreateDto[];
    contactEmail?: ContactEmailCreateDto[];
    contactAddress?: ContactAddressCreateDto[] | undefined;
    contactLeads?: ContactLeadCreateDto[] | undefined;
    contactTitles?: ContactTitleCreateDto[] | undefined;
    contactLanguages?: ContactLanguageCreateDto[] | undefined;
    faculties?: FacultyContactCreateDto[] | undefined;
    specialities?: SpecialityContactCreateDto[] | undefined;
    createProcess?: boolean | undefined;
    processtype?: ProcessType | undefined;
    couponOriginId?: number | undefined;
    university?: University;
    guid?: string;
    requestIp?: string | undefined;

    constructor(data?: IContactCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.firstSurName = _data["firstSurName"];
            this.secondSurName = _data["secondSurName"];
            this.studentCIF = _data["studentCIF"];
            this.fiscalCIF = _data["fiscalCIF"];
            this.email = _data["email"];
            this.legalName = _data["legalName"];
            this.idCard = _data["idCard"];
            this.countryCode = _data["countryCode"];
            this.currencyCode = _data["currencyCode"];
            this.contactTypeId = _data["contactTypeId"];
            this.contactStatusId = _data["contactStatusId"];
            this.mainArea = _data["mainArea"];
            this.mainSpeciality = _data["mainSpeciality"];
            this.origin = _data["origin"];
            this.profession = _data["profession"];
            this.career = _data["career"];
            this.contactGenderId = _data["contactGenderId"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.nationality = _data["nationality"];
            this.company = _data["company"];
            this.lastSale = _data["lastSale"] ? new Date(_data["lastSale"].toString()) : <any>undefined;
            this.keyRegimeCode = _data["keyRegimeCode"];
            this.customerAccount = _data["customerAccount"];
            this.occupation = _data["occupation"];
            this.centerName = _data["centerName"];
            this.observations = _data["observations"];
            this.originContactId = _data["originContactId"];
            this.lastInteraction = _data["lastInteraction"] ? new Date(_data["lastInteraction"].toString()) : <any>undefined;
            this.nextInteraction = _data["nextInteraction"] ? new Date(_data["nextInteraction"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.workCenter = _data["workCenter"];
            if (Array.isArray(_data["contactPhone"])) {
                this.contactPhone = [] as any;
                for (let item of _data["contactPhone"])
                    this.contactPhone!.push(ContactPhoneCreateDto.fromJS(item));
            }
            if (Array.isArray(_data["contactEmail"])) {
                this.contactEmail = [] as any;
                for (let item of _data["contactEmail"])
                    this.contactEmail!.push(ContactEmailCreateDto.fromJS(item));
            }
            if (Array.isArray(_data["contactAddress"])) {
                this.contactAddress = [] as any;
                for (let item of _data["contactAddress"])
                    this.contactAddress!.push(ContactAddressCreateDto.fromJS(item));
            }
            if (Array.isArray(_data["contactLeads"])) {
                this.contactLeads = [] as any;
                for (let item of _data["contactLeads"])
                    this.contactLeads!.push(ContactLeadCreateDto.fromJS(item));
            }
            if (Array.isArray(_data["contactTitles"])) {
                this.contactTitles = [] as any;
                for (let item of _data["contactTitles"])
                    this.contactTitles!.push(ContactTitleCreateDto.fromJS(item));
            }
            if (Array.isArray(_data["contactLanguages"])) {
                this.contactLanguages = [] as any;
                for (let item of _data["contactLanguages"])
                    this.contactLanguages!.push(ContactLanguageCreateDto.fromJS(item));
            }
            if (Array.isArray(_data["faculties"])) {
                this.faculties = [] as any;
                for (let item of _data["faculties"])
                    this.faculties!.push(FacultyContactCreateDto.fromJS(item));
            }
            if (Array.isArray(_data["specialities"])) {
                this.specialities = [] as any;
                for (let item of _data["specialities"])
                    this.specialities!.push(SpecialityContactCreateDto.fromJS(item));
            }
            this.createProcess = _data["createProcess"];
            this.processtype = _data["processtype"];
            this.couponOriginId = _data["couponOriginId"];
            this.university = _data["university"];
            this.guid = _data["guid"];
            this.requestIp = _data["requestIp"];
        }
    }

    static fromJS(data: any): ContactCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["firstSurName"] = this.firstSurName;
        data["secondSurName"] = this.secondSurName;
        data["studentCIF"] = this.studentCIF;
        data["fiscalCIF"] = this.fiscalCIF;
        data["email"] = this.email;
        data["legalName"] = this.legalName;
        data["idCard"] = this.idCard;
        data["countryCode"] = this.countryCode;
        data["currencyCode"] = this.currencyCode;
        data["contactTypeId"] = this.contactTypeId;
        data["contactStatusId"] = this.contactStatusId;
        data["mainArea"] = this.mainArea;
        data["mainSpeciality"] = this.mainSpeciality;
        data["origin"] = this.origin;
        data["profession"] = this.profession;
        data["career"] = this.career;
        data["contactGenderId"] = this.contactGenderId;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["nationality"] = this.nationality;
        data["company"] = this.company;
        data["lastSale"] = this.lastSale ? this.lastSale.toISOString() : <any>undefined;
        data["keyRegimeCode"] = this.keyRegimeCode;
        data["customerAccount"] = this.customerAccount;
        data["occupation"] = this.occupation;
        data["centerName"] = this.centerName;
        data["observations"] = this.observations;
        data["originContactId"] = this.originContactId;
        data["lastInteraction"] = this.lastInteraction ? this.lastInteraction.toISOString() : <any>undefined;
        data["nextInteraction"] = this.nextInteraction ? this.nextInteraction.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["workCenter"] = this.workCenter;
        if (Array.isArray(this.contactPhone)) {
            data["contactPhone"] = [];
            for (let item of this.contactPhone)
                data["contactPhone"].push(item.toJSON());
        }
        if (Array.isArray(this.contactEmail)) {
            data["contactEmail"] = [];
            for (let item of this.contactEmail)
                data["contactEmail"].push(item.toJSON());
        }
        if (Array.isArray(this.contactAddress)) {
            data["contactAddress"] = [];
            for (let item of this.contactAddress)
                data["contactAddress"].push(item.toJSON());
        }
        if (Array.isArray(this.contactLeads)) {
            data["contactLeads"] = [];
            for (let item of this.contactLeads)
                data["contactLeads"].push(item.toJSON());
        }
        if (Array.isArray(this.contactTitles)) {
            data["contactTitles"] = [];
            for (let item of this.contactTitles)
                data["contactTitles"].push(item.toJSON());
        }
        if (Array.isArray(this.contactLanguages)) {
            data["contactLanguages"] = [];
            for (let item of this.contactLanguages)
                data["contactLanguages"].push(item.toJSON());
        }
        if (Array.isArray(this.faculties)) {
            data["faculties"] = [];
            for (let item of this.faculties)
                data["faculties"].push(item.toJSON());
        }
        if (Array.isArray(this.specialities)) {
            data["specialities"] = [];
            for (let item of this.specialities)
                data["specialities"].push(item.toJSON());
        }
        data["createProcess"] = this.createProcess;
        data["processtype"] = this.processtype;
        data["couponOriginId"] = this.couponOriginId;
        data["university"] = this.university;
        data["guid"] = this.guid;
        data["requestIp"] = this.requestIp;
        return data;
    }
}

export interface IContactCreateDto {
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    studentCIF?: string | undefined;
    fiscalCIF?: string | undefined;
    email?: string | undefined;
    legalName?: string | undefined;
    idCard?: string | undefined;
    countryCode?: string | undefined;
    currencyCode?: string | undefined;
    contactTypeId?: number;
    contactStatusId?: number;
    mainArea?: string | undefined;
    mainSpeciality?: string | undefined;
    origin?: string | undefined;
    profession?: string | undefined;
    career?: string | undefined;
    contactGenderId?: number;
    dateOfBirth?: Date | undefined;
    nationality?: string | undefined;
    company?: string | undefined;
    lastSale?: Date | undefined;
    keyRegimeCode?: string | undefined;
    customerAccount?: string | undefined;
    occupation?: string | undefined;
    centerName?: string | undefined;
    observations?: string | undefined;
    originContactId?: number | undefined;
    lastInteraction?: Date | undefined;
    nextInteraction?: Date | undefined;
    title?: Title | undefined;
    workCenter?: string | undefined;
    contactPhone?: ContactPhoneCreateDto[];
    contactEmail?: ContactEmailCreateDto[];
    contactAddress?: ContactAddressCreateDto[] | undefined;
    contactLeads?: ContactLeadCreateDto[] | undefined;
    contactTitles?: ContactTitleCreateDto[] | undefined;
    contactLanguages?: ContactLanguageCreateDto[] | undefined;
    faculties?: FacultyContactCreateDto[] | undefined;
    specialities?: SpecialityContactCreateDto[] | undefined;
    createProcess?: boolean | undefined;
    processtype?: ProcessType | undefined;
    couponOriginId?: number | undefined;
    university?: University;
    guid?: string;
    requestIp?: string | undefined;
}

export class CreateContactCommand extends ContactCreateDto implements ICreateContactCommand {
    createProcess?: boolean | undefined;
    selectedProcessType?: ProcessType | undefined;

    constructor(data?: ICreateContactCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.createProcess = _data["createProcess"];
            this.selectedProcessType = _data["selectedProcessType"];
        }
    }

    static fromJS(data: any): CreateContactCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createProcess"] = this.createProcess;
        data["selectedProcessType"] = this.selectedProcessType;
        super.toJSON(data);
        return data;
    }
}

export interface ICreateContactCommand extends IContactCreateDto {
    createProcess?: boolean | undefined;
    selectedProcessType?: ProcessType | undefined;
}

export enum ProcessType {
    Sale = "sale",
    NonPayment = "nonpayment",
    SupportTicket = "supportticket",
    Validation = "validation",
    Apostille = "apostille",
    CampusQuery = "campusquery",
    Claims = "claims",
    FUNDAE = "fundae",
    CFG = "cfg",
    AuthorCertificate = "authorcertificate",
    NotesCertificate = "notescertificate",
    None = "none",
    Coupons = "coupons",
    Records = "records",
    Cancelled = "cancelled",
    Activations = "activations",
    Recoveries = "recoveries",
    Visits = "visits",
    CouponsPrePurchase = "couponsprepurchase",
    CouponsDossier = "couponsdossier",
    CouponsInformation = "couponsinformation",
    CouponsContact = "couponscontact",
    CouponsDiscount = "couponsdiscount",
    CouponsRematricula = "couponsrematricula",
    Records2 = "records2",
    CouponsBarn = "couponsbarn",
    Couponstrackweb = "couponstrackweb",
    Coupons2 = "coupons2",
}

export class ContactPhoneCreateDto implements IContactPhoneCreateDto {
    contactId?: number;
    phoneTypeId?: number;
    phone?: string;
    phonePrefix?: string;
    isDefault?: boolean;

    constructor(data?: IContactPhoneCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.phoneTypeId = _data["phoneTypeId"];
            this.phone = _data["phone"];
            this.phonePrefix = _data["phonePrefix"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactPhoneCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhoneCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["phoneTypeId"] = this.phoneTypeId;
        data["phone"] = this.phone;
        data["phonePrefix"] = this.phonePrefix;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IContactPhoneCreateDto {
    contactId?: number;
    phoneTypeId?: number;
    phone?: string;
    phonePrefix?: string;
    isDefault?: boolean;
}

export class ContactEmailCreateDto implements IContactEmailCreateDto {
    contactId?: number;
    emailTypeId?: number;
    email?: string;
    isDefault?: boolean;

    constructor(data?: IContactEmailCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.emailTypeId = _data["emailTypeId"];
            this.email = _data["email"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactEmailCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmailCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["emailTypeId"] = this.emailTypeId;
        data["email"] = this.email;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IContactEmailCreateDto {
    contactId?: number;
    emailTypeId?: number;
    email?: string;
    isDefault?: boolean;
}

export class ContactAddressCreateDto implements IContactAddressCreateDto {
    contactId?: number;
    addressTypeId?: number;
    address?: string;
    city?: string;
    countryCode?: string;
    countryId?: number | undefined;
    province?: string;
    postalCode?: string;
    department?: string;
    isDefault?: boolean;

    constructor(data?: IContactAddressCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.addressTypeId = _data["addressTypeId"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.countryCode = _data["countryCode"];
            this.countryId = _data["countryId"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.department = _data["department"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactAddressCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAddressCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["addressTypeId"] = this.addressTypeId;
        data["address"] = this.address;
        data["city"] = this.city;
        data["countryCode"] = this.countryCode;
        data["countryId"] = this.countryId;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["department"] = this.department;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IContactAddressCreateDto {
    contactId?: number;
    addressTypeId?: number;
    address?: string;
    city?: string;
    countryCode?: string;
    countryId?: number | undefined;
    province?: string;
    postalCode?: string;
    department?: string;
    isDefault?: boolean;
}

export class ContactLeadCreateDto implements IContactLeadCreateDto {
    courseId?: number | undefined;
    courseDataId?: number | undefined;
    contactId?: number;
    url?: string | undefined;
    countryCode?: string | undefined;
    courseCountryId?: number;
    price?: number | undefined;
    finalPrice?: number | undefined;
    currency?: string | undefined;
    courseTypeName?: string;
    facultyName?: string;
    areaUrl?: string | undefined;
    facultyId?: number | undefined;
    discount?: number | undefined;
    enrollmentPercentage?: number | undefined;
    fees?: number | undefined;
    isFavourite?: boolean;
    emailSent?: boolean;
    messageSent?: boolean;
    created?: Date | undefined;
    convocationDate?: Date | undefined;
    types?: ContactLeadType[];
    processId?: number;
    courseTypeBaseCode?: string;
    startDateCourse?: Date | undefined;
    finishDateCourse?: Date | undefined;
    languageCode?: string;
    languageId?: number | undefined;
    university?: University;
    title?: string | undefined;
    courseCode?: string;

    constructor(data?: IContactLeadCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.courseId = _data["courseId"];
            this.courseDataId = _data["courseDataId"];
            this.contactId = _data["contactId"];
            this.url = _data["url"];
            this.countryCode = _data["countryCode"];
            this.courseCountryId = _data["courseCountryId"];
            this.price = _data["price"];
            this.finalPrice = _data["finalPrice"];
            this.currency = _data["currency"];
            this.courseTypeName = _data["courseTypeName"];
            this.facultyName = _data["facultyName"];
            this.areaUrl = _data["areaUrl"];
            this.facultyId = _data["facultyId"];
            this.discount = _data["discount"];
            this.enrollmentPercentage = _data["enrollmentPercentage"];
            this.fees = _data["fees"];
            this.isFavourite = _data["isFavourite"];
            this.emailSent = _data["emailSent"];
            this.messageSent = _data["messageSent"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.convocationDate = _data["convocationDate"] ? new Date(_data["convocationDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(item);
            }
            this.processId = _data["processId"];
            this.courseTypeBaseCode = _data["courseTypeBaseCode"];
            this.startDateCourse = _data["startDateCourse"] ? new Date(_data["startDateCourse"].toString()) : <any>undefined;
            this.finishDateCourse = _data["finishDateCourse"] ? new Date(_data["finishDateCourse"].toString()) : <any>undefined;
            this.languageCode = _data["languageCode"];
            this.languageId = _data["languageId"];
            this.university = _data["university"];
            this.title = _data["title"];
            this.courseCode = _data["courseCode"];
        }
    }

    static fromJS(data: any): ContactLeadCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLeadCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["courseId"] = this.courseId;
        data["courseDataId"] = this.courseDataId;
        data["contactId"] = this.contactId;
        data["url"] = this.url;
        data["countryCode"] = this.countryCode;
        data["courseCountryId"] = this.courseCountryId;
        data["price"] = this.price;
        data["finalPrice"] = this.finalPrice;
        data["currency"] = this.currency;
        data["courseTypeName"] = this.courseTypeName;
        data["facultyName"] = this.facultyName;
        data["areaUrl"] = this.areaUrl;
        data["facultyId"] = this.facultyId;
        data["discount"] = this.discount;
        data["enrollmentPercentage"] = this.enrollmentPercentage;
        data["fees"] = this.fees;
        data["isFavourite"] = this.isFavourite;
        data["emailSent"] = this.emailSent;
        data["messageSent"] = this.messageSent;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["convocationDate"] = this.convocationDate ? this.convocationDate.toISOString() : <any>undefined;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["processId"] = this.processId;
        data["courseTypeBaseCode"] = this.courseTypeBaseCode;
        data["startDateCourse"] = this.startDateCourse ? this.startDateCourse.toISOString() : <any>undefined;
        data["finishDateCourse"] = this.finishDateCourse ? this.finishDateCourse.toISOString() : <any>undefined;
        data["languageCode"] = this.languageCode;
        data["languageId"] = this.languageId;
        data["university"] = this.university;
        data["title"] = this.title;
        data["courseCode"] = this.courseCode;
        return data;
    }
}

export interface IContactLeadCreateDto {
    courseId?: number | undefined;
    courseDataId?: number | undefined;
    contactId?: number;
    url?: string | undefined;
    countryCode?: string | undefined;
    courseCountryId?: number;
    price?: number | undefined;
    finalPrice?: number | undefined;
    currency?: string | undefined;
    courseTypeName?: string;
    facultyName?: string;
    areaUrl?: string | undefined;
    facultyId?: number | undefined;
    discount?: number | undefined;
    enrollmentPercentage?: number | undefined;
    fees?: number | undefined;
    isFavourite?: boolean;
    emailSent?: boolean;
    messageSent?: boolean;
    created?: Date | undefined;
    convocationDate?: Date | undefined;
    types?: ContactLeadType[];
    processId?: number;
    courseTypeBaseCode?: string;
    startDateCourse?: Date | undefined;
    finishDateCourse?: Date | undefined;
    languageCode?: string;
    languageId?: number | undefined;
    university?: University;
    title?: string | undefined;
    courseCode?: string;
}

export enum ContactLeadType {
    Recommended = "recommended",
    Contact = "contact",
    Demo = "demo",
    Dossier = "dossier",
    PreEnrolment = "preEnrolment",
    PromotionalCode = "promotionalCode",
    Visit = "visit",
    Enquiry = "enquiry",
}

export class ContactTitleCreateDto implements IContactTitleCreateDto {
    contactId?: number;
    titleTypeId?: number;
    academicInstitution?: string;
    degree?: string;
    isDeleted?: boolean;

    constructor(data?: IContactTitleCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.titleTypeId = _data["titleTypeId"];
            this.academicInstitution = _data["academicInstitution"];
            this.degree = _data["degree"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): ContactTitleCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTitleCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["titleTypeId"] = this.titleTypeId;
        data["academicInstitution"] = this.academicInstitution;
        data["degree"] = this.degree;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IContactTitleCreateDto {
    contactId?: number;
    titleTypeId?: number;
    academicInstitution?: string;
    degree?: string;
    isDeleted?: boolean;
}

export class ContactLanguageCreateDto implements IContactLanguageCreateDto {
    contactId?: number;
    languageId?: number;
    isDefault?: boolean;

    constructor(data?: IContactLanguageCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.languageId = _data["languageId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactLanguageCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLanguageCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["languageId"] = this.languageId;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IContactLanguageCreateDto {
    contactId?: number;
    languageId?: number;
    isDefault?: boolean;
}

export class FacultyContactCreateDto implements IFacultyContactCreateDto {
    facultyId?: number | undefined;

    constructor(data?: IFacultyContactCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facultyId = _data["facultyId"];
        }
    }

    static fromJS(data: any): FacultyContactCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new FacultyContactCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facultyId"] = this.facultyId;
        return data;
    }
}

export interface IFacultyContactCreateDto {
    facultyId?: number | undefined;
}

export class SpecialityContactCreateDto implements ISpecialityContactCreateDto {
    specialityId?: number;

    constructor(data?: ISpecialityContactCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.specialityId = _data["specialityId"];
        }
    }

    static fromJS(data: any): SpecialityContactCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialityContactCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specialityId"] = this.specialityId;
        return data;
    }
}

export interface ISpecialityContactCreateDto {
    specialityId?: number;
}

export class ContactUpdateDto implements IContactUpdateDto {
    id?: number;
    name?: string | undefined;
    firstSurName?: string | undefined;
    secondSurName?: string | undefined;
    studentCIF?: string | undefined;
    fiscalCIF?: string | undefined;
    legalName?: string | undefined;
    idCard?: string | undefined;
    countryCode?: string | undefined;
    currencyCode?: string | undefined;
    contactTypeId?: number | undefined;
    contactStatusId?: number | undefined;
    profession?: string | undefined;
    contactGenderId?: number | undefined;
    dateOfBirth?: Date | undefined;
    nationality?: string | undefined;
    title?: Title | undefined;
    workCenter?: string | undefined;
    dontWantCalls?: boolean | undefined;
    guid?: string | undefined;
    contactPhone?: ContactPhoneUpdateDto[] | undefined;
    contactEmail?: ContactEmailUpdateDto[] | undefined;
    contactAddress?: ContactAddressUpdateDto[] | undefined;
    contactTitles?: ContactTitleUpdateDto[] | undefined;
    contactLanguages?: ContactLanguageUpdateDto[] | undefined;
    faculties?: FacultyDto[] | undefined;
    specialities?: SpecialityDto[] | undefined;
    couponOriginId?: number | undefined;
    requestIp?: string | undefined;

    constructor(data?: IContactUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.firstSurName = _data["firstSurName"];
            this.secondSurName = _data["secondSurName"];
            this.studentCIF = _data["studentCIF"];
            this.fiscalCIF = _data["fiscalCIF"];
            this.legalName = _data["legalName"];
            this.idCard = _data["idCard"];
            this.countryCode = _data["countryCode"];
            this.currencyCode = _data["currencyCode"];
            this.contactTypeId = _data["contactTypeId"];
            this.contactStatusId = _data["contactStatusId"];
            this.profession = _data["profession"];
            this.contactGenderId = _data["contactGenderId"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.nationality = _data["nationality"];
            this.title = _data["title"];
            this.workCenter = _data["workCenter"];
            this.dontWantCalls = _data["dontWantCalls"];
            this.guid = _data["guid"];
            if (Array.isArray(_data["contactPhone"])) {
                this.contactPhone = [] as any;
                for (let item of _data["contactPhone"])
                    this.contactPhone!.push(ContactPhoneUpdateDto.fromJS(item));
            }
            if (Array.isArray(_data["contactEmail"])) {
                this.contactEmail = [] as any;
                for (let item of _data["contactEmail"])
                    this.contactEmail!.push(ContactEmailUpdateDto.fromJS(item));
            }
            if (Array.isArray(_data["contactAddress"])) {
                this.contactAddress = [] as any;
                for (let item of _data["contactAddress"])
                    this.contactAddress!.push(ContactAddressUpdateDto.fromJS(item));
            }
            if (Array.isArray(_data["contactTitles"])) {
                this.contactTitles = [] as any;
                for (let item of _data["contactTitles"])
                    this.contactTitles!.push(ContactTitleUpdateDto.fromJS(item));
            }
            if (Array.isArray(_data["contactLanguages"])) {
                this.contactLanguages = [] as any;
                for (let item of _data["contactLanguages"])
                    this.contactLanguages!.push(ContactLanguageUpdateDto.fromJS(item));
            }
            if (Array.isArray(_data["faculties"])) {
                this.faculties = [] as any;
                for (let item of _data["faculties"])
                    this.faculties!.push(FacultyDto.fromJS(item));
            }
            if (Array.isArray(_data["specialities"])) {
                this.specialities = [] as any;
                for (let item of _data["specialities"])
                    this.specialities!.push(SpecialityDto.fromJS(item));
            }
            this.couponOriginId = _data["couponOriginId"];
            this.requestIp = _data["requestIp"];
        }
    }

    static fromJS(data: any): ContactUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["firstSurName"] = this.firstSurName;
        data["secondSurName"] = this.secondSurName;
        data["studentCIF"] = this.studentCIF;
        data["fiscalCIF"] = this.fiscalCIF;
        data["legalName"] = this.legalName;
        data["idCard"] = this.idCard;
        data["countryCode"] = this.countryCode;
        data["currencyCode"] = this.currencyCode;
        data["contactTypeId"] = this.contactTypeId;
        data["contactStatusId"] = this.contactStatusId;
        data["profession"] = this.profession;
        data["contactGenderId"] = this.contactGenderId;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["nationality"] = this.nationality;
        data["title"] = this.title;
        data["workCenter"] = this.workCenter;
        data["dontWantCalls"] = this.dontWantCalls;
        data["guid"] = this.guid;
        if (Array.isArray(this.contactPhone)) {
            data["contactPhone"] = [];
            for (let item of this.contactPhone)
                data["contactPhone"].push(item.toJSON());
        }
        if (Array.isArray(this.contactEmail)) {
            data["contactEmail"] = [];
            for (let item of this.contactEmail)
                data["contactEmail"].push(item.toJSON());
        }
        if (Array.isArray(this.contactAddress)) {
            data["contactAddress"] = [];
            for (let item of this.contactAddress)
                data["contactAddress"].push(item.toJSON());
        }
        if (Array.isArray(this.contactTitles)) {
            data["contactTitles"] = [];
            for (let item of this.contactTitles)
                data["contactTitles"].push(item.toJSON());
        }
        if (Array.isArray(this.contactLanguages)) {
            data["contactLanguages"] = [];
            for (let item of this.contactLanguages)
                data["contactLanguages"].push(item.toJSON());
        }
        if (Array.isArray(this.faculties)) {
            data["faculties"] = [];
            for (let item of this.faculties)
                data["faculties"].push(item.toJSON());
        }
        if (Array.isArray(this.specialities)) {
            data["specialities"] = [];
            for (let item of this.specialities)
                data["specialities"].push(item.toJSON());
        }
        data["couponOriginId"] = this.couponOriginId;
        data["requestIp"] = this.requestIp;
        return data;
    }
}

export interface IContactUpdateDto {
    id?: number;
    name?: string | undefined;
    firstSurName?: string | undefined;
    secondSurName?: string | undefined;
    studentCIF?: string | undefined;
    fiscalCIF?: string | undefined;
    legalName?: string | undefined;
    idCard?: string | undefined;
    countryCode?: string | undefined;
    currencyCode?: string | undefined;
    contactTypeId?: number | undefined;
    contactStatusId?: number | undefined;
    profession?: string | undefined;
    contactGenderId?: number | undefined;
    dateOfBirth?: Date | undefined;
    nationality?: string | undefined;
    title?: Title | undefined;
    workCenter?: string | undefined;
    dontWantCalls?: boolean | undefined;
    guid?: string | undefined;
    contactPhone?: ContactPhoneUpdateDto[] | undefined;
    contactEmail?: ContactEmailUpdateDto[] | undefined;
    contactAddress?: ContactAddressUpdateDto[] | undefined;
    contactTitles?: ContactTitleUpdateDto[] | undefined;
    contactLanguages?: ContactLanguageUpdateDto[] | undefined;
    faculties?: FacultyDto[] | undefined;
    specialities?: SpecialityDto[] | undefined;
    couponOriginId?: number | undefined;
    requestIp?: string | undefined;
}

export class UpdateContactCommand extends ContactUpdateDto implements IUpdateContactCommand {

    constructor(data?: IUpdateContactCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpdateContactCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateContactCommand extends IContactUpdateDto {
}

export class ContactPhoneUpdateDto implements IContactPhoneUpdateDto {
    id?: number | undefined;
    contactId?: number;
    phoneTypeId?: number;
    phone?: string;
    phonePrefix?: string;
    isDeleted?: boolean;
    isDefault?: boolean;

    constructor(data?: IContactPhoneUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.phoneTypeId = _data["phoneTypeId"];
            this.phone = _data["phone"];
            this.phonePrefix = _data["phonePrefix"];
            this.isDeleted = _data["isDeleted"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactPhoneUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPhoneUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["phoneTypeId"] = this.phoneTypeId;
        data["phone"] = this.phone;
        data["phonePrefix"] = this.phonePrefix;
        data["isDeleted"] = this.isDeleted;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IContactPhoneUpdateDto {
    id?: number | undefined;
    contactId?: number;
    phoneTypeId?: number;
    phone?: string;
    phonePrefix?: string;
    isDeleted?: boolean;
    isDefault?: boolean;
}

export class ContactEmailUpdateDto implements IContactEmailUpdateDto {
    id?: number | undefined;
    contactId?: number;
    emailTypeId?: number;
    email?: string;
    isDeleted?: boolean;
    isDefault?: boolean;

    constructor(data?: IContactEmailUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.emailTypeId = _data["emailTypeId"];
            this.email = _data["email"];
            this.isDeleted = _data["isDeleted"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactEmailUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmailUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["emailTypeId"] = this.emailTypeId;
        data["email"] = this.email;
        data["isDeleted"] = this.isDeleted;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IContactEmailUpdateDto {
    id?: number | undefined;
    contactId?: number;
    emailTypeId?: number;
    email?: string;
    isDeleted?: boolean;
    isDefault?: boolean;
}

export class ContactAddressUpdateDto implements IContactAddressUpdateDto {
    id?: number | undefined;
    contactId?: number;
    addressTypeId?: number;
    address?: string;
    city?: string;
    countryCode?: string;
    province?: string;
    postalCode?: string;
    department?: string;
    isDeleted?: boolean;
    isDefault?: boolean;

    constructor(data?: IContactAddressUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.addressTypeId = _data["addressTypeId"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.countryCode = _data["countryCode"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.department = _data["department"];
            this.isDeleted = _data["isDeleted"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): ContactAddressUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAddressUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["addressTypeId"] = this.addressTypeId;
        data["address"] = this.address;
        data["city"] = this.city;
        data["countryCode"] = this.countryCode;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["department"] = this.department;
        data["isDeleted"] = this.isDeleted;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IContactAddressUpdateDto {
    id?: number | undefined;
    contactId?: number;
    addressTypeId?: number;
    address?: string;
    city?: string;
    countryCode?: string;
    province?: string;
    postalCode?: string;
    department?: string;
    isDeleted?: boolean;
    isDefault?: boolean;
}

export class ContactTitleUpdateDto implements IContactTitleUpdateDto {
    id?: number | undefined;
    contactId?: number;
    titleTypeId?: number;
    academicInstitution?: string;
    degree?: string;
    isDeleted?: boolean;

    constructor(data?: IContactTitleUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.titleTypeId = _data["titleTypeId"];
            this.academicInstitution = _data["academicInstitution"];
            this.degree = _data["degree"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): ContactTitleUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTitleUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["titleTypeId"] = this.titleTypeId;
        data["academicInstitution"] = this.academicInstitution;
        data["degree"] = this.degree;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IContactTitleUpdateDto {
    id?: number | undefined;
    contactId?: number;
    titleTypeId?: number;
    academicInstitution?: string;
    degree?: string;
    isDeleted?: boolean;
}

export class ContactLanguageUpdateDto implements IContactLanguageUpdateDto {
    id?: number | undefined;
    contactId?: number;
    languageId?: number;
    isDefault?: boolean;
    isDeleted?: boolean;

    constructor(data?: IContactLanguageUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.languageId = _data["languageId"];
            this.isDefault = _data["isDefault"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): ContactLanguageUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLanguageUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["languageId"] = this.languageId;
        data["isDefault"] = this.isDefault;
        data["isDeleted"] = this.isDeleted;
        return data;
    }
}

export interface IContactLanguageUpdateDto {
    id?: number | undefined;
    contactId?: number;
    languageId?: number;
    isDefault?: boolean;
    isDeleted?: boolean;
}

export class AddContactToBlacklistCommand implements IAddContactToBlacklistCommand {
    contactId?: number;
    newContactStatusId?: number;
    newStatusReason?: string | undefined;
    newStatusObservations?: string | undefined;
    processId?: number;

    constructor(data?: IAddContactToBlacklistCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.newContactStatusId = _data["newContactStatusId"];
            this.newStatusReason = _data["newStatusReason"];
            this.newStatusObservations = _data["newStatusObservations"];
            this.processId = _data["processId"];
        }
    }

    static fromJS(data: any): AddContactToBlacklistCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddContactToBlacklistCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["newContactStatusId"] = this.newContactStatusId;
        data["newStatusReason"] = this.newStatusReason;
        data["newStatusObservations"] = this.newStatusObservations;
        data["processId"] = this.processId;
        return data;
    }
}

export interface IAddContactToBlacklistCommand {
    contactId?: number;
    newContactStatusId?: number;
    newStatusReason?: string | undefined;
    newStatusObservations?: string | undefined;
    processId?: number;
}

export class AddCourseToFavouriteCommand implements IAddCourseToFavouriteCommand {
    contactLeadId?: number;
    processId?: number;
    courseFavourite?: boolean;

    constructor(data?: IAddCourseToFavouriteCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactLeadId = _data["contactLeadId"];
            this.processId = _data["processId"];
            this.courseFavourite = _data["courseFavourite"];
        }
    }

    static fromJS(data: any): AddCourseToFavouriteCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddCourseToFavouriteCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactLeadId"] = this.contactLeadId;
        data["processId"] = this.processId;
        data["courseFavourite"] = this.courseFavourite;
        return data;
    }
}

export interface IAddCourseToFavouriteCommand {
    contactLeadId?: number;
    processId?: number;
    courseFavourite?: boolean;
}

export class ContactInfoDto implements IContactInfoDto {
    id?: number;
    processId?: number;
    canCreateProcess?: boolean;
    isBlackList?: boolean;
    replaceable?: boolean | undefined;

    constructor(data?: IContactInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.processId = _data["processId"];
            this.canCreateProcess = _data["canCreateProcess"];
            this.isBlackList = _data["isBlackList"];
            this.replaceable = _data["replaceable"];
        }
    }

    static fromJS(data: any): ContactInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["processId"] = this.processId;
        data["canCreateProcess"] = this.canCreateProcess;
        data["isBlackList"] = this.isBlackList;
        data["replaceable"] = this.replaceable;
        return data;
    }
}

export interface IContactInfoDto {
    id?: number;
    processId?: number;
    canCreateProcess?: boolean;
    isBlackList?: boolean;
    replaceable?: boolean | undefined;
}

export class CreateContactLeadCommand extends ContactLeadCreateDto implements ICreateContactLeadCommand {

    constructor(data?: ICreateContactLeadCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateContactLeadCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactLeadCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateContactLeadCommand extends IContactLeadCreateDto {
}

export class ContactLeadDto implements IContactLeadDto {
    id?: number;
    countryCode?: string;
    userCountryCode?: string;
    currencyCountryCode?: string;
    areaUrl?: string;
    title?: string;
    courseId?: number | undefined;
    course?: CourseDto;
    courseDataId?: number | undefined;
    courseData?: CourseDataDto;
    originalCourseId?: number | undefined;
    enquiry?: string;
    contactId?: number | undefined;
    contact?: ContactDto;
    url?: string;
    accessUrl?: string;
    price?: number | undefined;
    currency?: string;
    currencyDisplayFormat?: string;
    currencySymbol?: string;
    created?: Date;
    isFavourite?: boolean;
    emailSent?: boolean;
    messageSent?: boolean;
    specialities?: SpecialityDto[];
    faculty?: FacultyDto;
    idContactTypes?: string;
    types?: ContactLeadType[];
    courseCountryId?: number;
    finalPrice?: number | undefined;
    discount?: number | undefined;
    enrollmentPercentage?: number | undefined;
    fees?: number | undefined;
    courseTypeName?: string;
    contactTrackerDate?: Date | undefined;
    convocationDate?: Date | undefined;
    courseTypeBaseCode?: string;
    courseTypeBase?: CourseTypeBaseDto;
    startDateCourse?: Date | undefined;
    finishDateCourse?: Date | undefined;
    languageId?: number | undefined;
    languageCode?: string | undefined;
    couponOriginId?: number | undefined;
    couponOrigin?: CouponsOriginsDto;
    university?: University;
    courseCode?: string;

    constructor(data?: IContactLeadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.countryCode = _data["countryCode"];
            this.userCountryCode = _data["userCountryCode"];
            this.currencyCountryCode = _data["currencyCountryCode"];
            this.areaUrl = _data["areaUrl"];
            this.title = _data["title"];
            this.courseId = _data["courseId"];
            this.course = _data["course"] ? CourseDto.fromJS(_data["course"]) : <any>undefined;
            this.courseDataId = _data["courseDataId"];
            this.courseData = _data["courseData"] ? CourseDataDto.fromJS(_data["courseData"]) : <any>undefined;
            this.originalCourseId = _data["originalCourseId"];
            this.enquiry = _data["enquiry"];
            this.contactId = _data["contactId"];
            this.contact = _data["contact"] ? ContactDto.fromJS(_data["contact"]) : <any>undefined;
            this.url = _data["url"];
            this.accessUrl = _data["accessUrl"];
            this.price = _data["price"];
            this.currency = _data["currency"];
            this.currencyDisplayFormat = _data["currencyDisplayFormat"];
            this.currencySymbol = _data["currencySymbol"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.isFavourite = _data["isFavourite"];
            this.emailSent = _data["emailSent"];
            this.messageSent = _data["messageSent"];
            if (Array.isArray(_data["specialities"])) {
                this.specialities = [] as any;
                for (let item of _data["specialities"])
                    this.specialities!.push(SpecialityDto.fromJS(item));
            }
            this.faculty = _data["faculty"] ? FacultyDto.fromJS(_data["faculty"]) : <any>undefined;
            this.idContactTypes = _data["idContactTypes"];
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(item);
            }
            this.courseCountryId = _data["courseCountryId"];
            this.finalPrice = _data["finalPrice"];
            this.discount = _data["discount"];
            this.enrollmentPercentage = _data["enrollmentPercentage"];
            this.fees = _data["fees"];
            this.courseTypeName = _data["courseTypeName"];
            this.contactTrackerDate = _data["contactTrackerDate"] ? new Date(_data["contactTrackerDate"].toString()) : <any>undefined;
            this.convocationDate = _data["convocationDate"] ? new Date(_data["convocationDate"].toString()) : <any>undefined;
            this.courseTypeBaseCode = _data["courseTypeBaseCode"];
            this.courseTypeBase = _data["courseTypeBase"] ? CourseTypeBaseDto.fromJS(_data["courseTypeBase"]) : <any>undefined;
            this.startDateCourse = _data["startDateCourse"] ? new Date(_data["startDateCourse"].toString()) : <any>undefined;
            this.finishDateCourse = _data["finishDateCourse"] ? new Date(_data["finishDateCourse"].toString()) : <any>undefined;
            this.languageId = _data["languageId"];
            this.languageCode = _data["languageCode"];
            this.couponOriginId = _data["couponOriginId"];
            this.couponOrigin = _data["couponOrigin"] ? CouponsOriginsDto.fromJS(_data["couponOrigin"]) : <any>undefined;
            this.university = _data["university"];
            this.courseCode = _data["courseCode"];
        }
    }

    static fromJS(data: any): ContactLeadDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLeadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryCode"] = this.countryCode;
        data["userCountryCode"] = this.userCountryCode;
        data["currencyCountryCode"] = this.currencyCountryCode;
        data["areaUrl"] = this.areaUrl;
        data["title"] = this.title;
        data["courseId"] = this.courseId;
        data["course"] = this.course ? this.course.toJSON() : <any>undefined;
        data["courseDataId"] = this.courseDataId;
        data["courseData"] = this.courseData ? this.courseData.toJSON() : <any>undefined;
        data["originalCourseId"] = this.originalCourseId;
        data["enquiry"] = this.enquiry;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["url"] = this.url;
        data["accessUrl"] = this.accessUrl;
        data["price"] = this.price;
        data["currency"] = this.currency;
        data["currencyDisplayFormat"] = this.currencyDisplayFormat;
        data["currencySymbol"] = this.currencySymbol;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["isFavourite"] = this.isFavourite;
        data["emailSent"] = this.emailSent;
        data["messageSent"] = this.messageSent;
        if (Array.isArray(this.specialities)) {
            data["specialities"] = [];
            for (let item of this.specialities)
                data["specialities"].push(item.toJSON());
        }
        data["faculty"] = this.faculty ? this.faculty.toJSON() : <any>undefined;
        data["idContactTypes"] = this.idContactTypes;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        data["courseCountryId"] = this.courseCountryId;
        data["finalPrice"] = this.finalPrice;
        data["discount"] = this.discount;
        data["enrollmentPercentage"] = this.enrollmentPercentage;
        data["fees"] = this.fees;
        data["courseTypeName"] = this.courseTypeName;
        data["contactTrackerDate"] = this.contactTrackerDate ? this.contactTrackerDate.toISOString() : <any>undefined;
        data["convocationDate"] = this.convocationDate ? this.convocationDate.toISOString() : <any>undefined;
        data["courseTypeBaseCode"] = this.courseTypeBaseCode;
        data["courseTypeBase"] = this.courseTypeBase ? this.courseTypeBase.toJSON() : <any>undefined;
        data["startDateCourse"] = this.startDateCourse ? this.startDateCourse.toISOString() : <any>undefined;
        data["finishDateCourse"] = this.finishDateCourse ? this.finishDateCourse.toISOString() : <any>undefined;
        data["languageId"] = this.languageId;
        data["languageCode"] = this.languageCode;
        data["couponOriginId"] = this.couponOriginId;
        data["couponOrigin"] = this.couponOrigin ? this.couponOrigin.toJSON() : <any>undefined;
        data["university"] = this.university;
        data["courseCode"] = this.courseCode;
        return data;
    }
}

export interface IContactLeadDto {
    id?: number;
    countryCode?: string;
    userCountryCode?: string;
    currencyCountryCode?: string;
    areaUrl?: string;
    title?: string;
    courseId?: number | undefined;
    course?: CourseDto;
    courseDataId?: number | undefined;
    courseData?: CourseDataDto;
    originalCourseId?: number | undefined;
    enquiry?: string;
    contactId?: number | undefined;
    contact?: ContactDto;
    url?: string;
    accessUrl?: string;
    price?: number | undefined;
    currency?: string;
    currencyDisplayFormat?: string;
    currencySymbol?: string;
    created?: Date;
    isFavourite?: boolean;
    emailSent?: boolean;
    messageSent?: boolean;
    specialities?: SpecialityDto[];
    faculty?: FacultyDto;
    idContactTypes?: string;
    types?: ContactLeadType[];
    courseCountryId?: number;
    finalPrice?: number | undefined;
    discount?: number | undefined;
    enrollmentPercentage?: number | undefined;
    fees?: number | undefined;
    courseTypeName?: string;
    contactTrackerDate?: Date | undefined;
    convocationDate?: Date | undefined;
    courseTypeBaseCode?: string;
    courseTypeBase?: CourseTypeBaseDto;
    startDateCourse?: Date | undefined;
    finishDateCourse?: Date | undefined;
    languageId?: number | undefined;
    languageCode?: string | undefined;
    couponOriginId?: number | undefined;
    couponOrigin?: CouponsOriginsDto;
    university?: University;
    courseCode?: string;
}

export class CourseDto implements ICourseDto {
    id?: number;
    originalCourseId?: number;
    courseTypeId?: number | undefined;
    courseType?: CourseTypeDto;
    title?: string;
    code?: string;
    guarantor?: GuarantorDto;
    courseFaculties?: CourseFacultyDto[];
    courseSpecialities?: CourseSpecialityDto[];

    constructor(data?: ICourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.originalCourseId = _data["originalCourseId"];
            this.courseTypeId = _data["courseTypeId"];
            this.courseType = _data["courseType"] ? CourseTypeDto.fromJS(_data["courseType"]) : <any>undefined;
            this.title = _data["title"];
            this.code = _data["code"];
            this.guarantor = _data["guarantor"] ? GuarantorDto.fromJS(_data["guarantor"]) : <any>undefined;
            if (Array.isArray(_data["courseFaculties"])) {
                this.courseFaculties = [] as any;
                for (let item of _data["courseFaculties"])
                    this.courseFaculties!.push(CourseFacultyDto.fromJS(item));
            }
            if (Array.isArray(_data["courseSpecialities"])) {
                this.courseSpecialities = [] as any;
                for (let item of _data["courseSpecialities"])
                    this.courseSpecialities!.push(CourseSpecialityDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["originalCourseId"] = this.originalCourseId;
        data["courseTypeId"] = this.courseTypeId;
        data["courseType"] = this.courseType ? this.courseType.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["code"] = this.code;
        data["guarantor"] = this.guarantor ? this.guarantor.toJSON() : <any>undefined;
        if (Array.isArray(this.courseFaculties)) {
            data["courseFaculties"] = [];
            for (let item of this.courseFaculties)
                data["courseFaculties"].push(item.toJSON());
        }
        if (Array.isArray(this.courseSpecialities)) {
            data["courseSpecialities"] = [];
            for (let item of this.courseSpecialities)
                data["courseSpecialities"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICourseDto {
    id?: number;
    originalCourseId?: number;
    courseTypeId?: number | undefined;
    courseType?: CourseTypeDto;
    title?: string;
    code?: string;
    guarantor?: GuarantorDto;
    courseFaculties?: CourseFacultyDto[];
    courseSpecialities?: CourseSpecialityDto[];
}

export class CourseTypeDto implements ICourseTypeDto {
    id?: number;
    name?: string;
    label?: string;

    constructor(data?: ICourseTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): CourseTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["label"] = this.label;
        return data;
    }
}

export interface ICourseTypeDto {
    id?: number;
    name?: string;
    label?: string;
}

export class GuarantorDto implements IGuarantorDto {
    originalGuarantorId?: number;
    name?: string;
    shortName?: string;
    longName?: string;
    label?: string;

    constructor(data?: IGuarantorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originalGuarantorId = _data["originalGuarantorId"];
            this.name = _data["name"];
            this.shortName = _data["shortName"];
            this.longName = _data["longName"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): GuarantorDto {
        data = typeof data === 'object' ? data : {};
        let result = new GuarantorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originalGuarantorId"] = this.originalGuarantorId;
        data["name"] = this.name;
        data["shortName"] = this.shortName;
        data["longName"] = this.longName;
        data["label"] = this.label;
        return data;
    }
}

export interface IGuarantorDto {
    originalGuarantorId?: number;
    name?: string;
    shortName?: string;
    longName?: string;
    label?: string;
}

export class CourseFacultyDto implements ICourseFacultyDto {
    facultyId?: number;
    faculty?: FacultyDto;
    courseId?: number;

    constructor(data?: ICourseFacultyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facultyId = _data["facultyId"];
            this.faculty = _data["faculty"] ? FacultyDto.fromJS(_data["faculty"]) : <any>undefined;
            this.courseId = _data["courseId"];
        }
    }

    static fromJS(data: any): CourseFacultyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseFacultyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facultyId"] = this.facultyId;
        data["faculty"] = this.faculty ? this.faculty.toJSON() : <any>undefined;
        data["courseId"] = this.courseId;
        return data;
    }
}

export interface ICourseFacultyDto {
    facultyId?: number;
    faculty?: FacultyDto;
    courseId?: number;
}

export class CourseSpecialityDto implements ICourseSpecialityDto {
    specialityId?: number;
    courseId?: number;
    speciality?: SpecialityDto;

    constructor(data?: ICourseSpecialityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.specialityId = _data["specialityId"];
            this.courseId = _data["courseId"];
            this.speciality = _data["speciality"] ? SpecialityDto.fromJS(_data["speciality"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CourseSpecialityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSpecialityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specialityId"] = this.specialityId;
        data["courseId"] = this.courseId;
        data["speciality"] = this.speciality ? this.speciality.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICourseSpecialityDto {
    specialityId?: number;
    courseId?: number;
    speciality?: SpecialityDto;
}

export class CourseDataDto implements ICourseDataDto {
    id?: number;
    title?: string;
    seoTitle?: string;

    constructor(data?: ICourseDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.seoTitle = _data["seoTitle"];
        }
    }

    static fromJS(data: any): CourseDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["seoTitle"] = this.seoTitle;
        return data;
    }
}

export interface ICourseDataDto {
    id?: number;
    title?: string;
    seoTitle?: string;
}

export class CourseTypeBaseDto implements ICourseTypeBaseDto {
    id?: number;
    originalCourseTypeId?: number;
    name?: string | undefined;
    label?: string | undefined;
    seoUrl?: string | undefined;
    seoTitle?: string | undefined;
    seoKeywords?: string | undefined;
    seoDescription?: string | undefined;
    order?: number;
    code?: string | undefined;
    canBeParent?: boolean;
    isActive?: boolean;
    isPractical?: boolean;
    guarantorType?: string | undefined;
    modality?: string | undefined;

    constructor(data?: ICourseTypeBaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.originalCourseTypeId = _data["originalCourseTypeId"];
            this.name = _data["name"];
            this.label = _data["label"];
            this.seoUrl = _data["seoUrl"];
            this.seoTitle = _data["seoTitle"];
            this.seoKeywords = _data["seoKeywords"];
            this.seoDescription = _data["seoDescription"];
            this.order = _data["order"];
            this.code = _data["code"];
            this.canBeParent = _data["canBeParent"];
            this.isActive = _data["isActive"];
            this.isPractical = _data["isPractical"];
            this.guarantorType = _data["guarantorType"];
            this.modality = _data["modality"];
        }
    }

    static fromJS(data: any): CourseTypeBaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseTypeBaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["originalCourseTypeId"] = this.originalCourseTypeId;
        data["name"] = this.name;
        data["label"] = this.label;
        data["seoUrl"] = this.seoUrl;
        data["seoTitle"] = this.seoTitle;
        data["seoKeywords"] = this.seoKeywords;
        data["seoDescription"] = this.seoDescription;
        data["order"] = this.order;
        data["code"] = this.code;
        data["canBeParent"] = this.canBeParent;
        data["isActive"] = this.isActive;
        data["isPractical"] = this.isPractical;
        data["guarantorType"] = this.guarantorType;
        data["modality"] = this.modality;
        return data;
    }
}

export interface ICourseTypeBaseDto {
    id?: number;
    originalCourseTypeId?: number;
    name?: string | undefined;
    label?: string | undefined;
    seoUrl?: string | undefined;
    seoTitle?: string | undefined;
    seoKeywords?: string | undefined;
    seoDescription?: string | undefined;
    order?: number;
    code?: string | undefined;
    canBeParent?: boolean;
    isActive?: boolean;
    isPractical?: boolean;
    guarantorType?: string | undefined;
    modality?: string | undefined;
}

export class CouponsOriginsDto implements ICouponsOriginsDto {
    id?: number;
    name?: string;

    constructor(data?: ICouponsOriginsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CouponsOriginsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponsOriginsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICouponsOriginsDto {
    id?: number;
    name?: string;
}

export class ContactFacultiesCreateDto implements IContactFacultiesCreateDto {
    facultiesId?: number[];
    contactId?: number;

    constructor(data?: IContactFacultiesCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["facultiesId"])) {
                this.facultiesId = [] as any;
                for (let item of _data["facultiesId"])
                    this.facultiesId!.push(item);
            }
            this.contactId = _data["contactId"];
        }
    }

    static fromJS(data: any): ContactFacultiesCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactFacultiesCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.facultiesId)) {
            data["facultiesId"] = [];
            for (let item of this.facultiesId)
                data["facultiesId"].push(item);
        }
        data["contactId"] = this.contactId;
        return data;
    }
}

export interface IContactFacultiesCreateDto {
    facultiesId?: number[];
    contactId?: number;
}

export class AddContactFacultiesCommand extends ContactFacultiesCreateDto implements IAddContactFacultiesCommand {

    constructor(data?: IAddContactFacultiesCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): AddContactFacultiesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddContactFacultiesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IAddContactFacultiesCommand extends IContactFacultiesCreateDto {
}

export class RemoveContactFacultyCommand implements IRemoveContactFacultyCommand {
    facultyId?: number;
    contactId?: number;

    constructor(data?: IRemoveContactFacultyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facultyId = _data["facultyId"];
            this.contactId = _data["contactId"];
        }
    }

    static fromJS(data: any): RemoveContactFacultyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveContactFacultyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facultyId"] = this.facultyId;
        data["contactId"] = this.contactId;
        return data;
    }
}

export interface IRemoveContactFacultyCommand {
    facultyId?: number;
    contactId?: number;
}

export class ContactSpecialitiesCreateDto implements IContactSpecialitiesCreateDto {
    specialitiesId?: number[];
    contactId?: number;

    constructor(data?: IContactSpecialitiesCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["specialitiesId"])) {
                this.specialitiesId = [] as any;
                for (let item of _data["specialitiesId"])
                    this.specialitiesId!.push(item);
            }
            this.contactId = _data["contactId"];
        }
    }

    static fromJS(data: any): ContactSpecialitiesCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSpecialitiesCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.specialitiesId)) {
            data["specialitiesId"] = [];
            for (let item of this.specialitiesId)
                data["specialitiesId"].push(item);
        }
        data["contactId"] = this.contactId;
        return data;
    }
}

export interface IContactSpecialitiesCreateDto {
    specialitiesId?: number[];
    contactId?: number;
}

export class AddContactSpecialitiesCommand extends ContactSpecialitiesCreateDto implements IAddContactSpecialitiesCommand {

    constructor(data?: IAddContactSpecialitiesCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): AddContactSpecialitiesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddContactSpecialitiesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IAddContactSpecialitiesCommand extends IContactSpecialitiesCreateDto {
}

export class RemoveContactSpecialitiesCommand implements IRemoveContactSpecialitiesCommand {
    specialitiesId?: number[];
    contactId?: number;

    constructor(data?: IRemoveContactSpecialitiesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["specialitiesId"])) {
                this.specialitiesId = [] as any;
                for (let item of _data["specialitiesId"])
                    this.specialitiesId!.push(item);
            }
            this.contactId = _data["contactId"];
        }
    }

    static fromJS(data: any): RemoveContactSpecialitiesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveContactSpecialitiesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.specialitiesId)) {
            data["specialitiesId"] = [];
            for (let item of this.specialitiesId)
                data["specialitiesId"].push(item);
        }
        data["contactId"] = this.contactId;
        return data;
    }
}

export interface IRemoveContactSpecialitiesCommand {
    specialitiesId?: number[];
    contactId?: number;
}

export class ContactInfoTlmkDto implements IContactInfoTlmkDto {
    id?: number;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    email?: string;
    phone?: string;
    idCard?: string;
    profession?: string;
    gender?: string;
    address?: string;
    city?: string;
    province?: string;
    countryCode?: string;
    postalCode?: string;
    department?: string;
    dateOfBirth?: Date | undefined;
    nationality?: string;
    titleType?: string;
    academicInstitution?: string;

    constructor(data?: IContactInfoTlmkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.firstSurName = _data["firstSurName"];
            this.secondSurName = _data["secondSurName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.idCard = _data["idCard"];
            this.profession = _data["profession"];
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.countryCode = _data["countryCode"];
            this.postalCode = _data["postalCode"];
            this.department = _data["department"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.nationality = _data["nationality"];
            this.titleType = _data["titleType"];
            this.academicInstitution = _data["academicInstitution"];
        }
    }

    static fromJS(data: any): ContactInfoTlmkDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInfoTlmkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["firstSurName"] = this.firstSurName;
        data["secondSurName"] = this.secondSurName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["idCard"] = this.idCard;
        data["profession"] = this.profession;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["city"] = this.city;
        data["province"] = this.province;
        data["countryCode"] = this.countryCode;
        data["postalCode"] = this.postalCode;
        data["department"] = this.department;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["nationality"] = this.nationality;
        data["titleType"] = this.titleType;
        data["academicInstitution"] = this.academicInstitution;
        return data;
    }
}

export interface IContactInfoTlmkDto {
    id?: number;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    email?: string;
    phone?: string;
    idCard?: string;
    profession?: string;
    gender?: string;
    address?: string;
    city?: string;
    province?: string;
    countryCode?: string;
    postalCode?: string;
    department?: string;
    dateOfBirth?: Date | undefined;
    nationality?: string;
    titleType?: string;
    academicInstitution?: string;
}

export class AddNewContactEmailCommand implements IAddNewContactEmailCommand {
    contactId?: number;
    email?: string;
    emailTypeId?: number;
    isDefault?: boolean;

    constructor(data?: IAddNewContactEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.email = _data["email"];
            this.emailTypeId = _data["emailTypeId"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): AddNewContactEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewContactEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["email"] = this.email;
        data["emailTypeId"] = this.emailTypeId;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IAddNewContactEmailCommand {
    contactId?: number;
    email?: string;
    emailTypeId?: number;
    isDefault?: boolean;
}

export class UpdateCountryCodeCommand implements IUpdateCountryCodeCommand {
    countryCode?: string;
    contactId?: number;

    constructor(data?: IUpdateCountryCodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryCode = _data["countryCode"];
            this.contactId = _data["contactId"];
        }
    }

    static fromJS(data: any): UpdateCountryCodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCountryCodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryCode"] = this.countryCode;
        data["contactId"] = this.contactId;
        return data;
    }
}

export interface IUpdateCountryCodeCommand {
    countryCode?: string;
    contactId?: number;
}

export class UpdateCurrencyCommand implements IUpdateCurrencyCommand {
    currencyId?: number;
    contactId?: number;

    constructor(data?: IUpdateCurrencyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currencyId = _data["currencyId"];
            this.contactId = _data["contactId"];
        }
    }

    static fromJS(data: any): UpdateCurrencyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCurrencyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currencyId"] = this.currencyId;
        data["contactId"] = this.contactId;
        return data;
    }
}

export interface IUpdateCurrencyCommand {
    currencyId?: number;
    contactId?: number;
}

export class ContactLeadUpdateDto implements IContactLeadUpdateDto {
    contactLeadId?: number;
    finalPrice?: number | undefined;
    discount?: number | undefined;
    enrollmentPercentage?: number | undefined;
    fees?: number | undefined;
    courseCode?: string;
    startDateCourse?: Date | undefined;
    finishDateCourse?: Date | undefined;
    convocationDate?: Date | undefined;
    courseTypeBaseCode?: string | undefined;
    types?: ContactLeadType[] | undefined;

    constructor(data?: IContactLeadUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactLeadId = _data["contactLeadId"];
            this.finalPrice = _data["finalPrice"];
            this.discount = _data["discount"];
            this.enrollmentPercentage = _data["enrollmentPercentage"];
            this.fees = _data["fees"];
            this.courseCode = _data["courseCode"];
            this.startDateCourse = _data["startDateCourse"] ? new Date(_data["startDateCourse"].toString()) : <any>undefined;
            this.finishDateCourse = _data["finishDateCourse"] ? new Date(_data["finishDateCourse"].toString()) : <any>undefined;
            this.convocationDate = _data["convocationDate"] ? new Date(_data["convocationDate"].toString()) : <any>undefined;
            this.courseTypeBaseCode = _data["courseTypeBaseCode"];
            if (Array.isArray(_data["types"])) {
                this.types = [] as any;
                for (let item of _data["types"])
                    this.types!.push(item);
            }
        }
    }

    static fromJS(data: any): ContactLeadUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLeadUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactLeadId"] = this.contactLeadId;
        data["finalPrice"] = this.finalPrice;
        data["discount"] = this.discount;
        data["enrollmentPercentage"] = this.enrollmentPercentage;
        data["fees"] = this.fees;
        data["courseCode"] = this.courseCode;
        data["startDateCourse"] = this.startDateCourse ? this.startDateCourse.toISOString() : <any>undefined;
        data["finishDateCourse"] = this.finishDateCourse ? this.finishDateCourse.toISOString() : <any>undefined;
        data["convocationDate"] = this.convocationDate ? this.convocationDate.toISOString() : <any>undefined;
        data["courseTypeBaseCode"] = this.courseTypeBaseCode;
        if (Array.isArray(this.types)) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item);
        }
        return data;
    }
}

export interface IContactLeadUpdateDto {
    contactLeadId?: number;
    finalPrice?: number | undefined;
    discount?: number | undefined;
    enrollmentPercentage?: number | undefined;
    fees?: number | undefined;
    courseCode?: string;
    startDateCourse?: Date | undefined;
    finishDateCourse?: Date | undefined;
    convocationDate?: Date | undefined;
    courseTypeBaseCode?: string | undefined;
    types?: ContactLeadType[] | undefined;
}

export class UpdateContactLeadCommand extends ContactLeadUpdateDto implements IUpdateContactLeadCommand {

    constructor(data?: IUpdateContactLeadCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpdateContactLeadCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactLeadCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateContactLeadCommand extends IContactLeadUpdateDto {
}

export class UpdateContactLeadsCommand implements IUpdateContactLeadsCommand {
    contactLeads?: ContactLeadUpdateDto[];

    constructor(data?: IUpdateContactLeadsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contactLeads"])) {
                this.contactLeads = [] as any;
                for (let item of _data["contactLeads"])
                    this.contactLeads!.push(ContactLeadUpdateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateContactLeadsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactLeadsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contactLeads)) {
            data["contactLeads"] = [];
            for (let item of this.contactLeads)
                data["contactLeads"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateContactLeadsCommand {
    contactLeads?: ContactLeadUpdateDto[];
}

export class ContactLeadPriceUpdateDto implements IContactLeadPriceUpdateDto {
    contactLeadId?: number;
    price?: number | undefined;
    finalPrice?: number | undefined;
    discount?: number | undefined;
    enrollmentPercentage?: number | undefined;
    fees?: number | undefined;

    constructor(data?: IContactLeadPriceUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactLeadId = _data["contactLeadId"];
            this.price = _data["price"];
            this.finalPrice = _data["finalPrice"];
            this.discount = _data["discount"];
            this.enrollmentPercentage = _data["enrollmentPercentage"];
            this.fees = _data["fees"];
        }
    }

    static fromJS(data: any): ContactLeadPriceUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactLeadPriceUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactLeadId"] = this.contactLeadId;
        data["price"] = this.price;
        data["finalPrice"] = this.finalPrice;
        data["discount"] = this.discount;
        data["enrollmentPercentage"] = this.enrollmentPercentage;
        data["fees"] = this.fees;
        return data;
    }
}

export interface IContactLeadPriceUpdateDto {
    contactLeadId?: number;
    price?: number | undefined;
    finalPrice?: number | undefined;
    discount?: number | undefined;
    enrollmentPercentage?: number | undefined;
    fees?: number | undefined;
}

export class UpdateContactLeadPriceCommand extends ContactLeadPriceUpdateDto implements IUpdateContactLeadPriceCommand {

    constructor(data?: IUpdateContactLeadPriceCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpdateContactLeadPriceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContactLeadPriceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateContactLeadPriceCommand extends IContactLeadPriceUpdateDto {
}

export class ContactGetted implements IContactGetted {
    correlationId?: string;
    id?: number;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    guidId?: string;

    constructor(data?: IContactGetted) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.correlationId = _data["correlationId"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.firstSurName = _data["firstSurName"];
            this.secondSurName = _data["secondSurName"];
            this.guidId = _data["guidId"];
        }
    }

    static fromJS(data: any): ContactGetted {
        data = typeof data === 'object' ? data : {};
        let result = new ContactGetted();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["correlationId"] = this.correlationId;
        data["id"] = this.id;
        data["name"] = this.name;
        data["firstSurName"] = this.firstSurName;
        data["secondSurName"] = this.secondSurName;
        data["guidId"] = this.guidId;
        return data;
    }
}

export interface IContactGetted {
    correlationId?: string;
    id?: number;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    guidId?: string;
}

export class ContactUserDto implements IContactUserDto {
    id?: number;
    name?: string;
    surname?: string;
    email?: string;

    constructor(data?: IContactUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ContactUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        return data;
    }
}

export interface IContactUserDto {
    id?: number;
    name?: string;
    surname?: string;
    email?: string;
}

export class RecoverContactActivationsCommand implements IRecoverContactActivationsCommand {
    processId?: number;

    constructor(data?: IRecoverContactActivationsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processId = _data["processId"];
        }
    }

    static fromJS(data: any): RecoverContactActivationsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RecoverContactActivationsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processId"] = this.processId;
        return data;
    }
}

export interface IRecoverContactActivationsCommand {
    processId?: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;
}

export class ValidationProblemDetails extends HttpValidationProblemDetails implements IValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IValidationProblemDetails) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IValidationProblemDetails extends IHttpValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;
}

/** It is used to transfer the data from the source email to the destination email. */
export class ConsolidateContactsCommand implements IConsolidateContactsCommand {
    /** Email where the data will be transferred. */
    destinationEmail?: string;
    /** Email with the data to be transferred. */
    originEmail?: string;

    constructor(data?: IConsolidateContactsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.destinationEmail = _data["destinationEmail"];
            this.originEmail = _data["originEmail"];
        }
    }

    static fromJS(data: any): ConsolidateContactsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConsolidateContactsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["destinationEmail"] = this.destinationEmail;
        data["originEmail"] = this.originEmail;
        return data;
    }
}

/** It is used to transfer the data from the source email to the destination email. */
export interface IConsolidateContactsCommand {
    /** Email where the data will be transferred. */
    destinationEmail?: string;
    /** Email with the data to be transferred. */
    originEmail?: string;
}

/** It is used to "transfer the data" from the source contact to the destination contact by ids. */
export class ConsolidateContactsByIdCommand implements IConsolidateContactsByIdCommand {
    /** Contact Id where the data will be transferred. */
    destinationId?: number;
    /** Contact Id with the data to be transferred. */
    originId?: number;
    apiKey?: string;

    constructor(data?: IConsolidateContactsByIdCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.destinationId = _data["destinationId"];
            this.originId = _data["originId"];
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): ConsolidateContactsByIdCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConsolidateContactsByIdCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["destinationId"] = this.destinationId;
        data["originId"] = this.originId;
        data["apiKey"] = this.apiKey;
        return data;
    }
}

/** It is used to "transfer the data" from the source contact to the destination contact by ids. */
export interface IConsolidateContactsByIdCommand {
    /** Contact Id where the data will be transferred. */
    destinationId?: number;
    /** Contact Id with the data to be transferred. */
    originId?: number;
    apiKey?: string;
}

/** Create a new fp coupon from a university coupon. */
export class CreateSpecialFpContactCouponDto implements ICreateSpecialFpContactCouponDto {
    /** id de la tabla contact. */
    contactId?: number;
    /** Id de la tabla processes. */
    processId?: number;

    constructor(data?: ICreateSpecialFpContactCouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
        }
    }

    static fromJS(data: any): CreateSpecialFpContactCouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSpecialFpContactCouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        return data;
    }
}

/** Create a new fp coupon from a university coupon. */
export interface ICreateSpecialFpContactCouponDto {
    /** id de la tabla contact. */
    contactId?: number;
    /** Id de la tabla processes. */
    processId?: number;
}

export class CopyToCouponFpCommand extends CreateSpecialFpContactCouponDto implements ICopyToCouponFpCommand {

    constructor(data?: ICopyToCouponFpCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CopyToCouponFpCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CopyToCouponFpCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICopyToCouponFpCommand extends ICreateSpecialFpContactCouponDto {
}

export class TopSellingCourseDto implements ITopSellingCourseDto {
    facultyId?: number;
    title?: string;
    courseCode?: string;
    courseTypeBaseCode?: string;
    courseCountryId?: number;
    countryId?: number;
    total?: number;

    constructor(data?: ITopSellingCourseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facultyId = _data["facultyId"];
            this.title = _data["title"];
            this.courseCode = _data["courseCode"];
            this.courseTypeBaseCode = _data["courseTypeBaseCode"];
            this.courseCountryId = _data["courseCountryId"];
            this.countryId = _data["countryId"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): TopSellingCourseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopSellingCourseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facultyId"] = this.facultyId;
        data["title"] = this.title;
        data["courseCode"] = this.courseCode;
        data["courseTypeBaseCode"] = this.courseTypeBaseCode;
        data["courseCountryId"] = this.courseCountryId;
        data["countryId"] = this.countryId;
        data["total"] = this.total;
        return data;
    }
}

export interface ITopSellingCourseDto {
    facultyId?: number;
    title?: string;
    courseCode?: string;
    courseTypeBaseCode?: string;
    courseCountryId?: number;
    countryId?: number;
    total?: number;
}

export class PopulateMissingInterestedCoursesResult implements IPopulateMissingInterestedCoursesResult {
    statisticsPeriodStart?: Date;
    statisticsPeriodEnd?: Date;
    totalCoursesCreated?: number;
    /** Reasons can be:
1. No sold courses statistics found by provided criteria,
2. No matching non-deleted coursed for statistics,
3. Minimum required Course graph incomplete (CourseType && Faculty && Country)
             */
    totalCoursesSkipped?: number;
    /** Count only in case of Specific Contacts workflow. null/absent value means that this workflow
was not executed and counting is not relevant.
             */
    notFoundContactsCount?: number | undefined;
    createdByFacultyCountries?: { [key: string]: { [key: string]: number; }; };
    skippedByFacultyCounties?: { [key: string]: { [key: string]: number; }; };
    exceptions?: Exception[];

    constructor(data?: IPopulateMissingInterestedCoursesResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statisticsPeriodStart = _data["statisticsPeriodStart"] ? new Date(_data["statisticsPeriodStart"].toString()) : <any>undefined;
            this.statisticsPeriodEnd = _data["statisticsPeriodEnd"] ? new Date(_data["statisticsPeriodEnd"].toString()) : <any>undefined;
            this.totalCoursesCreated = _data["totalCoursesCreated"];
            this.totalCoursesSkipped = _data["totalCoursesSkipped"];
            this.notFoundContactsCount = _data["notFoundContactsCount"];
            if (_data["createdByFacultyCountries"]) {
                this.createdByFacultyCountries = {} as any;
                for (let key in _data["createdByFacultyCountries"]) {
                    if (_data["createdByFacultyCountries"].hasOwnProperty(key))
                        (<any>this.createdByFacultyCountries)![key] = _data["createdByFacultyCountries"][key] !== undefined ? _data["createdByFacultyCountries"][key] : {};
                }
            }
            if (_data["skippedByFacultyCounties"]) {
                this.skippedByFacultyCounties = {} as any;
                for (let key in _data["skippedByFacultyCounties"]) {
                    if (_data["skippedByFacultyCounties"].hasOwnProperty(key))
                        (<any>this.skippedByFacultyCounties)![key] = _data["skippedByFacultyCounties"][key] !== undefined ? _data["skippedByFacultyCounties"][key] : {};
                }
            }
            if (Array.isArray(_data["exceptions"])) {
                this.exceptions = [] as any;
                for (let item of _data["exceptions"])
                    this.exceptions!.push(Exception.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PopulateMissingInterestedCoursesResult {
        data = typeof data === 'object' ? data : {};
        let result = new PopulateMissingInterestedCoursesResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statisticsPeriodStart"] = this.statisticsPeriodStart ? this.statisticsPeriodStart.toISOString() : <any>undefined;
        data["statisticsPeriodEnd"] = this.statisticsPeriodEnd ? this.statisticsPeriodEnd.toISOString() : <any>undefined;
        data["totalCoursesCreated"] = this.totalCoursesCreated;
        data["totalCoursesSkipped"] = this.totalCoursesSkipped;
        data["notFoundContactsCount"] = this.notFoundContactsCount;
        if (this.createdByFacultyCountries) {
            data["createdByFacultyCountries"] = {};
            for (let key in this.createdByFacultyCountries) {
                if (this.createdByFacultyCountries.hasOwnProperty(key))
                    (<any>data["createdByFacultyCountries"])[key] = (<any>this.createdByFacultyCountries)[key];
            }
        }
        if (this.skippedByFacultyCounties) {
            data["skippedByFacultyCounties"] = {};
            for (let key in this.skippedByFacultyCounties) {
                if (this.skippedByFacultyCounties.hasOwnProperty(key))
                    (<any>data["skippedByFacultyCounties"])[key] = (<any>this.skippedByFacultyCounties)[key];
            }
        }
        if (Array.isArray(this.exceptions)) {
            data["exceptions"] = [];
            for (let item of this.exceptions)
                data["exceptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPopulateMissingInterestedCoursesResult {
    statisticsPeriodStart?: Date;
    statisticsPeriodEnd?: Date;
    totalCoursesCreated?: number;
    /** Reasons can be:
1. No sold courses statistics found by provided criteria,
2. No matching non-deleted coursed for statistics,
3. Minimum required Course graph incomplete (CourseType && Faculty && Country)
             */
    totalCoursesSkipped?: number;
    /** Count only in case of Specific Contacts workflow. null/absent value means that this workflow
was not executed and counting is not relevant.
             */
    notFoundContactsCount?: number | undefined;
    createdByFacultyCountries?: { [key: string]: { [key: string]: number; }; };
    skippedByFacultyCounties?: { [key: string]: { [key: string]: number; }; };
    exceptions?: Exception[];
}

export class Exception implements IException {
    message?: string;
    innerException?: Exception | undefined;
    source?: string | undefined;
    stackTrace?: string | undefined;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["Message"];
            this.innerException = _data["InnerException"] ? Exception.fromJS(_data["InnerException"]) : <any>undefined;
            this.source = _data["Source"];
            this.stackTrace = _data["StackTrace"];
        }
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        data["InnerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["Source"] = this.source;
        data["StackTrace"] = this.stackTrace;
        return data;
    }
}

export interface IException {
    message?: string;
    innerException?: Exception | undefined;
    source?: string | undefined;
    stackTrace?: string | undefined;
}

/** Represents an error. */
export class ErrorDto implements IErrorDto {
    /** Gets the unique error code. */
    code?: string;
    /** Gets the error description. */
    description?: string;
    /** Gets the error type. */
    type?: ErrorType;
    /** Gets the numeric value of the type. */
    numericType?: number;
    /** Gets the metadata. */
    metadata?: { [key: string]: any; } | undefined;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.description = _data["description"];
            this.type = _data["type"];
            this.numericType = _data["numericType"];
            if (_data["metadata"]) {
                this.metadata = {} as any;
                for (let key in _data["metadata"]) {
                    if (_data["metadata"].hasOwnProperty(key))
                        (<any>this.metadata)![key] = _data["metadata"][key];
                }
            }
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        data["type"] = this.type;
        data["numericType"] = this.numericType;
        if (this.metadata) {
            data["metadata"] = {};
            for (let key in this.metadata) {
                if (this.metadata.hasOwnProperty(key))
                    (<any>data["metadata"])[key] = (<any>this.metadata)[key];
            }
        }
        return data;
    }
}

/** Represents an error. */
export interface IErrorDto {
    /** Gets the unique error code. */
    code?: string;
    /** Gets the error description. */
    description?: string;
    /** Gets the error type. */
    type?: ErrorType;
    /** Gets the numeric value of the type. */
    numericType?: number;
    /** Gets the metadata. */
    metadata?: { [key: string]: any; } | undefined;
}

/** Error types. */
export enum ErrorType {
    Failure = "failure",
    Unexpected = "unexpected",
    Validation = "validation",
    Conflict = "conflict",
    NotFound = "notFound",
    Unauthorized = "unauthorized",
    Forbidden = "forbidden",
}

/** Command to create missing Interested Courses for Contacts accoring using one of the possible workflows. */
export class PopulateMissingInterestedCoursesDto implements IPopulateMissingInterestedCoursesDto {
    /** Area/FacultyName to work with. Accepts wildcard character * to work with all faculties.
             */
    area?: string;
    /** Contact country code. Accepts wildcard character * to work with all countries.
             */
    countryCode?: string;
    /** Must be provided in case of Specific Contacts workflow is intended.
Total maximum number of contacts to work with.
If omitted or 0, then job will not execute.
If wildcard value of -1 is used then all then Contacts will be processed, that are missing
interested course.
Will be ignored when ContactIds are provided.
             */
    maxJobContacts?: number | undefined;
    /** Optional. If provided, then Specific Contacts workflow will be executed, so only these contacts are
analyzed for missing interested courses and Area and CountryCode
will be ignored.
Parameter MaxJobContacts will be ignored in this case.
             */
    contactIds?: number[] | undefined;

    constructor(data?: IPopulateMissingInterestedCoursesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.area = _data["area"];
            this.countryCode = _data["countryCode"];
            this.maxJobContacts = _data["maxJobContacts"];
            if (Array.isArray(_data["contactIds"])) {
                this.contactIds = [] as any;
                for (let item of _data["contactIds"])
                    this.contactIds!.push(item);
            }
        }
    }

    static fromJS(data: any): PopulateMissingInterestedCoursesDto {
        data = typeof data === 'object' ? data : {};
        let result = new PopulateMissingInterestedCoursesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["area"] = this.area;
        data["countryCode"] = this.countryCode;
        data["maxJobContacts"] = this.maxJobContacts;
        if (Array.isArray(this.contactIds)) {
            data["contactIds"] = [];
            for (let item of this.contactIds)
                data["contactIds"].push(item);
        }
        return data;
    }
}

/** Command to create missing Interested Courses for Contacts accoring using one of the possible workflows. */
export interface IPopulateMissingInterestedCoursesDto {
    /** Area/FacultyName to work with. Accepts wildcard character * to work with all faculties.
             */
    area?: string;
    /** Contact country code. Accepts wildcard character * to work with all countries.
             */
    countryCode?: string;
    /** Must be provided in case of Specific Contacts workflow is intended.
Total maximum number of contacts to work with.
If omitted or 0, then job will not execute.
If wildcard value of -1 is used then all then Contacts will be processed, that are missing
interested course.
Will be ignored when ContactIds are provided.
             */
    maxJobContacts?: number | undefined;
    /** Optional. If provided, then Specific Contacts workflow will be executed, so only these contacts are
analyzed for missing interested courses and Area and CountryCode
will be ignored.
Parameter MaxJobContacts will be ignored in this case.
             */
    contactIds?: number[] | undefined;
}

/** Command to create missing Interested Courses for Contacts accoring using one of the possible workflows. */
export class PopulateMissingInterestedCoursesCommand extends PopulateMissingInterestedCoursesDto implements IPopulateMissingInterestedCoursesCommand {
    apiKey?: string;

    constructor(data?: IPopulateMissingInterestedCoursesCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): PopulateMissingInterestedCoursesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PopulateMissingInterestedCoursesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        super.toJSON(data);
        return data;
    }
}

/** Command to create missing Interested Courses for Contacts accoring using one of the possible workflows. */
export interface IPopulateMissingInterestedCoursesCommand extends IPopulateMissingInterestedCoursesDto {
    apiKey?: string;
}

export class PaginatedListOfEmailPaginationDto implements IPaginatedListOfEmailPaginationDto {
    items?: EmailPaginationDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfEmailPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EmailPaginationDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfEmailPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfEmailPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfEmailPaginationDto {
    items?: EmailPaginationDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class EmailPaginationDto implements IEmailPaginationDto {
    id?: number;
    userId?: number | undefined;
    user?: UserEmailContactPaginationDto;
    actionId?: number | undefined;
    action?: ActionEmailContactPaginationDto;
    from?: string;
    fromName?: string;
    to?: string;
    cc?: string;
    subject?: string;
    message?: string;

    constructor(data?: IEmailPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserEmailContactPaginationDto.fromJS(_data["user"]) : <any>undefined;
            this.actionId = _data["actionId"];
            this.action = _data["action"] ? ActionEmailContactPaginationDto.fromJS(_data["action"]) : <any>undefined;
            this.from = _data["from"];
            this.fromName = _data["fromName"];
            this.to = _data["to"];
            this.cc = _data["cc"];
            this.subject = _data["subject"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): EmailPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["actionId"] = this.actionId;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["fromName"] = this.fromName;
        data["to"] = this.to;
        data["cc"] = this.cc;
        data["subject"] = this.subject;
        data["message"] = this.message;
        return data;
    }
}

export interface IEmailPaginationDto {
    id?: number;
    userId?: number | undefined;
    user?: UserEmailContactPaginationDto;
    actionId?: number | undefined;
    action?: ActionEmailContactPaginationDto;
    from?: string;
    fromName?: string;
    to?: string;
    cc?: string;
    subject?: string;
    message?: string;
}

export class UserEmailContactPaginationDto implements IUserEmailContactPaginationDto {
    id?: number;
    name?: string;
    surname?: string;
    email?: string;
    username?: string;

    constructor(data?: IUserEmailContactPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): UserEmailContactPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailContactPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["username"] = this.username;
        return data;
    }
}

export interface IUserEmailContactPaginationDto {
    id?: number;
    name?: string;
    surname?: string;
    email?: string;
    username?: string;
}

export class ActionEmailContactPaginationDto implements IActionEmailContactPaginationDto {
    id?: number;
    date?: Date;
    userId?: number | undefined;
    contactId?: number;
    processId?: number;
    process?: ProcessActionEmailContactPaginationDto;

    constructor(data?: IActionEmailContactPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
            this.process = _data["process"] ? ProcessActionEmailContactPaginationDto.fromJS(_data["process"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionEmailContactPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionEmailContactPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        data["process"] = this.process ? this.process.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActionEmailContactPaginationDto {
    id?: number;
    date?: Date;
    userId?: number | undefined;
    contactId?: number;
    processId?: number;
    process?: ProcessActionEmailContactPaginationDto;
}

export class ProcessActionEmailContactPaginationDto implements IProcessActionEmailContactPaginationDto {
    id?: number;
    userId?: number | undefined;
    contactId?: number;
    ordersImportedId?: number | undefined;

    constructor(data?: IProcessActionEmailContactPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.ordersImportedId = _data["ordersImportedId"];
        }
    }

    static fromJS(data: any): ProcessActionEmailContactPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessActionEmailContactPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["ordersImportedId"] = this.ordersImportedId;
        return data;
    }
}

export interface IProcessActionEmailContactPaginationDto {
    id?: number;
    userId?: number | undefined;
    contactId?: number;
    ordersImportedId?: number | undefined;
}

export enum Colour {
    None = "",
    Green = "green",
    GreenYellow = "greenyellow",
    Yellow = "yellow",
    Red = "red",
    Grey = "grey",
}

export class EmailFullDto implements IEmailFullDto {
    id?: number;
    contactId?: number;
    contact?: ContactEmailFullDto;
    userId?: number | undefined;
    user?: UserEmailFullDto;
    actionId?: number | undefined;
    action?: ActionEmailFullDto;
    from?: string;
    fromName?: string;
    to?: string;
    cc?: string;
    bcc?: string;
    subject?: string;
    body?: string;
    message?: string;
    emailTemplateId?: number | undefined;
    attachments?: AttachmentEmailFullDto[];

    constructor(data?: IEmailFullDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.contactId = _data["contactId"];
            this.contact = _data["contact"] ? ContactEmailFullDto.fromJS(_data["contact"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserEmailFullDto.fromJS(_data["user"]) : <any>undefined;
            this.actionId = _data["actionId"];
            this.action = _data["action"] ? ActionEmailFullDto.fromJS(_data["action"]) : <any>undefined;
            this.from = _data["from"];
            this.fromName = _data["fromName"];
            this.to = _data["to"];
            this.cc = _data["cc"];
            this.bcc = _data["bcc"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.message = _data["message"];
            this.emailTemplateId = _data["emailTemplateId"];
            if (Array.isArray(_data["attachments"])) {
                this.attachments = [] as any;
                for (let item of _data["attachments"])
                    this.attachments!.push(AttachmentEmailFullDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailFullDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailFullDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["actionId"] = this.actionId;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["fromName"] = this.fromName;
        data["to"] = this.to;
        data["cc"] = this.cc;
        data["bcc"] = this.bcc;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["message"] = this.message;
        data["emailTemplateId"] = this.emailTemplateId;
        if (Array.isArray(this.attachments)) {
            data["attachments"] = [];
            for (let item of this.attachments)
                data["attachments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEmailFullDto {
    id?: number;
    contactId?: number;
    contact?: ContactEmailFullDto;
    userId?: number | undefined;
    user?: UserEmailFullDto;
    actionId?: number | undefined;
    action?: ActionEmailFullDto;
    from?: string;
    fromName?: string;
    to?: string;
    cc?: string;
    bcc?: string;
    subject?: string;
    body?: string;
    message?: string;
    emailTemplateId?: number | undefined;
    attachments?: AttachmentEmailFullDto[];
}

export class ContactEmailFullDto implements IContactEmailFullDto {
    id?: number;
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string;

    constructor(data?: IContactEmailFullDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): ContactEmailFullDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactEmailFullDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data;
    }
}

export interface IContactEmailFullDto {
    id?: number;
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string;
}

export class UserEmailFullDto implements IUserEmailFullDto {
    id?: number;
    name?: string;
    surname?: string;
    email?: string;
    username?: string;

    constructor(data?: IUserEmailFullDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.email = _data["email"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): UserEmailFullDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEmailFullDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["email"] = this.email;
        data["username"] = this.username;
        return data;
    }
}

export interface IUserEmailFullDto {
    id?: number;
    name?: string;
    surname?: string;
    email?: string;
    username?: string;
}

export class ActionEmailFullDto implements IActionEmailFullDto {
    id?: number;
    date?: Date;
    userId?: number | undefined;
    contactId?: number;
    processId?: number;
    process?: ProcessActionEmailContactPaginationDto;

    constructor(data?: IActionEmailFullDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
            this.process = _data["process"] ? ProcessActionEmailContactPaginationDto.fromJS(_data["process"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionEmailFullDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionEmailFullDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        data["process"] = this.process ? this.process.toJSON() : <any>undefined;
        return data;
    }
}

export interface IActionEmailFullDto {
    id?: number;
    date?: Date;
    userId?: number | undefined;
    contactId?: number;
    processId?: number;
    process?: ProcessActionEmailContactPaginationDto;
}

export class AttachmentEmailFullDto implements IAttachmentEmailFullDto {
    id?: number;
    fileName?: string;
    path?: string;

    constructor(data?: IAttachmentEmailFullDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
            this.path = _data["path"];
        }
    }

    static fromJS(data: any): AttachmentEmailFullDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentEmailFullDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        data["path"] = this.path;
        return data;
    }
}

export interface IAttachmentEmailFullDto {
    id?: number;
    fileName?: string;
    path?: string;
}

export class GetMailBoxFreeQuery implements IGetMailBoxFreeQuery {

    constructor(data?: IGetMailBoxFreeQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetMailBoxFreeQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetMailBoxFreeQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetMailBoxFreeQuery {
}

export class SendEmailCommercialAssignment implements ISendEmailCommercialAssignment {
    correlationId?: NewId;
    processIds?: number[];

    constructor(data?: ISendEmailCommercialAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.correlationId = _data["correlationId"] ? NewId.fromJS(_data["correlationId"]) : <any>undefined;
            if (Array.isArray(_data["processIds"])) {
                this.processIds = [] as any;
                for (let item of _data["processIds"])
                    this.processIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SendEmailCommercialAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailCommercialAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["correlationId"] = this.correlationId ? this.correlationId.toJSON() : <any>undefined;
        if (Array.isArray(this.processIds)) {
            data["processIds"] = [];
            for (let item of this.processIds)
                data["processIds"].push(item);
        }
        return data;
    }
}

export interface ISendEmailCommercialAssignment {
    correlationId?: NewId;
    processIds?: number[];
}

export class SendEmailCommercialAssignmentCommand extends SendEmailCommercialAssignment implements ISendEmailCommercialAssignmentCommand {
    apiKey?: string;

    constructor(data?: ISendEmailCommercialAssignmentCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): SendEmailCommercialAssignmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailCommercialAssignmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        super.toJSON(data);
        return data;
    }
}

export interface ISendEmailCommercialAssignmentCommand extends ISendEmailCommercialAssignment {
    apiKey?: string;
}

/** A NewId is a type that fits into the same space as a Guid/Uuid/unique identifier, but is guaranteed to be both unique and ordered, assuming it is generated using a single instance of the generator for each network address used. */
export class NewId implements INewId {
    timestamp?: Date;

    constructor(data?: INewId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timestamp = _data["timestamp"] ? new Date(_data["timestamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): NewId {
        data = typeof data === 'object' ? data : {};
        let result = new NewId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        return data;
    }
}

/** A NewId is a type that fits into the same space as a Guid/Uuid/unique identifier, but is guaranteed to be both unique and ordered, assuming it is generated using a single instance of the generator for each network address used. */
export interface INewId {
    timestamp?: Date;
}

export class SendEmailRecords2ScholarshipActivation implements ISendEmailRecords2ScholarshipActivation {
    correlationId?: NewId;
    processIds?: number[];

    constructor(data?: ISendEmailRecords2ScholarshipActivation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.correlationId = _data["correlationId"] ? NewId.fromJS(_data["correlationId"]) : <any>undefined;
            if (Array.isArray(_data["processIds"])) {
                this.processIds = [] as any;
                for (let item of _data["processIds"])
                    this.processIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SendEmailRecords2ScholarshipActivation {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailRecords2ScholarshipActivation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["correlationId"] = this.correlationId ? this.correlationId.toJSON() : <any>undefined;
        if (Array.isArray(this.processIds)) {
            data["processIds"] = [];
            for (let item of this.processIds)
                data["processIds"].push(item);
        }
        return data;
    }
}

export interface ISendEmailRecords2ScholarshipActivation {
    correlationId?: NewId;
    processIds?: number[];
}

export class SendEmailRecords2ScholarshipActivationCommand extends SendEmailRecords2ScholarshipActivation implements ISendEmailRecords2ScholarshipActivationCommand {
    apiKey?: string;

    constructor(data?: ISendEmailRecords2ScholarshipActivationCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): SendEmailRecords2ScholarshipActivationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailRecords2ScholarshipActivationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        super.toJSON(data);
        return data;
    }
}

export interface ISendEmailRecords2ScholarshipActivationCommand extends ISendEmailRecords2ScholarshipActivation {
    apiKey?: string;
}

export class SendEmailCloseProcesses implements ISendEmailCloseProcesses {
    correlationId?: NewId;
    processIds?: number[];

    constructor(data?: ISendEmailCloseProcesses) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.correlationId = _data["correlationId"] ? NewId.fromJS(_data["correlationId"]) : <any>undefined;
            if (Array.isArray(_data["processIds"])) {
                this.processIds = [] as any;
                for (let item of _data["processIds"])
                    this.processIds!.push(item);
            }
        }
    }

    static fromJS(data: any): SendEmailCloseProcesses {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailCloseProcesses();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["correlationId"] = this.correlationId ? this.correlationId.toJSON() : <any>undefined;
        if (Array.isArray(this.processIds)) {
            data["processIds"] = [];
            for (let item of this.processIds)
                data["processIds"].push(item);
        }
        return data;
    }
}

export interface ISendEmailCloseProcesses {
    correlationId?: NewId;
    processIds?: number[];
}

export class SendEmailCloseProcessesCommand extends SendEmailCloseProcesses implements ISendEmailCloseProcessesCommand {
    apiKey?: string;

    constructor(data?: ISendEmailCloseProcessesCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): SendEmailCloseProcessesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailCloseProcessesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        super.toJSON(data);
        return data;
    }
}

export interface ISendEmailCloseProcessesCommand extends ISendEmailCloseProcesses {
    apiKey?: string;
}

export class EmployeeSubordinateViewModel implements IEmployeeSubordinateViewModel {
    id?: number;
    name?: string;
    surname?: string;
    countryName?: string;
    organizationNodeName?: string;
    userId?: number;

    constructor(data?: IEmployeeSubordinateViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.countryName = _data["countryName"];
            this.organizationNodeName = _data["organizationNodeName"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): EmployeeSubordinateViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeSubordinateViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["countryName"] = this.countryName;
        data["organizationNodeName"] = this.organizationNodeName;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IEmployeeSubordinateViewModel {
    id?: number;
    name?: string;
    surname?: string;
    countryName?: string;
    organizationNodeName?: string;
    userId?: number;
}

export class GetAllManagerSubordinatesQuery implements IGetAllManagerSubordinatesQuery {

    constructor(data?: IGetAllManagerSubordinatesQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetAllManagerSubordinatesQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllManagerSubordinatesQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetAllManagerSubordinatesQuery {
}

export class ManagerDto implements IManagerDto {
    givenName?: string;
    surname?: string;
    corporatePhone?: string;
    corporateEmail?: string;

    constructor(data?: IManagerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.givenName = _data["givenName"];
            this.surname = _data["surname"];
            this.corporatePhone = _data["corporatePhone"];
            this.corporateEmail = _data["corporateEmail"];
        }
    }

    static fromJS(data: any): ManagerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ManagerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["givenName"] = this.givenName;
        data["surname"] = this.surname;
        data["corporatePhone"] = this.corporatePhone;
        data["corporateEmail"] = this.corporateEmail;
        return data;
    }
}

export interface IManagerDto {
    givenName?: string;
    surname?: string;
    corporatePhone?: string;
    corporateEmail?: string;
}

export class GetManagerByEmployeeQuery implements IGetManagerByEmployeeQuery {

    constructor(data?: IGetManagerByEmployeeQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): GetManagerByEmployeeQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetManagerByEmployeeQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IGetManagerByEmployeeQuery {
}

export class EmployeeDto implements IEmployeeDto {
    gender?: EmployeeGender;
    corporatePhonePrefix?: string;
    corporatePhone?: string;
    corporateEmail?: string;

    constructor(data?: IEmployeeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gender = _data["gender"];
            this.corporatePhonePrefix = _data["corporatePhonePrefix"];
            this.corporatePhone = _data["corporatePhone"];
            this.corporateEmail = _data["corporateEmail"];
        }
    }

    static fromJS(data: any): EmployeeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gender"] = this.gender;
        data["corporatePhonePrefix"] = this.corporatePhonePrefix;
        data["corporatePhone"] = this.corporatePhone;
        data["corporateEmail"] = this.corporateEmail;
        return data;
    }
}

export interface IEmployeeDto {
    gender?: EmployeeGender;
    corporatePhonePrefix?: string;
    corporatePhone?: string;
    corporateEmail?: string;
}

export enum EmployeeGender {
    Female = "female",
    Male = "male",
    NonBinary = "nonbinary",
}

export class FlowDto implements IFlowDto {
    processType?: ProcessType;
    tagId?: number | undefined;
    totalSteps?: number;

    constructor(data?: IFlowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processType = _data["processType"];
            this.tagId = _data["tagId"];
            this.totalSteps = _data["totalSteps"];
        }
    }

    static fromJS(data: any): FlowDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processType"] = this.processType;
        data["tagId"] = this.tagId;
        data["totalSteps"] = this.totalSteps;
        return data;
    }
}

export interface IFlowDto {
    processType?: ProcessType;
    tagId?: number | undefined;
    totalSteps?: number;
}

/** Represents a void type, since Void is not a valid return type in C#. */
export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Represents a void type, since Void is not a valid return type in C#. */
export interface IUnit {
}

export class FlowDuplicateDto implements IFlowDuplicateDto {
    originProcessType?: ProcessType;
    originTagId?: number;
    processType?: ProcessType;
    tagId?: number;
    tagName?: string;

    constructor(data?: IFlowDuplicateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originProcessType = _data["originProcessType"];
            this.originTagId = _data["originTagId"];
            this.processType = _data["processType"];
            this.tagId = _data["tagId"];
            this.tagName = _data["tagName"];
        }
    }

    static fromJS(data: any): FlowDuplicateDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlowDuplicateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originProcessType"] = this.originProcessType;
        data["originTagId"] = this.originTagId;
        data["processType"] = this.processType;
        data["tagId"] = this.tagId;
        data["tagName"] = this.tagName;
        return data;
    }
}

export interface IFlowDuplicateDto {
    originProcessType?: ProcessType;
    originTagId?: number;
    processType?: ProcessType;
    tagId?: number;
    tagName?: string;
}

export class DuplicateFlowCommand extends FlowDuplicateDto implements IDuplicateFlowCommand {

    constructor(data?: IDuplicateFlowCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): DuplicateFlowCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DuplicateFlowCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IDuplicateFlowCommand extends IFlowDuplicateDto {
}

export class PaginatedListOfInvoicePaymentOptionDto implements IPaginatedListOfInvoicePaymentOptionDto {
    items?: InvoicePaymentOptionDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfInvoicePaymentOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InvoicePaymentOptionDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfInvoicePaymentOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfInvoicePaymentOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfInvoicePaymentOptionDto {
    items?: InvoicePaymentOptionDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class InvoicePaymentOptionDto implements IInvoicePaymentOptionDto {
    id?: number;
    invoicePaymentTypeId?: number;
    number?: string;
    holder?: string;
    status?: string;
    hasNonPayment?: boolean;
    invoicePaymentType?: InvoicePaymentTypeDto;

    constructor(data?: IInvoicePaymentOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoicePaymentTypeId = _data["invoicePaymentTypeId"];
            this.number = _data["number"];
            this.holder = _data["holder"];
            this.status = _data["status"];
            this.hasNonPayment = _data["hasNonPayment"];
            this.invoicePaymentType = _data["invoicePaymentType"] ? InvoicePaymentTypeDto.fromJS(_data["invoicePaymentType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InvoicePaymentOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoicePaymentTypeId"] = this.invoicePaymentTypeId;
        data["number"] = this.number;
        data["holder"] = this.holder;
        data["status"] = this.status;
        data["hasNonPayment"] = this.hasNonPayment;
        data["invoicePaymentType"] = this.invoicePaymentType ? this.invoicePaymentType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInvoicePaymentOptionDto {
    id?: number;
    invoicePaymentTypeId?: number;
    number?: string;
    holder?: string;
    status?: string;
    hasNonPayment?: boolean;
    invoicePaymentType?: InvoicePaymentTypeDto;
}

export class InvoicePaymentTypeDto implements IInvoicePaymentTypeDto {
    invoicePaymentTypeId?: number;
    name?: string;

    constructor(data?: IInvoicePaymentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoicePaymentTypeId = _data["invoicePaymentTypeId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): InvoicePaymentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoicePaymentTypeId"] = this.invoicePaymentTypeId;
        data["name"] = this.name;
        return data;
    }
}

export interface IInvoicePaymentTypeDto {
    invoicePaymentTypeId?: number;
    name?: string;
}

export class InvoicePaymentOptionCreateDto implements IInvoicePaymentOptionCreateDto {
    invoicePaymentTypeId?: number;
    number?: string;
    holder?: string;
    status?: string;
    contacts?: ContactChildDto[];

    constructor(data?: IInvoicePaymentOptionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.invoicePaymentTypeId = _data["invoicePaymentTypeId"];
            this.number = _data["number"];
            this.holder = _data["holder"];
            this.status = _data["status"];
            if (Array.isArray(_data["contacts"])) {
                this.contacts = [] as any;
                for (let item of _data["contacts"])
                    this.contacts!.push(ContactChildDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoicePaymentOptionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentOptionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoicePaymentTypeId"] = this.invoicePaymentTypeId;
        data["number"] = this.number;
        data["holder"] = this.holder;
        data["status"] = this.status;
        if (Array.isArray(this.contacts)) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInvoicePaymentOptionCreateDto {
    invoicePaymentTypeId?: number;
    number?: string;
    holder?: string;
    status?: string;
    contacts?: ContactChildDto[];
}

export class CreateInvoicePaymentOptionCommand extends InvoicePaymentOptionCreateDto implements ICreateInvoicePaymentOptionCommand {

    constructor(data?: ICreateInvoicePaymentOptionCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateInvoicePaymentOptionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoicePaymentOptionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateInvoicePaymentOptionCommand extends IInvoicePaymentOptionCreateDto {
}

export class InvoicePaymentOptionUpdateDto implements IInvoicePaymentOptionUpdateDto {
    id?: number;
    invoicePaymentTypeId?: number;
    number?: string;
    holder?: string;
    status?: string;
    contacts?: ContactChildDto[];

    constructor(data?: IInvoicePaymentOptionUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.invoicePaymentTypeId = _data["invoicePaymentTypeId"];
            this.number = _data["number"];
            this.holder = _data["holder"];
            this.status = _data["status"];
            if (Array.isArray(_data["contacts"])) {
                this.contacts = [] as any;
                for (let item of _data["contacts"])
                    this.contacts!.push(ContactChildDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoicePaymentOptionUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicePaymentOptionUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["invoicePaymentTypeId"] = this.invoicePaymentTypeId;
        data["number"] = this.number;
        data["holder"] = this.holder;
        data["status"] = this.status;
        if (Array.isArray(this.contacts)) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInvoicePaymentOptionUpdateDto {
    id?: number;
    invoicePaymentTypeId?: number;
    number?: string;
    holder?: string;
    status?: string;
    contacts?: ContactChildDto[];
}

export class UpdateInvoicePaymentOptionCommand extends InvoicePaymentOptionUpdateDto implements IUpdateInvoicePaymentOptionCommand {

    constructor(data?: IUpdateInvoicePaymentOptionCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpdateInvoicePaymentOptionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateInvoicePaymentOptionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateInvoicePaymentOptionCommand extends IInvoicePaymentOptionUpdateDto {
}

export class PaginatedListOfOrdersImportedDto implements IPaginatedListOfOrdersImportedDto {
    items?: OrdersImportedDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfOrdersImportedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrdersImportedDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfOrdersImportedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfOrdersImportedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfOrdersImportedDto {
    items?: OrdersImportedDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PedidoTlmkDto implements IPedidoTlmkDto {
    numPedido?: number;
    numPedidoAnterior?: number | undefined;
    numPedidoOriginal?: number | undefined;
    idCurso?: number;
    idWeb?: number;
    nif?: string;
    nombre?: string;
    apellidos?: string;
    direccion?: string;
    codpos?: string;
    provincia?: string;
    pobl?: string;
    pais?: string;
    telefono?: string;
    email?: string;
    fechaPedido?: Date | undefined;
    tipoPago?: string;
    observaciones?: string;
    titulo?: string;
    unidades?: number | undefined;
    precio?: number | undefined;
    sexo?: number;
    web?: string;
    descuento?: string;
    precioFinal?: number | undefined;
    precioMatricula?: number | undefined;
    precioPlazos?: number | undefined;
    nplazos?: number | undefined;
    nacionalidad?: string;
    profesion?: string;
    titulacion?: string;
    universidad?: string;
    teleoperadora?: string;
    ntarjeta?: string;
    tokenPedido?: string;
    ncuenta?: string;
    rematricula?: string;
    empresa?: string;
    refRedsys?: string;
    fechaNacimiento?: Date;
    fechaInicio?: Date | undefined;
    area?: string;
    paisVenta?: string;
    paisMoneda?: string;
    idAvalista?: number | undefined;
    idStudent?: number | undefined;
    intensive?: boolean;
    affiliateCode?: string;
    affiliateComissionPercent?: number | undefined;
    promotionalCode?: string;
    courseCode?: string;
    study?: string;
    programType?: string;
    codigoPedidoRedsys?: string;
    importeCobroRedsys?: number;
    plataformaPago?: string;
    duracion?: string;
    fechaFin?: Date | undefined;
    creditos?: number;
    primerPagoEUR?: number | undefined;
    primerPago?: number | undefined;
    divisaPrimerPago?: string | undefined;
    ratio?: number | undefined;
    idFactura?: number | undefined;
    politicasPrivacidadAceptadas?: boolean | undefined;
    condicionesContratacionAceptadas?: boolean | undefined;
    isRenewal?: boolean;
    importeRenovacion?: number | undefined;
    numPedidoOrigen?: number | undefined;
    clientNotificationsSent?: boolean | undefined;
    isEnrollmentUpload?: boolean | undefined;
    durationCourseInDays?: number;
    idPago?: number | undefined;
    idIdioma?: number | undefined;
    idioma?: string | undefined;
    tituloIdioma?: string | undefined;
    areaIdioma?: string | undefined;
    estudioIdioma?: string | undefined;
    processId?: number | undefined;

    constructor(data?: IPedidoTlmkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.numPedido = _data["numPedido"];
            this.numPedidoAnterior = _data["numPedidoAnterior"];
            this.numPedidoOriginal = _data["numPedidoOriginal"];
            this.idCurso = _data["idCurso"];
            this.idWeb = _data["idWeb"];
            this.nif = _data["nif"];
            this.nombre = _data["nombre"];
            this.apellidos = _data["apellidos"];
            this.direccion = _data["direccion"];
            this.codpos = _data["codpos"];
            this.provincia = _data["provincia"];
            this.pobl = _data["pobl"];
            this.pais = _data["pais"];
            this.telefono = _data["telefono"];
            this.email = _data["email"];
            this.fechaPedido = _data["fechaPedido"] ? new Date(_data["fechaPedido"].toString()) : <any>undefined;
            this.tipoPago = _data["tipoPago"];
            this.observaciones = _data["observaciones"];
            this.titulo = _data["titulo"];
            this.unidades = _data["unidades"];
            this.precio = _data["precio"];
            this.sexo = _data["sexo"];
            this.web = _data["web"];
            this.descuento = _data["descuento"];
            this.precioFinal = _data["precioFinal"];
            this.precioMatricula = _data["precioMatricula"];
            this.precioPlazos = _data["precioPlazos"];
            this.nplazos = _data["nplazos"];
            this.nacionalidad = _data["nacionalidad"];
            this.profesion = _data["profesion"];
            this.titulacion = _data["titulacion"];
            this.universidad = _data["universidad"];
            this.teleoperadora = _data["teleoperadora"];
            this.ntarjeta = _data["ntarjeta"];
            this.tokenPedido = _data["tokenPedido"];
            this.ncuenta = _data["ncuenta"];
            this.rematricula = _data["rematricula"];
            this.empresa = _data["empresa"];
            this.refRedsys = _data["refRedsys"];
            this.fechaNacimiento = _data["fechaNacimiento"] ? new Date(_data["fechaNacimiento"].toString()) : <any>undefined;
            this.fechaInicio = _data["fechaInicio"] ? new Date(_data["fechaInicio"].toString()) : <any>undefined;
            this.area = _data["area"];
            this.paisVenta = _data["paisVenta"];
            this.paisMoneda = _data["paisMoneda"];
            this.idAvalista = _data["idAvalista"];
            this.idStudent = _data["idStudent"];
            this.intensive = _data["intensive"];
            this.affiliateCode = _data["affiliateCode"];
            this.affiliateComissionPercent = _data["affiliateComissionPercent"];
            this.promotionalCode = _data["promotionalCode"];
            this.courseCode = _data["courseCode"];
            this.study = _data["study"];
            this.programType = _data["programType"];
            this.codigoPedidoRedsys = _data["codigoPedidoRedsys"];
            this.importeCobroRedsys = _data["importeCobroRedsys"];
            this.plataformaPago = _data["plataformaPago"];
            this.duracion = _data["duracion"];
            this.fechaFin = _data["fechaFin"] ? new Date(_data["fechaFin"].toString()) : <any>undefined;
            this.creditos = _data["creditos"];
            this.primerPagoEUR = _data["primerPagoEUR"];
            this.primerPago = _data["primerPago"];
            this.divisaPrimerPago = _data["divisaPrimerPago"];
            this.ratio = _data["ratio"];
            this.idFactura = _data["idFactura"];
            this.politicasPrivacidadAceptadas = _data["politicasPrivacidadAceptadas"];
            this.condicionesContratacionAceptadas = _data["condicionesContratacionAceptadas"];
            this.isRenewal = _data["isRenewal"];
            this.importeRenovacion = _data["importeRenovacion"];
            this.numPedidoOrigen = _data["numPedidoOrigen"];
            this.clientNotificationsSent = _data["clientNotificationsSent"];
            this.isEnrollmentUpload = _data["isEnrollmentUpload"];
            this.durationCourseInDays = _data["durationCourseInDays"];
            this.idPago = _data["idPago"];
            this.idIdioma = _data["idIdioma"];
            this.idioma = _data["idioma"];
            this.tituloIdioma = _data["tituloIdioma"];
            this.areaIdioma = _data["areaIdioma"];
            this.estudioIdioma = _data["estudioIdioma"];
            this.processId = _data["processId"];
        }
    }

    static fromJS(data: any): PedidoTlmkDto {
        data = typeof data === 'object' ? data : {};
        let result = new PedidoTlmkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["numPedido"] = this.numPedido;
        data["numPedidoAnterior"] = this.numPedidoAnterior;
        data["numPedidoOriginal"] = this.numPedidoOriginal;
        data["idCurso"] = this.idCurso;
        data["idWeb"] = this.idWeb;
        data["nif"] = this.nif;
        data["nombre"] = this.nombre;
        data["apellidos"] = this.apellidos;
        data["direccion"] = this.direccion;
        data["codpos"] = this.codpos;
        data["provincia"] = this.provincia;
        data["pobl"] = this.pobl;
        data["pais"] = this.pais;
        data["telefono"] = this.telefono;
        data["email"] = this.email;
        data["fechaPedido"] = this.fechaPedido ? this.fechaPedido.toISOString() : <any>undefined;
        data["tipoPago"] = this.tipoPago;
        data["observaciones"] = this.observaciones;
        data["titulo"] = this.titulo;
        data["unidades"] = this.unidades;
        data["precio"] = this.precio;
        data["sexo"] = this.sexo;
        data["web"] = this.web;
        data["descuento"] = this.descuento;
        data["precioFinal"] = this.precioFinal;
        data["precioMatricula"] = this.precioMatricula;
        data["precioPlazos"] = this.precioPlazos;
        data["nplazos"] = this.nplazos;
        data["nacionalidad"] = this.nacionalidad;
        data["profesion"] = this.profesion;
        data["titulacion"] = this.titulacion;
        data["universidad"] = this.universidad;
        data["teleoperadora"] = this.teleoperadora;
        data["ntarjeta"] = this.ntarjeta;
        data["tokenPedido"] = this.tokenPedido;
        data["ncuenta"] = this.ncuenta;
        data["rematricula"] = this.rematricula;
        data["empresa"] = this.empresa;
        data["refRedsys"] = this.refRedsys;
        data["fechaNacimiento"] = this.fechaNacimiento ? this.fechaNacimiento.toISOString() : <any>undefined;
        data["fechaInicio"] = this.fechaInicio ? this.fechaInicio.toISOString() : <any>undefined;
        data["area"] = this.area;
        data["paisVenta"] = this.paisVenta;
        data["paisMoneda"] = this.paisMoneda;
        data["idAvalista"] = this.idAvalista;
        data["idStudent"] = this.idStudent;
        data["intensive"] = this.intensive;
        data["affiliateCode"] = this.affiliateCode;
        data["affiliateComissionPercent"] = this.affiliateComissionPercent;
        data["promotionalCode"] = this.promotionalCode;
        data["courseCode"] = this.courseCode;
        data["study"] = this.study;
        data["programType"] = this.programType;
        data["codigoPedidoRedsys"] = this.codigoPedidoRedsys;
        data["importeCobroRedsys"] = this.importeCobroRedsys;
        data["plataformaPago"] = this.plataformaPago;
        data["duracion"] = this.duracion;
        data["fechaFin"] = this.fechaFin ? this.fechaFin.toISOString() : <any>undefined;
        data["creditos"] = this.creditos;
        data["primerPagoEUR"] = this.primerPagoEUR;
        data["primerPago"] = this.primerPago;
        data["divisaPrimerPago"] = this.divisaPrimerPago;
        data["ratio"] = this.ratio;
        data["idFactura"] = this.idFactura;
        data["politicasPrivacidadAceptadas"] = this.politicasPrivacidadAceptadas;
        data["condicionesContratacionAceptadas"] = this.condicionesContratacionAceptadas;
        data["isRenewal"] = this.isRenewal;
        data["importeRenovacion"] = this.importeRenovacion;
        data["numPedidoOrigen"] = this.numPedidoOrigen;
        data["clientNotificationsSent"] = this.clientNotificationsSent;
        data["isEnrollmentUpload"] = this.isEnrollmentUpload;
        data["durationCourseInDays"] = this.durationCourseInDays;
        data["idPago"] = this.idPago;
        data["idIdioma"] = this.idIdioma;
        data["idioma"] = this.idioma;
        data["tituloIdioma"] = this.tituloIdioma;
        data["areaIdioma"] = this.areaIdioma;
        data["estudioIdioma"] = this.estudioIdioma;
        data["processId"] = this.processId;
        return data;
    }
}

export interface IPedidoTlmkDto {
    numPedido?: number;
    numPedidoAnterior?: number | undefined;
    numPedidoOriginal?: number | undefined;
    idCurso?: number;
    idWeb?: number;
    nif?: string;
    nombre?: string;
    apellidos?: string;
    direccion?: string;
    codpos?: string;
    provincia?: string;
    pobl?: string;
    pais?: string;
    telefono?: string;
    email?: string;
    fechaPedido?: Date | undefined;
    tipoPago?: string;
    observaciones?: string;
    titulo?: string;
    unidades?: number | undefined;
    precio?: number | undefined;
    sexo?: number;
    web?: string;
    descuento?: string;
    precioFinal?: number | undefined;
    precioMatricula?: number | undefined;
    precioPlazos?: number | undefined;
    nplazos?: number | undefined;
    nacionalidad?: string;
    profesion?: string;
    titulacion?: string;
    universidad?: string;
    teleoperadora?: string;
    ntarjeta?: string;
    tokenPedido?: string;
    ncuenta?: string;
    rematricula?: string;
    empresa?: string;
    refRedsys?: string;
    fechaNacimiento?: Date;
    fechaInicio?: Date | undefined;
    area?: string;
    paisVenta?: string;
    paisMoneda?: string;
    idAvalista?: number | undefined;
    idStudent?: number | undefined;
    intensive?: boolean;
    affiliateCode?: string;
    affiliateComissionPercent?: number | undefined;
    promotionalCode?: string;
    courseCode?: string;
    study?: string;
    programType?: string;
    codigoPedidoRedsys?: string;
    importeCobroRedsys?: number;
    plataformaPago?: string;
    duracion?: string;
    fechaFin?: Date | undefined;
    creditos?: number;
    primerPagoEUR?: number | undefined;
    primerPago?: number | undefined;
    divisaPrimerPago?: string | undefined;
    ratio?: number | undefined;
    idFactura?: number | undefined;
    politicasPrivacidadAceptadas?: boolean | undefined;
    condicionesContratacionAceptadas?: boolean | undefined;
    isRenewal?: boolean;
    importeRenovacion?: number | undefined;
    numPedidoOrigen?: number | undefined;
    clientNotificationsSent?: boolean | undefined;
    isEnrollmentUpload?: boolean | undefined;
    durationCourseInDays?: number;
    idPago?: number | undefined;
    idIdioma?: number | undefined;
    idioma?: string | undefined;
    tituloIdioma?: string | undefined;
    areaIdioma?: string | undefined;
    estudioIdioma?: string | undefined;
    processId?: number | undefined;
}

export class CreateOrdersImportedFromTlmkCommand extends PedidoTlmkDto implements ICreateOrdersImportedFromTlmkCommand {
    apiKey?: string;

    constructor(data?: ICreateOrdersImportedFromTlmkCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.apiKey = _data["apiKey"];
        }
    }

    static fromJS(data: any): CreateOrdersImportedFromTlmkCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrdersImportedFromTlmkCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["apiKey"] = this.apiKey;
        super.toJSON(data);
        return data;
    }
}

export interface ICreateOrdersImportedFromTlmkCommand extends IPedidoTlmkDto {
    apiKey?: string;
}

export class SetProcessStatusByOrderNumberCommand implements ISetProcessStatusByOrderNumberCommand {
    orderNumber?: number;
    status?: ProcessStatus;
    outcome?: ProcessOutcome;
    paymentType?: string;

    constructor(data?: ISetProcessStatusByOrderNumberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNumber = _data["orderNumber"];
            this.status = _data["status"];
            this.outcome = _data["outcome"];
            this.paymentType = _data["paymentType"];
        }
    }

    static fromJS(data: any): SetProcessStatusByOrderNumberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetProcessStatusByOrderNumberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNumber"] = this.orderNumber;
        data["status"] = this.status;
        data["outcome"] = this.outcome;
        data["paymentType"] = this.paymentType;
        return data;
    }
}

export interface ISetProcessStatusByOrderNumberCommand {
    orderNumber?: number;
    status?: ProcessStatus;
    outcome?: ProcessOutcome;
    paymentType?: string;
}

export enum ProcessStatus {
    Ongoing = "ongoing",
    Pending = "pending",
    Closed = "closed",
    ToDo = "todo",
}

export enum ProcessOutcome {
    Open = "open",
    Sale = "sale",
    NotSale = "notsale",
    Resolved = "resolved",
    NotResolved = "notresolved",
    PaymentMethodPending = "paymentmethodpending",
    Pending = "pending",
    NotValid = "notvalid",
}

export class DeleteOrderImportedFromTlmkByEmailCommand implements IDeleteOrderImportedFromTlmkByEmailCommand {
    emails?: string[];

    constructor(data?: IDeleteOrderImportedFromTlmkByEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["emails"])) {
                this.emails = [] as any;
                for (let item of _data["emails"])
                    this.emails!.push(item);
            }
        }
    }

    static fromJS(data: any): DeleteOrderImportedFromTlmkByEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteOrderImportedFromTlmkByEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.emails)) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        return data;
    }
}

export interface IDeleteOrderImportedFromTlmkByEmailCommand {
    emails?: string[];
}

export class PaginatedListOfProcessInProgressDto implements IPaginatedListOfProcessInProgressDto {
    items?: ProcessInProgressDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProcessInProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProcessInProgressDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProcessInProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProcessInProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProcessInProgressDto {
    items?: ProcessInProgressDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProcessInProgressDto implements IProcessInProgressDto {
    processId?: number;
    contactId?: number;
    userId?: number | undefined;
    colour?: string | undefined;
    created?: Date | undefined;
    initialDate?: Date | undefined;
    lastActionDate?: Date | undefined;
    nextInteractionDate?: Date;
    contactInProgressDto?: ContactInProgressDto | undefined;
    type?: string;
    status?: string;
    activeCall?: boolean;
    attempts?: number;

    constructor(data?: IProcessInProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processId = _data["processId"];
            this.contactId = _data["contactId"];
            this.userId = _data["userId"];
            this.colour = _data["colour"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.initialDate = _data["initialDate"] ? new Date(_data["initialDate"].toString()) : <any>undefined;
            this.lastActionDate = _data["lastActionDate"] ? new Date(_data["lastActionDate"].toString()) : <any>undefined;
            this.nextInteractionDate = _data["nextInteractionDate"] ? new Date(_data["nextInteractionDate"].toString()) : <any>undefined;
            this.contactInProgressDto = _data["contactInProgressDto"] ? ContactInProgressDto.fromJS(_data["contactInProgressDto"]) : <any>undefined;
            this.type = _data["type"];
            this.status = _data["status"];
            this.activeCall = _data["activeCall"];
            this.attempts = _data["attempts"];
        }
    }

    static fromJS(data: any): ProcessInProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessInProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processId"] = this.processId;
        data["contactId"] = this.contactId;
        data["userId"] = this.userId;
        data["colour"] = this.colour;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["initialDate"] = this.initialDate ? this.initialDate.toISOString() : <any>undefined;
        data["lastActionDate"] = this.lastActionDate ? this.lastActionDate.toISOString() : <any>undefined;
        data["nextInteractionDate"] = this.nextInteractionDate ? this.nextInteractionDate.toISOString() : <any>undefined;
        data["contactInProgressDto"] = this.contactInProgressDto ? this.contactInProgressDto.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["status"] = this.status;
        data["activeCall"] = this.activeCall;
        data["attempts"] = this.attempts;
        return data;
    }
}

export interface IProcessInProgressDto {
    processId?: number;
    contactId?: number;
    userId?: number | undefined;
    colour?: string | undefined;
    created?: Date | undefined;
    initialDate?: Date | undefined;
    lastActionDate?: Date | undefined;
    nextInteractionDate?: Date;
    contactInProgressDto?: ContactInProgressDto | undefined;
    type?: string;
    status?: string;
    activeCall?: boolean;
    attempts?: number;
}

export class ContactInProgressDto implements IContactInProgressDto {
    name?: string | undefined;
    firstSurname?: string | undefined;
    secondSurname?: string | undefined;
    idCard?: string | undefined;
    nationality?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    workCenter?: string | undefined;
    faculties?: FacultiesInProgressDto[] | undefined;
    specialities?: SpecialitiesInProgressDto[] | undefined;

    constructor(data?: IContactInProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.firstSurname = _data["firstSurname"];
            this.secondSurname = _data["secondSurname"];
            this.idCard = _data["idCard"];
            this.nationality = _data["nationality"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.workCenter = _data["workCenter"];
            if (Array.isArray(_data["faculties"])) {
                this.faculties = [] as any;
                for (let item of _data["faculties"])
                    this.faculties!.push(FacultiesInProgressDto.fromJS(item));
            }
            if (Array.isArray(_data["specialities"])) {
                this.specialities = [] as any;
                for (let item of _data["specialities"])
                    this.specialities!.push(SpecialitiesInProgressDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContactInProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactInProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["firstSurname"] = this.firstSurname;
        data["secondSurname"] = this.secondSurname;
        data["idCard"] = this.idCard;
        data["nationality"] = this.nationality;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["workCenter"] = this.workCenter;
        if (Array.isArray(this.faculties)) {
            data["faculties"] = [];
            for (let item of this.faculties)
                data["faculties"].push(item.toJSON());
        }
        if (Array.isArray(this.specialities)) {
            data["specialities"] = [];
            for (let item of this.specialities)
                data["specialities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContactInProgressDto {
    name?: string | undefined;
    firstSurname?: string | undefined;
    secondSurname?: string | undefined;
    idCard?: string | undefined;
    nationality?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    workCenter?: string | undefined;
    faculties?: FacultiesInProgressDto[] | undefined;
    specialities?: SpecialitiesInProgressDto[] | undefined;
}

export class FacultiesInProgressDto implements IFacultiesInProgressDto {
    color?: string | undefined;
    name?: string | undefined;
    seoUrl?: string | undefined;

    constructor(data?: IFacultiesInProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.color = _data["color"];
            this.name = _data["name"];
            this.seoUrl = _data["seoUrl"];
        }
    }

    static fromJS(data: any): FacultiesInProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new FacultiesInProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["color"] = this.color;
        data["name"] = this.name;
        data["seoUrl"] = this.seoUrl;
        return data;
    }
}

export interface IFacultiesInProgressDto {
    color?: string | undefined;
    name?: string | undefined;
    seoUrl?: string | undefined;
}

export class SpecialitiesInProgressDto implements ISpecialitiesInProgressDto {
    name?: string | undefined;
    seoUrl?: string | undefined;

    constructor(data?: ISpecialitiesInProgressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.seoUrl = _data["seoUrl"];
        }
    }

    static fromJS(data: any): SpecialitiesInProgressDto {
        data = typeof data === 'object' ? data : {};
        let result = new SpecialitiesInProgressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["seoUrl"] = this.seoUrl;
        return data;
    }
}

export interface ISpecialitiesInProgressDto {
    name?: string | undefined;
    seoUrl?: string | undefined;
}

export class PaginatedListOfProcessDto implements IPaginatedListOfProcessDto {
    items?: ProcessDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfProcessDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProcessDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfProcessDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfProcessDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfProcessDto {
    items?: ProcessDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProcessTypeDto implements IProcessTypeDto {
    label?: string;
    value?: string;

    constructor(data?: IProcessTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ProcessTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data;
    }
}

export interface IProcessTypeDto {
    label?: string;
    value?: string;
}

export class ProcessSaleStatusDto implements IProcessSaleStatusDto {
    saleComplete?: boolean;

    constructor(data?: IProcessSaleStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saleComplete = _data["saleComplete"];
        }
    }

    static fromJS(data: any): ProcessSaleStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessSaleStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleComplete"] = this.saleComplete;
        return data;
    }
}

export interface IProcessSaleStatusDto {
    saleComplete?: boolean;
}

export class ProcessSaleAttemtpsDto implements IProcessSaleAttemtpsDto {
    saleAttemtps?: number;

    constructor(data?: IProcessSaleAttemtpsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.saleAttemtps = _data["saleAttemtps"];
        }
    }

    static fromJS(data: any): ProcessSaleAttemtpsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessSaleAttemtpsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["saleAttemtps"] = this.saleAttemtps;
        return data;
    }
}

export interface IProcessSaleAttemtpsDto {
    saleAttemtps?: number;
}

export class ProcessCreateDto implements IProcessCreateDto {
    guid?: string;
    userId?: number;
    contactId?: number;
    type?: string;
    status?: string;
    processOrigin?: string;
    outcome?: string;
    description?: string;
    colour?: string | undefined;
    actions?: ActionDto[];
    university?: University;

    constructor(data?: IProcessCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.processOrigin = _data["processOrigin"];
            this.outcome = _data["outcome"];
            this.description = _data["description"];
            this.colour = _data["colour"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(ActionDto.fromJS(item));
            }
            this.university = _data["university"];
        }
    }

    static fromJS(data: any): ProcessCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["type"] = this.type;
        data["status"] = this.status;
        data["processOrigin"] = this.processOrigin;
        data["outcome"] = this.outcome;
        data["description"] = this.description;
        data["colour"] = this.colour;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        data["university"] = this.university;
        return data;
    }
}

export interface IProcessCreateDto {
    guid?: string;
    userId?: number;
    contactId?: number;
    type?: string;
    status?: string;
    processOrigin?: string;
    outcome?: string;
    description?: string;
    colour?: string | undefined;
    actions?: ActionDto[];
    university?: University;
}

export class CreateProcessCommand extends ProcessCreateDto implements ICreateProcessCommand {

    constructor(data?: ICreateProcessCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateProcessCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProcessCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProcessCommand extends IProcessCreateDto {
}

export class ActionDto implements IActionDto {
    id?: number;
    userId?: number | undefined;
    contactId?: number;
    processId?: number | undefined;
    ordersImportedId?: number | undefined;
    user?: UserDto;
    contact?: ContactDto;
    process?: ProcessChildDto;
    ordersImported?: OrdersImportedChildDto;
    date?: Date;
    finishDate?: Date | undefined;
    type?: string;
    outcome?: string;
    email?: EmailActionDto;
    appointments?: AppointmentChildDto[];

    constructor(data?: IActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
            this.ordersImportedId = _data["ordersImportedId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.contact = _data["contact"] ? ContactDto.fromJS(_data["contact"]) : <any>undefined;
            this.process = _data["process"] ? ProcessChildDto.fromJS(_data["process"]) : <any>undefined;
            this.ordersImported = _data["ordersImported"] ? OrdersImportedChildDto.fromJS(_data["ordersImported"]) : <any>undefined;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.finishDate = _data["finishDate"] ? new Date(_data["finishDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.outcome = _data["outcome"];
            this.email = _data["email"] ? EmailActionDto.fromJS(_data["email"]) : <any>undefined;
            if (Array.isArray(_data["appointments"])) {
                this.appointments = [] as any;
                for (let item of _data["appointments"])
                    this.appointments!.push(AppointmentChildDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        data["ordersImportedId"] = this.ordersImportedId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["process"] = this.process ? this.process.toJSON() : <any>undefined;
        data["ordersImported"] = this.ordersImported ? this.ordersImported.toJSON() : <any>undefined;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["finishDate"] = this.finishDate ? this.finishDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["outcome"] = this.outcome;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        if (Array.isArray(this.appointments)) {
            data["appointments"] = [];
            for (let item of this.appointments)
                data["appointments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IActionDto {
    id?: number;
    userId?: number | undefined;
    contactId?: number;
    processId?: number | undefined;
    ordersImportedId?: number | undefined;
    user?: UserDto;
    contact?: ContactDto;
    process?: ProcessChildDto;
    ordersImported?: OrdersImportedChildDto;
    date?: Date;
    finishDate?: Date | undefined;
    type?: string;
    outcome?: string;
    email?: EmailActionDto;
    appointments?: AppointmentChildDto[];
}

export class EmailActionDto implements IEmailActionDto {
    id?: number;
    userId?: number | undefined;
    user?: UserDto;
    from?: string;
    fromName?: string;
    to?: string;
    cc?: string;
    subject?: string;
    message?: string;

    constructor(data?: IEmailActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.from = _data["from"];
            this.fromName = _data["fromName"];
            this.to = _data["to"];
            this.cc = _data["cc"];
            this.subject = _data["subject"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): EmailActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["from"] = this.from;
        data["fromName"] = this.fromName;
        data["to"] = this.to;
        data["cc"] = this.cc;
        data["subject"] = this.subject;
        data["message"] = this.message;
        return data;
    }
}

export interface IEmailActionDto {
    id?: number;
    userId?: number | undefined;
    user?: UserDto;
    from?: string;
    fromName?: string;
    to?: string;
    cc?: string;
    subject?: string;
    message?: string;
}

export class SetWebSaleProcessByEmailOrPhoneOrDniCommand implements ISetWebSaleProcessByEmailOrPhoneOrDniCommand {
    email?: string | undefined;
    phone?: string | undefined;
    dni?: string | undefined;

    constructor(data?: ISetWebSaleProcessByEmailOrPhoneOrDniCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.dni = _data["dni"];
        }
    }

    static fromJS(data: any): SetWebSaleProcessByEmailOrPhoneOrDniCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetWebSaleProcessByEmailOrPhoneOrDniCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["dni"] = this.dni;
        return data;
    }
}

export interface ISetWebSaleProcessByEmailOrPhoneOrDniCommand {
    email?: string | undefined;
    phone?: string | undefined;
    dni?: string | undefined;
}

export class ProcessUpdateDto implements IProcessUpdateDto {
    id?: number;
    userId?: number;
    contactId?: number;
    type?: string;
    status?: string;
    outcome?: string;
    description?: string | undefined;
    colour?: string;
    discardReasonId?: number | undefined;
    discardReasonObservations?: string | undefined;
    university?: University;

    constructor(data?: IProcessUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.contactId = _data["contactId"];
            this.type = _data["type"];
            this.status = _data["status"];
            this.outcome = _data["outcome"];
            this.description = _data["description"];
            this.colour = _data["colour"];
            this.discardReasonId = _data["discardReasonId"];
            this.discardReasonObservations = _data["discardReasonObservations"];
            this.university = _data["university"];
        }
    }

    static fromJS(data: any): ProcessUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["contactId"] = this.contactId;
        data["type"] = this.type;
        data["status"] = this.status;
        data["outcome"] = this.outcome;
        data["description"] = this.description;
        data["colour"] = this.colour;
        data["discardReasonId"] = this.discardReasonId;
        data["discardReasonObservations"] = this.discardReasonObservations;
        data["university"] = this.university;
        return data;
    }
}

export interface IProcessUpdateDto {
    id?: number;
    userId?: number;
    contactId?: number;
    type?: string;
    status?: string;
    outcome?: string;
    description?: string | undefined;
    colour?: string;
    discardReasonId?: number | undefined;
    discardReasonObservations?: string | undefined;
    university?: University;
}

export class UpdateProcessCommand extends ProcessUpdateDto implements IUpdateProcessCommand {

    constructor(data?: IUpdateProcessCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpdateProcessCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProcessCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProcessCommand extends IProcessUpdateDto {
}

export class OrderImportedUpdateDto implements IOrderImportedUpdateDto {
    orderNumber?: number;
    processId?: number | undefined;
    email?: string | undefined;
    nif?: string | undefined;
    status?: string | undefined;
    paymentType?: string | undefined;
    paymentDate?: Date | undefined;
    terminationDate?: Date | undefined;

    constructor(data?: IOrderImportedUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNumber = _data["orderNumber"];
            this.processId = _data["processId"];
            this.email = _data["email"];
            this.nif = _data["nif"];
            this.status = _data["status"];
            this.paymentType = _data["paymentType"];
            this.paymentDate = _data["paymentDate"] ? new Date(_data["paymentDate"].toString()) : <any>undefined;
            this.terminationDate = _data["terminationDate"] ? new Date(_data["terminationDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderImportedUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderImportedUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNumber"] = this.orderNumber;
        data["processId"] = this.processId;
        data["email"] = this.email;
        data["nif"] = this.nif;
        data["status"] = this.status;
        data["paymentType"] = this.paymentType;
        data["paymentDate"] = this.paymentDate ? this.paymentDate.toISOString() : <any>undefined;
        data["terminationDate"] = this.terminationDate ? this.terminationDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface IOrderImportedUpdateDto {
    orderNumber?: number;
    processId?: number | undefined;
    email?: string | undefined;
    nif?: string | undefined;
    status?: string | undefined;
    paymentType?: string | undefined;
    paymentDate?: Date | undefined;
    terminationDate?: Date | undefined;
}

export class ReassignProcessCommand implements IReassignProcessCommand {
    processId?: number;
    userId?: number;

    constructor(data?: IReassignProcessCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processId = _data["processId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ReassignProcessCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ReassignProcessCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processId"] = this.processId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IReassignProcessCommand {
    processId?: number;
    userId?: number;
}

export class ExternalSaleDto implements IExternalSaleDto {
    contactId?: number;
    processId?: number;
    studentName?: string | undefined;
    idCard?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    country?: string | undefined;
    province?: string | undefined;
    postalCode?: string | undefined;
    city?: string | undefined;
    orderNumber?: number;
    orderDate?: Date | undefined;
    academicTitle?: string | undefined;
    initDate?: Date | undefined;
    paymentType?: string | undefined;
    currencyCountry?: string | undefined;
    numberDeadLines?: number | undefined;
    salesCountry?: string | undefined;
    amountRegistration?: number | undefined;

    constructor(data?: IExternalSaleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.processId = _data["processId"];
            this.studentName = _data["studentName"];
            this.idCard = _data["idCard"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.country = _data["country"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.city = _data["city"];
            this.orderNumber = _data["orderNumber"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : <any>undefined;
            this.academicTitle = _data["academicTitle"];
            this.initDate = _data["initDate"] ? new Date(_data["initDate"].toString()) : <any>undefined;
            this.paymentType = _data["paymentType"];
            this.currencyCountry = _data["currencyCountry"];
            this.numberDeadLines = _data["numberDeadLines"];
            this.salesCountry = _data["salesCountry"];
            this.amountRegistration = _data["amountRegistration"];
        }
    }

    static fromJS(data: any): ExternalSaleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalSaleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["processId"] = this.processId;
        data["studentName"] = this.studentName;
        data["idCard"] = this.idCard;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["country"] = this.country;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["orderNumber"] = this.orderNumber;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["academicTitle"] = this.academicTitle;
        data["initDate"] = this.initDate ? this.initDate.toISOString() : <any>undefined;
        data["paymentType"] = this.paymentType;
        data["currencyCountry"] = this.currencyCountry;
        data["numberDeadLines"] = this.numberDeadLines;
        data["salesCountry"] = this.salesCountry;
        data["amountRegistration"] = this.amountRegistration;
        return data;
    }
}

export interface IExternalSaleDto {
    contactId?: number;
    processId?: number;
    studentName?: string | undefined;
    idCard?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    address?: string | undefined;
    country?: string | undefined;
    province?: string | undefined;
    postalCode?: string | undefined;
    city?: string | undefined;
    orderNumber?: number;
    orderDate?: Date | undefined;
    academicTitle?: string | undefined;
    initDate?: Date | undefined;
    paymentType?: string | undefined;
    currencyCountry?: string | undefined;
    numberDeadLines?: number | undefined;
    salesCountry?: string | undefined;
    amountRegistration?: number | undefined;
}

export class ExternalSuccessfulSaleProcessCommand extends ExternalSaleDto implements IExternalSuccessfulSaleProcessCommand {

    constructor(data?: IExternalSuccessfulSaleProcessCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): ExternalSuccessfulSaleProcessCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalSuccessfulSaleProcessCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IExternalSuccessfulSaleProcessCommand extends IExternalSaleDto {
}

export class PaginatedListOfTemplateProposalDto implements IPaginatedListOfTemplateProposalDto {
    items?: TemplateProposalDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTemplateProposalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TemplateProposalDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTemplateProposalDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTemplateProposalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTemplateProposalDto {
    items?: TemplateProposalDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TemplateProposalDto implements ITemplateProposalDto {
    id?: number;
    name?: string | undefined;
    processType?: ProcessType;
    day?: number;
    attempt?: number;
    colour?: Colour;
    courseKnown?: boolean;
    courseTypeId?: number | undefined;
    hasToSendEmail?: boolean;
    hasToSendWhatsApp?: boolean;
    tagId?: number | undefined;
    team?: string | undefined;

    constructor(data?: ITemplateProposalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.processType = _data["processType"];
            this.day = _data["day"];
            this.attempt = _data["attempt"];
            this.colour = _data["colour"];
            this.courseKnown = _data["courseKnown"];
            this.courseTypeId = _data["courseTypeId"];
            this.hasToSendEmail = _data["hasToSendEmail"];
            this.hasToSendWhatsApp = _data["hasToSendWhatsApp"];
            this.tagId = _data["tagId"];
            this.team = _data["team"];
        }
    }

    static fromJS(data: any): TemplateProposalDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateProposalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["processType"] = this.processType;
        data["day"] = this.day;
        data["attempt"] = this.attempt;
        data["colour"] = this.colour;
        data["courseKnown"] = this.courseKnown;
        data["courseTypeId"] = this.courseTypeId;
        data["hasToSendEmail"] = this.hasToSendEmail;
        data["hasToSendWhatsApp"] = this.hasToSendWhatsApp;
        data["tagId"] = this.tagId;
        data["team"] = this.team;
        return data;
    }
}

export interface ITemplateProposalDto {
    id?: number;
    name?: string | undefined;
    processType?: ProcessType;
    day?: number;
    attempt?: number;
    colour?: Colour;
    courseKnown?: boolean;
    courseTypeId?: number | undefined;
    hasToSendEmail?: boolean;
    hasToSendWhatsApp?: boolean;
    tagId?: number | undefined;
    team?: string | undefined;
}

export class TemplateProposalCreateDto implements ITemplateProposalCreateDto {
    name?: string | undefined;
    processType?: ProcessType;
    day?: number;
    attempt?: number;
    colour?: Colour;
    courseKnown?: boolean;
    courseTypeId?: number | undefined;
    hasToSendEmail?: boolean;
    hasToSendWhatsApp?: boolean;
    tagId?: number | undefined;

    constructor(data?: ITemplateProposalCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.processType = _data["processType"];
            this.day = _data["day"];
            this.attempt = _data["attempt"];
            this.colour = _data["colour"];
            this.courseKnown = _data["courseKnown"];
            this.courseTypeId = _data["courseTypeId"];
            this.hasToSendEmail = _data["hasToSendEmail"];
            this.hasToSendWhatsApp = _data["hasToSendWhatsApp"];
            this.tagId = _data["tagId"];
        }
    }

    static fromJS(data: any): TemplateProposalCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateProposalCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["processType"] = this.processType;
        data["day"] = this.day;
        data["attempt"] = this.attempt;
        data["colour"] = this.colour;
        data["courseKnown"] = this.courseKnown;
        data["courseTypeId"] = this.courseTypeId;
        data["hasToSendEmail"] = this.hasToSendEmail;
        data["hasToSendWhatsApp"] = this.hasToSendWhatsApp;
        data["tagId"] = this.tagId;
        return data;
    }
}

export interface ITemplateProposalCreateDto {
    name?: string | undefined;
    processType?: ProcessType;
    day?: number;
    attempt?: number;
    colour?: Colour;
    courseKnown?: boolean;
    courseTypeId?: number | undefined;
    hasToSendEmail?: boolean;
    hasToSendWhatsApp?: boolean;
    tagId?: number | undefined;
}

export class CreateTemplateProposalCommand extends TemplateProposalCreateDto implements ICreateTemplateProposalCommand {

    constructor(data?: ICreateTemplateProposalCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateTemplateProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTemplateProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateTemplateProposalCommand extends ITemplateProposalCreateDto {
}

export class TemplateProposalUpdateDto implements ITemplateProposalUpdateDto {
    id?: number;
    name?: string | undefined;
    processType?: ProcessType;
    day?: number;
    attempt?: number;
    colour?: Colour;
    courseKnown?: boolean;
    courseTypeId?: number | undefined;
    hasToSendEmail?: boolean;
    hasToSendWhatsApp?: boolean;
    tagId?: number | undefined;

    constructor(data?: ITemplateProposalUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.processType = _data["processType"];
            this.day = _data["day"];
            this.attempt = _data["attempt"];
            this.colour = _data["colour"];
            this.courseKnown = _data["courseKnown"];
            this.courseTypeId = _data["courseTypeId"];
            this.hasToSendEmail = _data["hasToSendEmail"];
            this.hasToSendWhatsApp = _data["hasToSendWhatsApp"];
            this.tagId = _data["tagId"];
        }
    }

    static fromJS(data: any): TemplateProposalUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateProposalUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["processType"] = this.processType;
        data["day"] = this.day;
        data["attempt"] = this.attempt;
        data["colour"] = this.colour;
        data["courseKnown"] = this.courseKnown;
        data["courseTypeId"] = this.courseTypeId;
        data["hasToSendEmail"] = this.hasToSendEmail;
        data["hasToSendWhatsApp"] = this.hasToSendWhatsApp;
        data["tagId"] = this.tagId;
        return data;
    }
}

export interface ITemplateProposalUpdateDto {
    id?: number;
    name?: string | undefined;
    processType?: ProcessType;
    day?: number;
    attempt?: number;
    colour?: Colour;
    courseKnown?: boolean;
    courseTypeId?: number | undefined;
    hasToSendEmail?: boolean;
    hasToSendWhatsApp?: boolean;
    tagId?: number | undefined;
}

export class UpdateTemplateProposalCommand extends TemplateProposalUpdateDto implements IUpdateTemplateProposalCommand {

    constructor(data?: IUpdateTemplateProposalCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpdateTemplateProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTemplateProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateTemplateProposalCommand extends ITemplateProposalUpdateDto {
}

export class TemplateProposalTemplateDto implements ITemplateProposalTemplateDto {
    templateProposalId?: number;
    templateId?: number;
    template?: TemplateDetailsDto;

    constructor(data?: ITemplateProposalTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateProposalId = _data["templateProposalId"];
            this.templateId = _data["templateId"];
            this.template = _data["template"] ? TemplateDetailsDto.fromJS(_data["template"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TemplateProposalTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateProposalTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateProposalId"] = this.templateProposalId;
        data["templateId"] = this.templateId;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITemplateProposalTemplateDto {
    templateProposalId?: number;
    templateId?: number;
    template?: TemplateDetailsDto;
}

export class TemplateDetailsDto implements ITemplateDetailsDto {
    id?: number;
    label?: string;
    name?: string;
    subject?: string;
    body?: string;
    colour?: string;
    day?: number;
    attempt?: number;
    type?: string;
    courseNeeded?: boolean;
    courseKnown?: boolean;
    languageId?: number;
    tagId?: number;
    team?: string | undefined;
    language?: LanguageDto;
    order?: number | undefined;
    fromEmail?: string | undefined;

    constructor(data?: ITemplateDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.label = _data["label"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.colour = _data["colour"];
            this.day = _data["day"];
            this.attempt = _data["attempt"];
            this.type = _data["type"];
            this.courseNeeded = _data["courseNeeded"];
            this.courseKnown = _data["courseKnown"];
            this.languageId = _data["languageId"];
            this.tagId = _data["tagId"];
            this.team = _data["team"];
            this.language = _data["language"] ? LanguageDto.fromJS(_data["language"]) : <any>undefined;
            this.order = _data["order"];
            this.fromEmail = _data["fromEmail"];
        }
    }

    static fromJS(data: any): TemplateDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["colour"] = this.colour;
        data["day"] = this.day;
        data["attempt"] = this.attempt;
        data["type"] = this.type;
        data["courseNeeded"] = this.courseNeeded;
        data["courseKnown"] = this.courseKnown;
        data["languageId"] = this.languageId;
        data["tagId"] = this.tagId;
        data["team"] = this.team;
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        data["order"] = this.order;
        data["fromEmail"] = this.fromEmail;
        return data;
    }
}

export interface ITemplateDetailsDto {
    id?: number;
    label?: string;
    name?: string;
    subject?: string;
    body?: string;
    colour?: string;
    day?: number;
    attempt?: number;
    type?: string;
    courseNeeded?: boolean;
    courseKnown?: boolean;
    languageId?: number;
    tagId?: number;
    team?: string | undefined;
    language?: LanguageDto;
    order?: number | undefined;
    fromEmail?: string | undefined;
}

export class TemplateDto implements ITemplateDto {
    id?: number;
    label?: string | undefined;
    name?: string | undefined;
    languageCode?: string | undefined;
    courseNeeded?: boolean;
    type?: string | undefined;
    languageId?: number | undefined;
    language?: LanguageDto | undefined;
    tagId?: number | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    day?: number | undefined;
    attempt?: number | undefined;
    isDeleted?: boolean;
    order?: number | undefined;
    fromEmail?: string | undefined;

    constructor(data?: ITemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.label = _data["label"];
            this.name = _data["name"];
            this.languageCode = _data["languageCode"];
            this.courseNeeded = _data["courseNeeded"];
            this.type = _data["type"];
            this.languageId = _data["languageId"];
            this.language = _data["language"] ? LanguageDto.fromJS(_data["language"]) : <any>undefined;
            this.tagId = _data["tagId"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.day = _data["day"];
            this.attempt = _data["attempt"];
            this.isDeleted = _data["isDeleted"];
            this.order = _data["order"];
            this.fromEmail = _data["fromEmail"];
        }
    }

    static fromJS(data: any): TemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        data["name"] = this.name;
        data["languageCode"] = this.languageCode;
        data["courseNeeded"] = this.courseNeeded;
        data["type"] = this.type;
        data["languageId"] = this.languageId;
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        data["tagId"] = this.tagId;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["day"] = this.day;
        data["attempt"] = this.attempt;
        data["isDeleted"] = this.isDeleted;
        data["order"] = this.order;
        data["fromEmail"] = this.fromEmail;
        return data;
    }
}

export interface ITemplateDto {
    id?: number;
    label?: string | undefined;
    name?: string | undefined;
    languageCode?: string | undefined;
    courseNeeded?: boolean;
    type?: string | undefined;
    languageId?: number | undefined;
    language?: LanguageDto | undefined;
    tagId?: number | undefined;
    subject?: string | undefined;
    body?: string | undefined;
    day?: number | undefined;
    attempt?: number | undefined;
    isDeleted?: boolean;
    order?: number | undefined;
    fromEmail?: string | undefined;
}

export class SetTemplateInTemplateProposalCommand implements ISetTemplateInTemplateProposalCommand {
    templateProposalId?: number;
    templateId?: number;

    constructor(data?: ISetTemplateInTemplateProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateProposalId = _data["templateProposalId"];
            this.templateId = _data["templateId"];
        }
    }

    static fromJS(data: any): SetTemplateInTemplateProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetTemplateInTemplateProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateProposalId"] = this.templateProposalId;
        data["templateId"] = this.templateId;
        return data;
    }
}

export interface ISetTemplateInTemplateProposalCommand {
    templateProposalId?: number;
    templateId?: number;
}

export class PaginatedListOfTemplateDto implements IPaginatedListOfTemplateDto {
    items?: TemplateDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TemplateDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPaginatedListOfTemplateDto {
    items?: TemplateDto[];
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class TemplateCreateDto implements ITemplateCreateDto {
    label?: string;
    name?: string;
    subject?: string;
    body?: string;
    type?: TemplateType;
    languageCode?: string;
    courseNeeded?: boolean;
    moduleId?: number | undefined;
    tagId?: number | undefined;
    order?: number | undefined;

    constructor(data?: ITemplateCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.type = _data["type"];
            this.languageCode = _data["languageCode"];
            this.courseNeeded = _data["courseNeeded"];
            this.moduleId = _data["moduleId"];
            this.tagId = _data["tagId"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): TemplateCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["type"] = this.type;
        data["languageCode"] = this.languageCode;
        data["courseNeeded"] = this.courseNeeded;
        data["moduleId"] = this.moduleId;
        data["tagId"] = this.tagId;
        data["order"] = this.order;
        return data;
    }
}

export interface ITemplateCreateDto {
    label?: string;
    name?: string;
    subject?: string;
    body?: string;
    type?: TemplateType;
    languageCode?: string;
    courseNeeded?: boolean;
    moduleId?: number | undefined;
    tagId?: number | undefined;
    order?: number | undefined;
}

export class CreateTemplateCommand extends TemplateCreateDto implements ICreateTemplateCommand {

    constructor(data?: ICreateTemplateCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateTemplateCommand extends ITemplateCreateDto {
}

export enum TemplateType {
    Email = "email",
    WhatsApp = "whatsapp",
    Argument = "argument",
}

export class TemplateUpdateDto implements ITemplateUpdateDto {
    id?: number;
    label?: string;
    name?: string;
    subject?: string;
    body?: string;
    type?: TemplateType;
    languageCode?: string;
    courseNeeded?: boolean;
    tagId?: number | undefined;
    order?: number | undefined;

    constructor(data?: ITemplateUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.label = _data["label"];
            this.name = _data["name"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.type = _data["type"];
            this.languageCode = _data["languageCode"];
            this.courseNeeded = _data["courseNeeded"];
            this.tagId = _data["tagId"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): TemplateUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["label"] = this.label;
        data["name"] = this.name;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["type"] = this.type;
        data["languageCode"] = this.languageCode;
        data["courseNeeded"] = this.courseNeeded;
        data["tagId"] = this.tagId;
        data["order"] = this.order;
        return data;
    }
}

export interface ITemplateUpdateDto {
    id?: number;
    label?: string;
    name?: string;
    subject?: string;
    body?: string;
    type?: TemplateType;
    languageCode?: string;
    courseNeeded?: boolean;
    tagId?: number | undefined;
    order?: number | undefined;
}

export class UpdateTemplateCommand extends TemplateUpdateDto implements IUpdateTemplateCommand {

    constructor(data?: IUpdateTemplateCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): UpdateTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateTemplateCommand extends ITemplateUpdateDto {
}

export class DeleteTemplateInTemplateProposalCommand implements IDeleteTemplateInTemplateProposalCommand {
    templateProposalId?: number;
    templateId?: number;

    constructor(data?: IDeleteTemplateInTemplateProposalCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateProposalId = _data["templateProposalId"];
            this.templateId = _data["templateId"];
        }
    }

    static fromJS(data: any): DeleteTemplateInTemplateProposalCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTemplateInTemplateProposalCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateProposalId"] = this.templateProposalId;
        data["templateId"] = this.templateId;
        return data;
    }
}

export interface IDeleteTemplateInTemplateProposalCommand {
    templateProposalId?: number;
    templateId?: number;
}

export class TemplateBundleProposalViewModel implements ITemplateBundleProposalViewModel {
    emailTemplate?: TemplateDto;
    whatsAppTemplate?: TemplateDto;
    hasToSendEmail?: boolean;
    hasToSendWhatsapp?: boolean;

    constructor(data?: ITemplateBundleProposalViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailTemplate = _data["emailTemplate"] ? TemplateDto.fromJS(_data["emailTemplate"]) : <any>undefined;
            this.whatsAppTemplate = _data["whatsAppTemplate"] ? TemplateDto.fromJS(_data["whatsAppTemplate"]) : <any>undefined;
            this.hasToSendEmail = _data["hasToSendEmail"];
            this.hasToSendWhatsapp = _data["hasToSendWhatsapp"];
        }
    }

    static fromJS(data: any): TemplateBundleProposalViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateBundleProposalViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailTemplate"] = this.emailTemplate ? this.emailTemplate.toJSON() : <any>undefined;
        data["whatsAppTemplate"] = this.whatsAppTemplate ? this.whatsAppTemplate.toJSON() : <any>undefined;
        data["hasToSendEmail"] = this.hasToSendEmail;
        data["hasToSendWhatsapp"] = this.hasToSendWhatsapp;
        return data;
    }
}

export interface ITemplateBundleProposalViewModel {
    emailTemplate?: TemplateDto;
    whatsAppTemplate?: TemplateDto;
    hasToSendEmail?: boolean;
    hasToSendWhatsapp?: boolean;
}

export class AffectedTemplatesViewModel implements IAffectedTemplatesViewModel {
    oldContentValue?: string;
    newContentValue?: string;
    affectedTemplates?: number[];
    affectedTemplateLanguages?: (number | undefined)[];

    constructor(data?: IAffectedTemplatesViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldContentValue = _data["oldContentValue"];
            this.newContentValue = _data["newContentValue"];
            if (Array.isArray(_data["affectedTemplates"])) {
                this.affectedTemplates = [] as any;
                for (let item of _data["affectedTemplates"])
                    this.affectedTemplates!.push(item);
            }
            if (Array.isArray(_data["affectedTemplateLanguages"])) {
                this.affectedTemplateLanguages = [] as any;
                for (let item of _data["affectedTemplateLanguages"])
                    this.affectedTemplateLanguages!.push(item);
            }
        }
    }

    static fromJS(data: any): AffectedTemplatesViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AffectedTemplatesViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldContentValue"] = this.oldContentValue;
        data["newContentValue"] = this.newContentValue;
        if (Array.isArray(this.affectedTemplates)) {
            data["affectedTemplates"] = [];
            for (let item of this.affectedTemplates)
                data["affectedTemplates"].push(item);
        }
        if (Array.isArray(this.affectedTemplateLanguages)) {
            data["affectedTemplateLanguages"] = [];
            for (let item of this.affectedTemplateLanguages)
                data["affectedTemplateLanguages"].push(item);
        }
        return data;
    }
}

export interface IAffectedTemplatesViewModel {
    oldContentValue?: string;
    newContentValue?: string;
    affectedTemplates?: number[];
    affectedTemplateLanguages?: (number | undefined)[];
}

export class UploadTemplateAuditoryCommand implements IUploadTemplateAuditoryCommand {
    file?: string;
    date?: Date | undefined;

    constructor(data?: IUploadTemplateAuditoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UploadTemplateAuditoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UploadTemplateAuditoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IUploadTemplateAuditoryCommand {
    file?: string;
    date?: Date | undefined;
}

export class WebEnrollmentDto implements IWebEnrollmentDto {
    guid?: string | undefined;
    price?: number | undefined;
    priceFormatted?: string;
    finalPrice?: number | undefined;
    finalPriceFormatted?: string;
    discountPercentage?: number | undefined;
    enrollmentPrice?: number | undefined;
    enrollmentPriceFormatted?: string;
    fees?: number;
    feePrice?: number | undefined;
    feePriceFormatted?: string;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    idCard?: string;
    phonePrefix?: string;
    phonePrefixCountryCode?: string;
    phone?: string;
    validUntil?: Date | undefined;
    countryCode?: string;
    processId?: number;
    contactId?: number;
    vendorId?: number;
    courseTypeBaseCode?: string;
    courseCode?: string;
    languageCode?: string;
    contactEmail?: string;
    token?: string | undefined;
    convocationDate?: Date | undefined;
    university?: University;
    currencyCode?: string;
    currencySymbol?: string;

    constructor(data?: IWebEnrollmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guid = _data["guid"];
            this.price = _data["price"];
            this.priceFormatted = _data["priceFormatted"];
            this.finalPrice = _data["finalPrice"];
            this.finalPriceFormatted = _data["finalPriceFormatted"];
            this.discountPercentage = _data["discountPercentage"];
            this.enrollmentPrice = _data["enrollmentPrice"];
            this.enrollmentPriceFormatted = _data["enrollmentPriceFormatted"];
            this.fees = _data["fees"];
            this.feePrice = _data["feePrice"];
            this.feePriceFormatted = _data["feePriceFormatted"];
            this.name = _data["name"];
            this.firstSurName = _data["firstSurName"];
            this.secondSurName = _data["secondSurName"];
            this.idCard = _data["idCard"];
            this.phonePrefix = _data["phonePrefix"];
            this.phonePrefixCountryCode = _data["phonePrefixCountryCode"];
            this.phone = _data["phone"];
            this.validUntil = _data["validUntil"] ? new Date(_data["validUntil"].toString()) : <any>undefined;
            this.countryCode = _data["countryCode"];
            this.processId = _data["processId"];
            this.contactId = _data["contactId"];
            this.vendorId = _data["vendorId"];
            this.courseTypeBaseCode = _data["courseTypeBaseCode"];
            this.courseCode = _data["courseCode"];
            this.languageCode = _data["languageCode"];
            this.contactEmail = _data["contactEmail"];
            this.token = _data["token"];
            this.convocationDate = _data["convocationDate"] ? new Date(_data["convocationDate"].toString()) : <any>undefined;
            this.university = _data["university"];
            this.currencyCode = _data["currencyCode"];
            this.currencySymbol = _data["currencySymbol"];
        }
    }

    static fromJS(data: any): WebEnrollmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new WebEnrollmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guid"] = this.guid;
        data["price"] = this.price;
        data["priceFormatted"] = this.priceFormatted;
        data["finalPrice"] = this.finalPrice;
        data["finalPriceFormatted"] = this.finalPriceFormatted;
        data["discountPercentage"] = this.discountPercentage;
        data["enrollmentPrice"] = this.enrollmentPrice;
        data["enrollmentPriceFormatted"] = this.enrollmentPriceFormatted;
        data["fees"] = this.fees;
        data["feePrice"] = this.feePrice;
        data["feePriceFormatted"] = this.feePriceFormatted;
        data["name"] = this.name;
        data["firstSurName"] = this.firstSurName;
        data["secondSurName"] = this.secondSurName;
        data["idCard"] = this.idCard;
        data["phonePrefix"] = this.phonePrefix;
        data["phonePrefixCountryCode"] = this.phonePrefixCountryCode;
        data["phone"] = this.phone;
        data["validUntil"] = this.validUntil ? this.validUntil.toISOString() : <any>undefined;
        data["countryCode"] = this.countryCode;
        data["processId"] = this.processId;
        data["contactId"] = this.contactId;
        data["vendorId"] = this.vendorId;
        data["courseTypeBaseCode"] = this.courseTypeBaseCode;
        data["courseCode"] = this.courseCode;
        data["languageCode"] = this.languageCode;
        data["contactEmail"] = this.contactEmail;
        data["token"] = this.token;
        data["convocationDate"] = this.convocationDate ? this.convocationDate.toISOString() : <any>undefined;
        data["university"] = this.university;
        data["currencyCode"] = this.currencyCode;
        data["currencySymbol"] = this.currencySymbol;
        return data;
    }
}

export interface IWebEnrollmentDto {
    guid?: string | undefined;
    price?: number | undefined;
    priceFormatted?: string;
    finalPrice?: number | undefined;
    finalPriceFormatted?: string;
    discountPercentage?: number | undefined;
    enrollmentPrice?: number | undefined;
    enrollmentPriceFormatted?: string;
    fees?: number;
    feePrice?: number | undefined;
    feePriceFormatted?: string;
    name?: string;
    firstSurName?: string;
    secondSurName?: string;
    idCard?: string;
    phonePrefix?: string;
    phonePrefixCountryCode?: string;
    phone?: string;
    validUntil?: Date | undefined;
    countryCode?: string;
    processId?: number;
    contactId?: number;
    vendorId?: number;
    courseTypeBaseCode?: string;
    courseCode?: string;
    languageCode?: string;
    contactEmail?: string;
    token?: string | undefined;
    convocationDate?: Date | undefined;
    university?: University;
    currencyCode?: string;
    currencySymbol?: string;
}

export class CreateWebEnrollmentCommand extends WebEnrollmentDto implements ICreateWebEnrollmentCommand {

    constructor(data?: ICreateWebEnrollmentCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): CreateWebEnrollmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateWebEnrollmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateWebEnrollmentCommand extends IWebEnrollmentDto {
}

export class WhatsappSendDto implements IWhatsappSendDto {
    contactId?: number;
    actionId?: number | undefined;
    processId?: number | undefined;
    whatsappTemplateId?: number | undefined;
    courseId?: number | undefined;
    from?: string | undefined;
    fromName?: string | undefined;
    to?: string | undefined;
    message?: string | undefined;
    contactLeadId?: number | undefined;

    constructor(data?: IWhatsappSendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contactId = _data["contactId"];
            this.actionId = _data["actionId"];
            this.processId = _data["processId"];
            this.whatsappTemplateId = _data["whatsappTemplateId"];
            this.courseId = _data["courseId"];
            this.from = _data["from"];
            this.fromName = _data["fromName"];
            this.to = _data["to"];
            this.message = _data["message"];
            this.contactLeadId = _data["contactLeadId"];
        }
    }

    static fromJS(data: any): WhatsappSendDto {
        data = typeof data === 'object' ? data : {};
        let result = new WhatsappSendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contactId"] = this.contactId;
        data["actionId"] = this.actionId;
        data["processId"] = this.processId;
        data["whatsappTemplateId"] = this.whatsappTemplateId;
        data["courseId"] = this.courseId;
        data["from"] = this.from;
        data["fromName"] = this.fromName;
        data["to"] = this.to;
        data["message"] = this.message;
        data["contactLeadId"] = this.contactLeadId;
        return data;
    }
}

export interface IWhatsappSendDto {
    contactId?: number;
    actionId?: number | undefined;
    processId?: number | undefined;
    whatsappTemplateId?: number | undefined;
    courseId?: number | undefined;
    from?: string | undefined;
    fromName?: string | undefined;
    to?: string | undefined;
    message?: string | undefined;
    contactLeadId?: number | undefined;
}

export class SendWhatsappCommand extends WhatsappSendDto implements ISendWhatsappCommand {

    constructor(data?: ISendWhatsappCommand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): SendWhatsappCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SendWhatsappCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISendWhatsappCommand extends IWhatsappSendDto {
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class Intranet_CrmException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isIntranet_CrmException = true;

    static isIntranet_CrmException(obj: any): obj is Intranet_CrmException {
        return obj.isIntranet_CrmException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new Intranet_CrmException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}